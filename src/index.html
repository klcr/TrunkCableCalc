<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>低圧幹線ケーブル計算ツール</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; overflow: hidden; }
body {
  font-family: 'Noto Sans JP', 'Hiragino Kaku Gothic ProN', Meiryo, sans-serif;
  font-size: 14px;
  color: #333;
  background: #f5f5f5;
}
@media print {
  body { font-family: 'MS Gothic', 'Hiragino Kaku Gothic ProN', monospace; }
}
</style>
</head>
<body>
<div id="root"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>

<script type="text/babel">
/* === DATA TABLES === */
/* __DATA__ */

/* === TREE UTILITIES === */

function genId() {
  return typeof crypto !== 'undefined' && crypto.randomUUID
    ? crypto.randomUUID()
    : Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
}

function getChildren(nodes, parentId) {
  return nodes.filter(n => n.parentId === parentId).sort((a, b) => a.order - b.order);
}

function getParent(nodes, id) {
  const node = nodes.find(n => n.id === id);
  return node && node.parentId ? nodes.find(n => n.id === node.parentId) : null;
}

function getAncestors(nodes, id) {
  const result = [];
  let cur = nodes.find(n => n.id === id);
  while (cur && cur.parentId) {
    cur = nodes.find(n => n.id === cur.parentId);
    if (cur) result.push(cur);
  }
  return result;
}

function getDepth(nodes, id) {
  let d = 0, cur = nodes.find(n => n.id === id);
  while (cur && cur.parentId) {
    cur = nodes.find(n => n.id === cur.parentId);
    d++;
  }
  return d;
}

function getDescendants(nodes, id) {
  const result = [];
  const stack = getChildren(nodes, id).slice();
  while (stack.length) {
    const n = stack.pop();
    result.push(n);
    stack.push(...getChildren(nodes, n.id));
  }
  return result;
}

function buildTree(nodes) {
  const roots = nodes.filter(n => !n.parentId).sort((a, b) => a.order - b.order);
  const attach = (node) => ({
    ...node,
    children: getChildren(nodes, node.id).map(attach)
  });
  return roots.map(attach);
}

function validateNode(nodes, node) {
  const depth = node.parentId ? getDepth(nodes, node.parentId) + 1 : 0;
  if (depth > 3) return 'depth exceeds 3';
  if (node.type === 'transformer' && depth !== 0) return 'transformer must be root';
  if (node.type === 'trunk' && depth < 1 && nodes.some(n => n.type === 'transformer')) return 'trunk must be under transformer';
  if (node.type === 'load') {
    const parent = node.parentId ? nodes.find(n => n.id === node.parentId) : null;
    if (!parent || parent.type !== 'trunk') return 'load must be under trunk';
  }
  return null;
}

function addNode(nodes, node) {
  const err = validateNode(nodes, node);
  if (err) { console.warn('addNode:', err); return nodes; }
  return [...nodes, node];
}

function updateNode(nodes, id, patch) {
  return nodes.map(n => n.id === id ? { ...n, ...patch, id: n.id, type: n.type, ts: new Date().toISOString() } : n);
}

function removeNode(nodes, id) {
  const descIds = new Set(getDescendants(nodes, id).map(n => n.id));
  descIds.add(id);
  return nodes.filter(n => !descIds.has(n.id));
}

/* === CALC ENGINE === */

/* --- 定数・ヘルパー --- */
const SIZES_CVT = [8, 14, 22, 38, 60, 100, 150, 200, 250, 325];
const SIZES_CV  = [2, 3.5, 5.5, 8, 14, 22, 38, 60, 100, 150, 200, 250, 325];

function getCableSizes(ct) {
  return (ct === 'CVT' || ct === 'CVD') ? SIZES_CVT : SIZES_CV;
}

function getImpTable(ct) {
  return (ct === 'CVT' || ct === 'CVD') ? IMP_CVT : IMP_CV;
}

function getAmpTable(wm) {
  const m = { 'ケーブルラック配線': A_RACK, '配管配線': A_COND, '直埋布設': A_DIRECT, '管路布設': A_DUCT };
  return m[wm] || A_RACK;
}

/** 基本許容電流を取得。データ未整備の場合は null */
function getBaseAmpacity(ct, wm, sz) {
  const t = getAmpTable(wm)[ct];
  if (!t) return null;
  const i = t.sizes_mm2.indexOf(sz);
  return (i >= 0 && i < t.ampacity.length) ? t.ampacity[i] : null;
}

/** インピーダンス [R, X] を取得 */
function getImpedance(ct, freq, sz) {
  const t = getImpTable(ct);
  return (t[freq] && t[freq][String(sz)]) || null;
}

/** 温度補正係数（線形補間対応） */
function getTempFactor(wm, temp) {
  const env = (wm === '直埋布設' || wm === '管路布設') ? 'ground' : 'air';
  const f = TC[env].factors;
  const ts = Object.keys(f).map(Number).sort((a, b) => a - b);
  if (temp <= ts[0]) return f[ts[0]];
  if (temp >= ts[ts.length - 1]) return f[ts[ts.length - 1]];
  for (let i = 0; i < ts.length - 1; i++) {
    if (temp >= ts[i] && temp <= ts[i + 1]) {
      return f[ts[i]] + (f[ts[i + 1]] - f[ts[i]]) * (temp - ts[i]) / (ts[i + 1] - ts[i]);
    }
  }
  return 1.0;
}

/** 電圧降下の方式係数 K と基準電圧 (§8-4) */
function getVdParams(sys, V) {
  switch (sys) {
    case '単相2線式': return { K: 2, baseV: V };
    case '単相3線式': return { K: 1, baseV: 100 };
    case '三相3線式': return { K: Math.sqrt(3), baseV: V };
    case '三相4線式': return { K: 1, baseV: V / Math.sqrt(3) };
    default: return { K: Math.sqrt(3), baseV: V };
  }
}

/** 許容電圧降下率 [%] (§8-5) */
function getAllowVdP(L, sup) {
  const h = sup === '高圧受電';
  if (L <= 60)  return h ? 3 : 2;
  if (L <= 120) return h ? 5 : 4;
  if (L <= 200) return h ? 6 : 5;
  return h ? 7 : 6;
}

/** MCCB 自動選定 (§8-6) */
function selectMCCB(dI, circuitType) {
  const th = circuitType === '電動機' ? dI * 1.25 : dI;
  for (const at of MCCB_AT) { if (at >= th) return at; }
  return MCCB_AT[MCCB_AT.length - 1];
}

function isThreePhase(sys) {
  return sys === '三相3線式' || sys === '三相4線式';
}

/** 丸めユーティリティ */
function rd(v, n = 2) { const m = Math.pow(10, n); return Math.round(v * m) / m; }

/**
 * runCalc — 子回路のケーブルサイズ選定 (§8)
 *
 * @param {Object} p - 入力パラメータ
 * @returns {Object} 計算結果（ok, size, dI, sizingI, mccbAT, 各判定フラグ等）
 */
function runCalc(p) {
  /* 8-1: 設計電流 */
  const V = p.voltage, PF = p.powerFactor, EFF = p.efficiency;
  const three = isThreePhase(p.system);
  let rawI;
  if (p.unit === 'kW') {
    rawI = three
      ? p.capacity * 1000 / (Math.sqrt(3) * V * PF * EFF)
      : p.capacity * 1000 / (V * PF * EFF);
  } else if (p.unit === 'kVA') {
    rawI = three
      ? p.capacity * 1000 / (Math.sqrt(3) * V)
      : p.capacity * 1000 / V;
  } else {
    rawI = p.capacity;
  }
  const dI = rawI * p.demandFactor / 100;

  /* 8-2: 電動機電流補正 */
  const sizingI = p.circuitType === '電動機'
    ? (dI <= 50 ? dI * 1.25 : dI * 1.1)
    : dI;

  /* 電圧降下パラメータ */
  const { K, baseV } = getVdParams(p.system, V);
  const sinT = Math.sqrt(1 - PF * PF);
  const allowVdP = getAllowVdP(p.cableLength, p.supplyType);

  /* 温度補正 */
  const tF = getTempFactor(p.wiringMethod, p.ambientTemp);

  /* MCCB（ケーブルサイズに依存しないため先に決定） */
  const mccbAT = p.mccbATOverride !== '自動'
    ? Number(p.mccbATOverride)
    : selectMCCB(dI, p.circuitType);

  const sizes = getCableSizes(p.cableType);

  /* 8-3: 3条件走査 — 許容電流→電圧降下→保護協調 */
  for (const sz of sizes) {
    /* Step 1: 許容電流 */
    const bA = getBaseAmpacity(p.cableType, p.wiringMethod, sz);
    if (bA === null) continue;
    const eA = bA * tF * p.reductionFactor;
    if (eA < sizingI) continue;

    /* Step 2: 電圧降下（精密式 R·cosθ + X·sinθ） */
    const imp = getImpedance(p.cableType, p.freq, sz);
    if (!imp) continue;
    const Z = imp[0] * PF + imp[1] * sinT;
    const vd = K * dI * (p.cableLength / 1000) * Z;
    const vdP = baseV > 0 ? vd / baseV * 100 : 0;
    if (vdP > allowVdP) continue;

    /* Step 3: 保護協調 */
    const protOK = p.circuitType === '電動機' ? eA >= mccbAT / 2.5 : eA >= mccbAT;
    if (!protOK) continue;

    return {
      ok: true, size: sz, parallel: 1, dI: rd(dI), sizingI: rd(sizingI), mccbAT,
      baseAmpacity: bA, tempFactor: rd(tF, 3), reductionFactor: p.reductionFactor,
      effectiveAmpacity: rd(eA), Z: rd(Z, 4), K,
      vd: rd(vd), vdPercent: rd(vdP),
      allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
      ampacityOK: true, vdOK: true, protOK: true
    };
  }

  /* 325×2 並列試行 — 単線で全サイズ不適合の場合 */
  {
    const sz2 = 325;
    const bA2 = getBaseAmpacity(p.cableType, p.wiringMethod, sz2);
    const imp2 = getImpedance(p.cableType, p.freq, sz2);
    if (bA2 !== null && imp2) {
      const eA2 = bA2 * 2 * tF * p.reductionFactor;
      const Z2 = (imp2[0] * PF + imp2[1] * sinT) / 2;
      const vd2 = K * dI * (p.cableLength / 1000) * Z2;
      const vdP2 = baseV > 0 ? vd2 / baseV * 100 : 0;
      const protOK2 = p.circuitType === '電動機' ? eA2 >= mccbAT / 2.5 : eA2 >= mccbAT;
      if (eA2 >= sizingI && vdP2 <= allowVdP && protOK2) {
        return {
          ok: true, size: sz2, parallel: 2, dI: rd(dI), sizingI: rd(sizingI), mccbAT,
          baseAmpacity: bA2 * 2, tempFactor: rd(tF, 3), reductionFactor: p.reductionFactor,
          effectiveAmpacity: rd(eA2), Z: rd(Z2, 4), K,
          vd: rd(vd2), vdPercent: rd(vdP2),
          allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
          ampacityOK: true, vdOK: true, protOK: true
        };
      }
      /* 325×2 でも不適合 — NG 結果を返す */
      return {
        ok: false, size: sz2, parallel: 2, dI: rd(dI), sizingI: rd(sizingI), mccbAT,
        baseAmpacity: bA2 * 2, tempFactor: rd(tF, 3), reductionFactor: p.reductionFactor,
        effectiveAmpacity: rd(eA2), Z: rd(Z2, 4), K,
        vd: rd(vd2), vdPercent: rd(vdP2),
        allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
        ampacityOK: eA2 >= sizingI, vdOK: vdP2 <= allowVdP,
        protOK: p.circuitType === '電動機' ? eA2 >= mccbAT / 2.5 : eA2 >= mccbAT
      };
    }
  }

  /* 全サイズ不適合（325データなし） — 最大サイズで NG 結果を返す */
  const sz = sizes[sizes.length - 1];
  const bA = getBaseAmpacity(p.cableType, p.wiringMethod, sz);
  const eA = bA !== null ? bA * tF * p.reductionFactor : 0;
  const imp = getImpedance(p.cableType, p.freq, sz);
  const Z = imp ? imp[0] * PF + imp[1] * sinT : 0;
  const vd = K * dI * (p.cableLength / 1000) * Z;
  const vdP = baseV > 0 ? vd / baseV * 100 : 0;

  return {
    ok: false, size: sz, parallel: 1, dI: rd(dI), sizingI: rd(sizingI), mccbAT,
    baseAmpacity: bA || 0, tempFactor: rd(tF, 3), reductionFactor: p.reductionFactor,
    effectiveAmpacity: rd(eA), Z: rd(Z, 4), K,
    vd: rd(vd), vdPercent: rd(vdP),
    allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
    ampacityOK: eA >= sizingI, vdOK: vdP <= allowVdP,
    protOK: p.circuitType === '電動機' ? eA >= mccbAT / 2.5 : eA >= mccbAT
  };
}

/**
 * runParentCalc — 親幹線のケーブルサイズ選定 (§9)
 *
 * @param {Array} children - 子回路の配列 [{ params, result }, ...]
 * @param {Object} cfg - 親幹線設定（cableLength, powerFactor, cableType, wiringMethod, ambientTemp, reductionFactor, mccbATOverride）
 * @returns {Object|null} 計算結果。children が空なら null
 */
function runParentCalc(children, cfg) {
  if (!children || children.length === 0) return null;

  /* 子回路の電気方式等を継承 */
  const first = children[0].params;
  const sys = first.system, V = first.voltage, freq = first.freq, sup = first.supplyType;

  /* 9-3: 設計電流の分類集計 */
  let sumIM = 0, sumIH = 0, hasMotor = false;
  for (const c of children) {
    if (c.params.circuitType === '電動機') { sumIM += c.result.dI; hasMotor = true; }
    else sumIH += c.result.dI;
  }
  const totalI = sumIM + sumIH;
  const sizingI = hasMotor
    ? (sumIM <= 50 ? sumIM * 1.25 + sumIH : sumIM * 1.1 + sumIH)
    : totalI;

  const PF = cfg.powerFactor;
  const { K, baseV } = getVdParams(sys, V);
  const sinT = Math.sqrt(1 - PF * PF);
  const allowVdP = getAllowVdP(cfg.cableLength, sup);
  const tF = getTempFactor(cfg.wiringMethod, cfg.ambientTemp);

  /* 9-4: MCCB */
  const mccbTh = hasMotor ? totalI * 1.25 : totalI;
  const mccbAT = cfg.mccbATOverride !== '自動'
    ? Number(cfg.mccbATOverride)
    : (() => { for (const at of MCCB_AT) { if (at >= mccbTh) return at; } return MCCB_AT[MCCB_AT.length - 1]; })();

  const sizes = getCableSizes(cfg.cableType);

  /* ケーブルサイズ走査 */
  for (const sz of sizes) {
    const bA = getBaseAmpacity(cfg.cableType, cfg.wiringMethod, sz);
    if (bA === null) continue;
    const eA = bA * tF * cfg.reductionFactor;
    if (eA < sizingI) continue;

    const imp = getImpedance(cfg.cableType, freq, sz);
    if (!imp) continue;
    const Z = imp[0] * PF + imp[1] * sinT;
    const vd = K * totalI * (cfg.cableLength / 1000) * Z;
    const vdP = baseV > 0 ? vd / baseV * 100 : 0;
    if (vdP > allowVdP) continue;

    /* 9-5: 保護協調 */
    const protOK = hasMotor ? eA >= mccbAT / 2.5 : eA >= mccbAT;
    if (!protOK) continue;

    return {
      ok: true, size: sz, parallel: 1, totalI: rd(totalI), sumIM: rd(sumIM), sumIH: rd(sumIH),
      hasMotor, sizingI: rd(sizingI), mccbAT,
      baseAmpacity: bA, tempFactor: rd(tF, 3), reductionFactor: cfg.reductionFactor,
      effectiveAmpacity: rd(eA), Z: rd(Z, 4), K,
      vd: rd(vd), vdPercent: rd(vdP),
      allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
      ampacityOK: true, vdOK: true, protOK: true
    };
  }

  /* 325×2 並列試行 */
  {
    const sz2 = 325;
    const bA2 = getBaseAmpacity(cfg.cableType, cfg.wiringMethod, sz2);
    const imp2 = getImpedance(cfg.cableType, freq, sz2);
    if (bA2 !== null && imp2) {
      const eA2 = bA2 * 2 * tF * cfg.reductionFactor;
      const Z2 = (imp2[0] * PF + imp2[1] * sinT) / 2;
      const vd2 = K * totalI * (cfg.cableLength / 1000) * Z2;
      const vdP2 = baseV > 0 ? vd2 / baseV * 100 : 0;
      const protOK2 = hasMotor ? eA2 >= mccbAT / 2.5 : eA2 >= mccbAT;
      if (eA2 >= sizingI && vdP2 <= allowVdP && protOK2) {
        return {
          ok: true, size: sz2, parallel: 2, totalI: rd(totalI), sumIM: rd(sumIM), sumIH: rd(sumIH),
          hasMotor, sizingI: rd(sizingI), mccbAT,
          baseAmpacity: bA2 * 2, tempFactor: rd(tF, 3), reductionFactor: cfg.reductionFactor,
          effectiveAmpacity: rd(eA2), Z: rd(Z2, 4), K,
          vd: rd(vd2), vdPercent: rd(vdP2),
          allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
          ampacityOK: true, vdOK: true, protOK: true
        };
      }
      return {
        ok: false, size: sz2, parallel: 2, totalI: rd(totalI), sumIM: rd(sumIM), sumIH: rd(sumIH),
        hasMotor, sizingI: rd(sizingI), mccbAT,
        baseAmpacity: bA2 * 2, tempFactor: rd(tF, 3), reductionFactor: cfg.reductionFactor,
        effectiveAmpacity: rd(eA2), Z: rd(Z2, 4), K,
        vd: rd(vd2), vdPercent: rd(vdP2),
        allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
        ampacityOK: eA2 >= sizingI, vdOK: vdP2 <= allowVdP,
        protOK: hasMotor ? eA2 >= mccbAT / 2.5 : eA2 >= mccbAT
      };
    }
  }

  /* 全サイズ不適合（325データなし） */
  const sz = sizes[sizes.length - 1];
  const bA = getBaseAmpacity(cfg.cableType, cfg.wiringMethod, sz);
  const eA = bA !== null ? bA * tF * cfg.reductionFactor : 0;
  const imp = getImpedance(cfg.cableType, freq, sz);
  const Z = imp ? imp[0] * PF + imp[1] * sinT : 0;
  const vd = K * totalI * (cfg.cableLength / 1000) * Z;
  const vdP = baseV > 0 ? vd / baseV * 100 : 0;

  return {
    ok: false, size: sz, parallel: 1, totalI: rd(totalI), sumIM: rd(sumIM), sumIH: rd(sumIH),
    hasMotor, sizingI: rd(sizingI), mccbAT,
    baseAmpacity: bA || 0, tempFactor: rd(tF, 3), reductionFactor: cfg.reductionFactor,
    effectiveAmpacity: rd(eA), Z: rd(Z, 4), K,
    vd: rd(vd), vdPercent: rd(vdP),
    allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
    ampacityOK: eA >= sizingI, vdOK: vdP <= allowVdP,
    protOK: hasMotor ? eA >= mccbAT / 2.5 : eA >= mccbAT
  };
}

/**
 * calcTransformer — 変圧器ノードの計算 (§19-3)
 */
function calcTransformer(tr) {
  const S = tr.capacity_kVA * 1000;
  const Vs = tr.secondaryV;
  const threePhase = tr.trType !== '単相油入';
  let Rs, Xs;
  if (tr.xrRatio != null && tr.xrRatio > 0) {
    const pctR = tr.pctZ / Math.sqrt(1 + tr.xrRatio * tr.xrRatio);
    const pctX = pctR * tr.xrRatio;
    Rs = (pctR / 100) * Vs * Vs / S;
    Xs = (pctX / 100) * Vs * Vs / S;
  } else {
    Rs = (tr.pctZ / 100) * Vs * Vs / S;
    Xs = 0;
  }
  const Zs = Math.sqrt(Rs * Rs + Xs * Xs);
  const In = threePhase ? S / (Math.sqrt(3) * Vs) : S / Vs;
  const Isc3 = threePhase ? Vs / (Math.sqrt(3) * Zs) : Vs / Zs;
  return { Rs, Xs, Zs, In, Isc3, pctZ: tr.pctZ, capacity_kVA: tr.capacity_kVA, threePhase };
}

/**
 * aggregateCurrents — ボトムアップ電流合算 (§9-3)
 */
function aggregateCurrents(nodes, trunkId, allResults) {
  const children = getChildren(nodes, trunkId);
  let sumIM = 0, sumIH = 0;
  for (const child of children) {
    if (child.type === 'trunk') {
      const sub = aggregateCurrents(nodes, child.id, allResults);
      sumIM += sub.sumIM;
      sumIH += sub.sumIH;
    } else if (child.type === 'load') {
      const r = allResults[child.id];
      if (!r) continue;
      if (child.load.circuitType === '電動機') sumIM += r.dI;
      else sumIH += r.dI;
    }
  }
  return { sumIM, sumIH, totalI: sumIM + sumIH, hasMotor: sumIM > 0 };
}

/**
 * runTrunkCalc — 幹線ノードのケーブルサイズ選定
 */
function runTrunkCalc(trunk, agg) {
  const { sumIM, sumIH, totalI, hasMotor } = agg;
  if (totalI === 0) return null;

  const sys = trunk.system, V = trunk.voltage, freq = trunk.freq, sup = trunk.supplyType;
  const PF = trunk.powerFactor;
  const sizingI = hasMotor
    ? (sumIM <= 50 ? sumIM * 1.25 + sumIH : sumIM * 1.1 + sumIH)
    : totalI;

  const { K, baseV } = getVdParams(sys, V);
  const sinT = Math.sqrt(1 - PF * PF);
  const allowVdP = getAllowVdP(trunk.cableLength, sup);
  const tF = getTempFactor(trunk.wiringMethod, trunk.ambientTemp);

  const mccbTh = hasMotor ? totalI * 1.25 : totalI;
  const mccbAT = trunk.mccbATOverride !== '自動'
    ? Number(trunk.mccbATOverride)
    : (() => { for (const at of MCCB_AT) { if (at >= mccbTh) return at; } return MCCB_AT[MCCB_AT.length - 1]; })();

  const sizes = getCableSizes(trunk.cableType);

  for (const sz of sizes) {
    const bA = getBaseAmpacity(trunk.cableType, trunk.wiringMethod, sz);
    if (bA === null) continue;
    const eA = bA * tF * trunk.reductionFactor;
    if (eA < sizingI) continue;

    const imp = getImpedance(trunk.cableType, freq, sz);
    if (!imp) continue;
    const Z = imp[0] * PF + imp[1] * sinT;
    const vd = K * totalI * (trunk.cableLength / 1000) * Z;
    const vdP = baseV > 0 ? vd / baseV * 100 : 0;
    if (vdP > allowVdP) continue;

    const protOK = hasMotor ? eA >= mccbAT / 2.5 : eA >= mccbAT;
    if (!protOK) continue;

    return {
      ok: true, size: sz, parallel: 1, dI: rd(totalI), totalI: rd(totalI),
      sumIM: rd(sumIM), sumIH: rd(sumIH), hasMotor, sizingI: rd(sizingI), mccbAT,
      baseAmpacity: bA, tempFactor: rd(tF, 3), reductionFactor: trunk.reductionFactor,
      effectiveAmpacity: rd(eA), Z: rd(Z, 4), K,
      vd: rd(vd), vdPercent: rd(vdP),
      allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
      ampacityOK: true, vdOK: true, protOK: true, baseV
    };
  }

  /* 325×2 並列試行 */
  {
    const sz2 = 325;
    const bA2 = getBaseAmpacity(trunk.cableType, trunk.wiringMethod, sz2);
    const imp2 = getImpedance(trunk.cableType, freq, sz2);
    if (bA2 !== null && imp2) {
      const eA2 = bA2 * 2 * tF * trunk.reductionFactor;
      const Z2 = (imp2[0] * PF + imp2[1] * sinT) / 2;
      const vd2 = K * totalI * (trunk.cableLength / 1000) * Z2;
      const vdP2 = baseV > 0 ? vd2 / baseV * 100 : 0;
      const protOK2 = hasMotor ? eA2 >= mccbAT / 2.5 : eA2 >= mccbAT;
      if (eA2 >= sizingI && vdP2 <= allowVdP && protOK2) {
        return {
          ok: true, size: sz2, parallel: 2, dI: rd(totalI), totalI: rd(totalI),
          sumIM: rd(sumIM), sumIH: rd(sumIH), hasMotor, sizingI: rd(sizingI), mccbAT,
          baseAmpacity: bA2 * 2, tempFactor: rd(tF, 3), reductionFactor: trunk.reductionFactor,
          effectiveAmpacity: rd(eA2), Z: rd(Z2, 4), K,
          vd: rd(vd2), vdPercent: rd(vdP2),
          allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
          ampacityOK: true, vdOK: true, protOK: true, baseV
        };
      }
      return {
        ok: false, size: sz2, parallel: 2, dI: rd(totalI), totalI: rd(totalI),
        sumIM: rd(sumIM), sumIH: rd(sumIH), hasMotor, sizingI: rd(sizingI), mccbAT,
        baseAmpacity: bA2 * 2, tempFactor: rd(tF, 3), reductionFactor: trunk.reductionFactor,
        effectiveAmpacity: rd(eA2), Z: rd(Z2, 4), K,
        vd: rd(vd2), vdPercent: rd(vdP2),
        allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
        ampacityOK: eA2 >= sizingI, vdOK: vdP2 <= allowVdP,
        protOK: hasMotor ? eA2 >= mccbAT / 2.5 : eA2 >= mccbAT, baseV
      };
    }
  }

  /* 全サイズ不適合（325データなし） */
  const sz = sizes[sizes.length - 1];
  const bA = getBaseAmpacity(trunk.cableType, trunk.wiringMethod, sz);
  const eA = bA !== null ? bA * tF * trunk.reductionFactor : 0;
  const imp = getImpedance(trunk.cableType, freq, sz);
  const Z = imp ? imp[0] * PF + imp[1] * sinT : 0;
  const vd = K * totalI * (trunk.cableLength / 1000) * Z;
  const vdP = baseV > 0 ? vd / baseV * 100 : 0;

  return {
    ok: false, size: sz, parallel: 1, dI: rd(totalI), totalI: rd(totalI),
    sumIM: rd(sumIM), sumIH: rd(sumIH), hasMotor, sizingI: rd(sizingI), mccbAT,
    baseAmpacity: bA || 0, tempFactor: rd(tF, 3), reductionFactor: trunk.reductionFactor,
    effectiveAmpacity: rd(eA), Z: rd(Z, 4), K,
    vd: rd(vd), vdPercent: rd(vdP),
    allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
    ampacityOK: eA >= sizingI, vdOK: vdP <= allowVdP,
    protOK: hasMotor ? eA >= mccbAT / 2.5 : eA >= mccbAT, baseV
  };
}

/**
 * calcCumulativeVd — トップダウン累積電圧降下 (§20-3)
 */
function calcCumulativeVd(nodes, nodeId, parentCumVd, allResults) {
  const r = allResults[nodeId];
  const cumVd = parentCumVd + (r && r.vd ? r.vd : 0);
  if (r) {
    r.cumulativeVd = rd(cumVd);
    const bV = r.baseV || (r.allowVdPercent && r.allowVd ? r.allowVd / r.allowVdPercent * 100 : 0);
    r.cumulativeVdP = bV > 0 ? rd(cumVd / bV * 100) : 0;
  }
  for (const child of getChildren(nodes, nodeId)) {
    calcCumulativeVd(nodes, child.id, cumVd, allResults);
  }
}

/**
 * calcFaultCurrents — トップダウン R+jX ベクトル累積による短絡電流計算 (§20-2, §20-3)
 */
function calcFaultCurrents(nodes, allResults) {
  /* M2-1: 複数変圧器対応 — 全 transformer ノードをループ */
  const transformers = nodes.filter(n => n.type === 'transformer');
  for (const tr of transformers) {
    const trR = allResults[tr.id];
    if (!trR) continue;
    /* M2-3: HV cable impedance LV conversion (§20-2)
     * 高圧ケーブルインピーダンスを LV 側に換算して Rsrc, Xsrc に加算する。
     * P4 では hvSystem フィールドは全て null のため実行されない。
     *
     * const hv = tr.transformer.hvSystem;
     * let Rsrc = trR.Rs, Xsrc = trR.Xs;
     * if (hv && hv.cableType && hv.cableSize_mm2 && hv.totalCableLength_km) {
     *   const freq = '50Hz'; // TODO: 系統周波数を transformer に持たせる
     *   const hvImp = IMP_HV[freq] && IMP_HV[freq][String(hv.cableSize_mm2)];
     *   if (hvImp) {
     *     const ratio = Math.pow(tr.transformer.secondaryV / tr.transformer.primaryV, 2);
     *     Rsrc += hvImp[0] * hv.totalCableLength_km * ratio;
     *     Xsrc += hvImp[1] * hv.totalCableLength_km * ratio;
     *   }
     * }
     * propagateFault(nodes, tr.id, Rsrc, Xsrc, tr.transformer.secondaryV, allResults);
     */
    propagateFault(nodes, tr.id, trR.Rs, trR.Xs, tr.transformer.secondaryV, allResults);
  }
}

function propagateFault(nodes, nodeId, Rcum, Xcum, Vs, allResults) {
  const r = allResults[nodeId];
  if (r) {
    r.Rcum = Rcum;
    r.Xcum = Xcum;
    r.Zcum = Math.sqrt(Rcum * Rcum + Xcum * Xcum);
    r.Isc3 = Vs / (Math.sqrt(3) * r.Zcum);
  }
  for (const child of getChildren(nodes, nodeId)) {
    let Rc = 0, Xc = 0;
    if (child.type === 'trunk' || child.type === 'load') {
      const cfg = child.type === 'trunk' ? child.trunk : child.load;
      const childR = allResults[child.id];
      if (childR && childR.size) {
        const imp = getImpedance(cfg.cableType, cfg.freq, childR.size);
        if (imp) {
          const Lkm = cfg.cableLength / 1000;
          const par = childR.parallel || 1;
          Rc = imp[0] * Lkm / par;
          Xc = imp[1] * Lkm / par;
        }
      }
    }
    propagateFault(nodes, child.id, Rcum + Rc, Xcum + Xc, Vs, allResults);
  }
}

/**
 * checkWithstand — 短時間耐電流検証 (§20-6)
 */
function checkWithstand(size_mm2, Isc3, t, parallel) {
  t = t || 0.1;
  parallel = parallel || 1;
  const K = 134; /* Cu_XLPE: WITHSTAND.K_constants.Cu_XLPE.K */
  const Iw = K * size_mm2 * parallel / Math.sqrt(t);
  return { ok: Isc3 <= Iw, Iwithstand: rd(Iw), Isc3: rd(Isc3), K, t };
}

/**
 * calculateAll — 全ノード一括計算
 */
function calculateAll(nodes) {
  const results = {};

  /* 1. ボトムアップ: 全 load ノードを計算 */
  for (const n of nodes) {
    if (n.type === 'load') results[n.id] = runCalc(n.load);
  }

  /* 2. ボトムアップ: trunk ノードを深い順に計算 */
  const trunks = nodes.filter(n => n.type === 'trunk')
    .map(n => ({ node: n, depth: getDepth(nodes, n.id) }))
    .sort((a, b) => b.depth - a.depth);
  for (const { node } of trunks) {
    const agg = aggregateCurrents(nodes, node.id, results);
    const r = runTrunkCalc(node.trunk, agg);
    if (r) results[node.id] = r;
  }

  /* 3. transformer ノード */
  for (const n of nodes) {
    if (n.type === 'transformer') results[n.id] = calcTransformer(n.transformer);
  }

  /* 4. トップダウン: 累積電圧降下 */
  const roots = nodes.filter(n => !n.parentId);
  for (const root of roots) {
    calcCumulativeVd(nodes, root.id, 0, results);
  }

  /* 5. トップダウン: 短絡電流 */
  calcFaultCurrents(nodes, results);

  /* M2-3: 一線地絡電流 Ig = 3ωCV (§20-5)
   * 非接地系 6.6kV 系統における一線地絡電流。
   * 変圧器の hvSystem.capacitance_uF_per_km と系統全長から算出。
   *
   * function calcGroundFaultCurrent(freq, capacitance_uF, lineVoltage) {
   *   const omega = 2 * Math.PI * (freq === '50Hz' ? 50 : 60);
   *   const C = capacitance_uF * 1e-6; // [F]
   *   return 3 * omega * C * (lineVoltage / Math.sqrt(3)); // [A]
   * }
   *
   * §20-8: ELCB 保護協調 — TT系統: RA × IΔn ≤ 50V
   * ELCB テーブル (data/elcb-specs.json) の感度電流・動作時間を使用。
   */

  return results;
}

/* === DIAGRAM: DIRECTION FRAMEWORK (M2-4-7) === */

const DIRECTIONS = {
  horizontal: {
    mainAxis: 'x', crossAxis: 'y',
    inPort: 'left', outPort: 'right',
    label: '横型（左→右）'
  },
  vertical: {
    mainAxis: 'y', crossAxis: 'x',
    inPort: 'top', outPort: 'bottom',
    label: '縦型（上→下）'
  }
};

/* モジュールサイズ定数 */
const MOD = {
  TR_W: 200, TR_H: 80,
  TRUNK_W: 260, TRUNK_H: 64,
  LOAD_W: 220, LOAD_H: 56,
  RECV_W: 100, RECV_H: 50,
  PORT_R: 5,
  GAP_MAIN: 120,    /* 主軸方向（左→右）の間隔 */
  GAP_CROSS: 20,    /* 交差軸方向（上→下）の兄弟間隔 */
  MARGIN: 40
};

/* === DIAGRAM: SYMBOLS (M2-4-3) === */

function SvgTransformer({ x, y, w, h, connection }) {
  const r = Math.min(w, h) * 0.22;
  const cx = x + w / 2, cy = y + h / 2;
  const [pri, sec] = (connection || 'Δ-Y').split('-');
  return (
    <g>
      <rect x={x} y={y} width={w} height={h} rx={4} fill="#f3e5f5" stroke="#7b1fa2" strokeWidth={1.5} />
      <circle cx={cx - r * 0.5} cy={cy} r={r} fill="none" stroke="#333" strokeWidth={1.5} />
      <circle cx={cx + r * 0.5} cy={cy} r={r} fill="none" stroke="#333" strokeWidth={1.5} />
      <text x={cx - r * 0.5} y={cy - r - 4} fontSize={9} textAnchor="middle" fill="#555">{pri}</text>
      <text x={cx + r * 0.5} y={cy - r - 4} fontSize={9} textAnchor="middle" fill="#555">{sec}</text>
    </g>
  );
}

function SvgMCCB({ x, y, w, h }) {
  w = w || 20; h = h || 14;
  return (
    <g>
      <rect x={x - w / 2} y={y - h / 2} width={w} height={h} fill="#fff" stroke="#333" strokeWidth={1.2} />
      <line x1={x - w / 4} y1={y - h / 2} x2={x + w / 4} y2={y + h / 2} stroke="#333" strokeWidth={1.2} />
    </g>
  );
}

function SvgMotor({ x, y, r }) {
  r = r || 12;
  return (
    <g>
      <circle cx={x} cy={y} r={r} fill="#e3f2fd" stroke="#1565c0" strokeWidth={1.5} />
      <text x={x} y={y + 4} fontSize={10} textAnchor="middle" fontWeight={700} fill="#1565c0">M</text>
    </g>
  );
}

function SvgLoad({ x, y, r }) {
  r = r || 12;
  return (
    <g>
      <polygon points={`${x},${y - r} ${x + r},${y + r * 0.6} ${x - r},${y + r * 0.6}`}
        fill="#fff3e0" stroke="#e65100" strokeWidth={1.5} />
    </g>
  );
}

function SvgBusBar({ x, y, width }) {
  return <rect x={x} y={y - 2} width={width} height={4} fill="#333" rx={1} />;
}

function SvgPort({ x, y, active, onMouseDown, type }) {
  return (
    <circle cx={x} cy={y} r={MOD.PORT_R}
      fill={active ? '#1976d2' : '#fff'} stroke={active ? '#1976d2' : '#999'} strokeWidth={1.5}
      style={{ cursor: 'crosshair' }}
      onMouseDown={onMouseDown}
      data-port-type={type}
    />
  );
}

function SvgVCB({ x, y }) {
  const r = 8;
  return (
    <g>
      <circle cx={x} cy={y} r={r} fill="#fff" stroke="#333" strokeWidth={1.5} />
      <line x1={x - 4} y1={y - 4} x2={x + 4} y2={y + 4} stroke="#333" strokeWidth={1.2} />
      <line x1={x + 4} y1={y - 4} x2={x - 4} y2={y + 4} stroke="#333" strokeWidth={1.2} />
    </g>
  );
}

/* === DIAGRAM: AUTO LAYOUT (M2-4-8) === */

function autoLayout(nodes, direction) {
  const dir = DIRECTIONS[direction || 'horizontal'];
  const tree = buildTree(nodes);
  if (tree.length === 0) return {};
  const positions = {};

  /* サブツリーの交差軸方向のサイズを再帰的に計測 */
  function measureCross(node) {
    if (!node.children || node.children.length === 0) {
      const s = nodeSize(node.type);
      return dir.crossAxis === 'y' ? s.h : s.w;
    }
    let total = 0;
    for (let i = 0; i < node.children.length; i++) {
      if (i > 0) total += MOD.GAP_CROSS;
      total += measureCross(node.children[i]);
    }
    const s = nodeSize(node.type);
    const minSelf = dir.crossAxis === 'y' ? s.h : s.w;
    return Math.max(total, minSelf);
  }

  function nodeSize(type) {
    switch (type) {
      case 'transformer': return { w: MOD.TR_W, h: MOD.TR_H };
      case 'trunk': return { w: MOD.TRUNK_W, h: MOD.TRUNK_H };
      case 'load': return { w: MOD.LOAD_W, h: MOD.LOAD_H };
      default: return { w: 100, h: 50 };
    }
  }

  /* 再帰的に座標を割り当て */
  function assign(node, mainPos, crossStart) {
    const s = nodeSize(node.type);
    const subtreeCross = measureCross(node);
    const selfCross = dir.crossAxis === 'y' ? s.h : s.w;
    const selfMain = dir.mainAxis === 'x' ? s.w : s.h;
    const cx = crossStart + (subtreeCross - selfCross) / 2;

    if (dir.mainAxis === 'x') {
      positions[node.id] = { x: mainPos, y: cx, width: s.w, height: s.h };
    } else {
      positions[node.id] = { x: cx, y: mainPos, width: s.w, height: s.h };
    }

    if (node.children && node.children.length > 0) {
      let childCross = crossStart;
      const childMain = mainPos + selfMain + MOD.GAP_MAIN;
      for (let i = 0; i < node.children.length; i++) {
        if (i > 0) childCross += MOD.GAP_CROSS;
        assign(node.children[i], childMain, childCross);
        childCross += measureCross(node.children[i]);
      }
    }
  }

  /* 各ルートを配置 */
  let crossOffset = MOD.MARGIN;
  for (let i = 0; i < tree.length; i++) {
    if (i > 0) crossOffset += MOD.GAP_CROSS * 2;
    assign(tree[i], MOD.MARGIN, crossOffset);
    crossOffset += measureCross(tree[i]);
  }

  return positions;
}

/* canvas 座標が未設定のノードに自動配置を適用 */
function ensureCanvasPositions(nodes, direction) {
  const needsLayout = nodes.some(n => !n.canvas || n.canvas.x == null);
  if (!needsLayout) return nodes;
  const positions = autoLayout(nodes, direction);
  return nodes.map(n => {
    if (n.canvas && n.canvas.x != null) return n;
    const pos = positions[n.id];
    return pos ? { ...n, canvas: pos } : { ...n, canvas: { x: 0, y: 0, width: 100, height: 50 } };
  });
}

/* === DIAGRAM: CONNECTION LINE (M2-4-4) === */

function ConnectionLine({ fromCanvas, toCanvas, direction, ok, selected }) {
  const dir = DIRECTIONS[direction || 'horizontal'];
  let fx, fy, tx, ty;
  if (dir.outPort === 'right') {
    fx = fromCanvas.x + fromCanvas.width;
    fy = fromCanvas.y + fromCanvas.height / 2;
    tx = toCanvas.x;
    ty = toCanvas.y + toCanvas.height / 2;
  } else {
    fx = fromCanvas.x + fromCanvas.width / 2;
    fy = fromCanvas.y + fromCanvas.height;
    tx = toCanvas.x + toCanvas.width / 2;
    ty = toCanvas.y;
  }
  const mx = (fx + tx) / 2;
  const my = (fy + ty) / 2;
  const d = dir.outPort === 'right'
    ? `M${fx},${fy} C${mx},${fy} ${mx},${ty} ${tx},${ty}`
    : `M${fx},${fy} C${fx},${my} ${tx},${my} ${tx},${ty}`;
  return (
    <path d={d}
      fill="none"
      stroke={selected ? '#1976d2' : ok === false ? '#c00' : '#666'}
      strokeWidth={selected ? 2.5 : 1.5}
      strokeDasharray={ok === false ? '4 2' : 'none'}
    />
  );
}

/* === DIAGRAM: MODULE COMPONENTS (M2-4-2) === */

function ModuleTransformer({ node, result, canvas, selected, mode, direction, onMouseDown, onClick, onPortMouseDown }) {
  const { x, y, width: w, height: h } = canvas;
  const dir = DIRECTIONS[direction || 'horizontal'];
  const tr = node.transformer || {};
  const inX = dir.inPort === 'left' ? x : x + w / 2;
  const inY = dir.inPort === 'left' ? y + h / 2 : y;
  const outX = dir.outPort === 'right' ? x + w : x + w / 2;
  const outY = dir.outPort === 'right' ? y + h / 2 : y + h;
  return (
    <g style={{ cursor: mode === 'edit' ? 'grab' : 'pointer' }}
       onMouseDown={mode === 'edit' ? onMouseDown : undefined}
       onClick={onClick}>
      <SvgTransformer x={x} y={y} w={w} h={h} connection={tr.connection} />
      {selected && <rect x={x - 2} y={y - 2} width={w + 4} height={h + 4} rx={6} fill="none" stroke="#1976d2" strokeWidth={2} strokeDasharray="4 2" />}
      <text x={x + w / 2} y={y - 6} fontSize={10} textAnchor="middle" fontWeight={700} fill="#333">{tr.name || 'TR'}</text>
      <text x={x + w / 2} y={y + h + 12} fontSize={8} textAnchor="middle" fill="#666">
        {tr.capacity_kVA || ''}kVA {tr.primaryV || ''}/{tr.secondaryV || ''}V
      </text>
      {result && <text x={x + w / 2} y={y + h + 22} fontSize={8} textAnchor="middle" fill="#666">
        Isc₃={rd(result.Isc3 / 1000, 1)}kA  %Z={tr.pctZ}
      </text>}
      {mode === 'edit' && (
        <>
          <SvgPort x={inX} y={inY} type="in" onMouseDown={e => { e.stopPropagation(); onPortMouseDown && onPortMouseDown(node.id, 'in', e); }} />
          <SvgPort x={outX} y={outY} type="out" onMouseDown={e => { e.stopPropagation(); onPortMouseDown && onPortMouseDown(node.id, 'out', e); }} />
        </>
      )}
    </g>
  );
}

function ModuleTrunk({ node, result, canvas, selected, mode, direction, onMouseDown, onClick, onPortMouseDown }) {
  const { x, y, width: w, height: h } = canvas;
  const dir = DIRECTIONS[direction || 'horizontal'];
  const tr = node.trunk || {};
  const ok = result ? result.ok : null;
  const borderColor = ok === false ? '#c00' : ok ? '#4caf50' : '#999';
  const bgColor = ok === false ? '#fff5f5' : '#fff';
  const outX = dir.outPort === 'right' ? x + w : x + w / 2;
  const outY = dir.outPort === 'right' ? y + h / 2 : y + h;
  const inX = dir.inPort === 'left' ? x : x + w / 2;
  const inY = dir.inPort === 'left' ? y + h / 2 : y;
  const sizeStr = result ? `${result.size}${result.parallel > 1 ? '×' + result.parallel : ''}` : '';
  return (
    <g style={{ cursor: mode === 'edit' ? 'grab' : 'pointer' }}
       onMouseDown={mode === 'edit' ? onMouseDown : undefined}
       onClick={onClick}>
      <rect x={x} y={y} width={w} height={h} rx={4} fill={bgColor} stroke={borderColor} strokeWidth={1.5} />
      {selected && <rect x={x - 2} y={y - 2} width={w + 4} height={h + 4} rx={6} fill="none" stroke="#1976d2" strokeWidth={2} strokeDasharray="4 2" />}
      {/* MCCB シンボル (左端内部) */}
      <SvgMCCB x={x + 18} y={y + h / 2} />
      {result && <text x={x + 36} y={y + h / 2 - 6} fontSize={8} fill="#333">{result.mccbAT}AT</text>}
      {/* ケーブル表記 */}
      <text x={x + 36} y={y + h / 2 + 5} fontSize={8} fill="#555">{tr.cableType} {sizeStr}</text>
      <text x={x + 36} y={y + h / 2 + 15} fontSize={7} fill="#888">{tr.cableLength}m</text>
      {/* 名称 */}
      <text x={x + w / 2} y={y - 5} fontSize={10} textAnchor="middle" fontWeight={600} fill="#333">{tr.name || '幹線'}</text>
      {/* 電流・電圧降下 */}
      {result && (
        <text x={x + w - 6} y={y + h / 2 + 3} fontSize={8} textAnchor="end" fill="#666">
          {rd(result.dI, 1)}A  e={result.vdPercent}%
        </text>
      )}
      {/* 判定バッジ */}
      {ok != null && (
        <g>
          <rect x={x + w - 22} y={y + 3} width={18} height={12} rx={2} fill={ok ? '#e8f5e9' : '#ffebee'} stroke={ok ? '#4caf50' : '#c00'} strokeWidth={0.8} />
          <text x={x + w - 13} y={y + 12} fontSize={7} textAnchor="middle" fontWeight={700} fill={ok ? '#2e7d32' : '#c00'}>{ok ? 'OK' : 'NG'}</text>
        </g>
      )}
      {mode === 'edit' && (
        <>
          <SvgPort x={inX} y={inY} type="in" onMouseDown={e => { e.stopPropagation(); onPortMouseDown && onPortMouseDown(node.id, 'in', e); }} />
          <SvgPort x={outX} y={outY} type="out" onMouseDown={e => { e.stopPropagation(); onPortMouseDown && onPortMouseDown(node.id, 'out', e); }} />
        </>
      )}
    </g>
  );
}

function ModuleLoadNode({ node, result, canvas, selected, mode, direction, onMouseDown, onClick, onPortMouseDown }) {
  const { x, y, width: w, height: h } = canvas;
  const dir = DIRECTIONS[direction || 'horizontal'];
  const p = node.load || {};
  const ok = result ? result.ok : null;
  const borderColor = ok === false ? '#c00' : ok ? '#4caf50' : '#999';
  const bgColor = ok === false ? '#fff5f5' : '#fff';
  const inX = dir.inPort === 'left' ? x : x + w / 2;
  const inY = dir.inPort === 'left' ? y + h / 2 : y;
  const sizeStr = result ? `${result.size}${result.parallel > 1 ? '×' + result.parallel : ''}` : '';
  const isMotor = p.circuitType === '電動機';
  return (
    <g style={{ cursor: mode === 'edit' ? 'grab' : 'pointer' }}
       onMouseDown={mode === 'edit' ? onMouseDown : undefined}
       onClick={onClick}>
      <rect x={x} y={y} width={w} height={h} rx={4} fill={bgColor} stroke={borderColor} strokeWidth={1.5} />
      {selected && <rect x={x - 2} y={y - 2} width={w + 4} height={h + 4} rx={6} fill="none" stroke="#1976d2" strokeWidth={2} strokeDasharray="4 2" />}
      {/* MCCB シンボル */}
      <SvgMCCB x={x + 18} y={y + h / 2} />
      {result && <text x={x + 36} y={y + h / 2 - 4} fontSize={8} fill="#333">{result.mccbAT}AT</text>}
      <text x={x + 36} y={y + h / 2 + 7} fontSize={7} fill="#888">{p.cableType} {sizeStr} {p.cableLength}m</text>
      {/* 負荷シンボル (右端) */}
      {isMotor
        ? <SvgMotor x={x + w - 18} y={y + h / 2} r={10} />
        : <SvgLoad x={x + w - 18} y={y + h / 2} r={10} />
      }
      {/* 名称 */}
      <text x={x + w / 2} y={y - 5} fontSize={9} textAnchor="middle" fontWeight={600} fill="#333">{p.loadName || p.trunkName || '負荷'}</text>
      {/* 電流 */}
      {result && (
        <text x={x + w / 2} y={y + h + 11} fontSize={7} textAnchor="middle" fill="#666">
          {rd(result.dI, 1)}A  e={result.vdPercent}%
        </text>
      )}
      {/* 判定バッジ */}
      {ok != null && (
        <g>
          <rect x={x + w - 22} y={y + 3} width={18} height={12} rx={2} fill={ok ? '#e8f5e9' : '#ffebee'} stroke={ok ? '#4caf50' : '#c00'} strokeWidth={0.8} />
          <text x={x + w - 13} y={y + 12} fontSize={7} textAnchor="middle" fontWeight={700} fill={ok ? '#2e7d32' : '#c00'}>{ok ? 'OK' : 'NG'}</text>
        </g>
      )}
      {mode === 'edit' && (
        <SvgPort x={inX} y={inY} type="in" onMouseDown={e => { e.stopPropagation(); onPortMouseDown && onPortMouseDown(node.id, 'in', e); }} />
      )}
    </g>
  );
}

/* === DIAGRAM: CANVAS COMPONENT (M2-4-1, M2-4-5, M2-4-6) === */

function DiagramCanvas({ nodes, allResults, systemMeta, selectedId, onSelectNode, mode, onNodesChange }) {
  const direction = (systemMeta && systemMeta.diagramDirection) || 'horizontal';
  const svgRef = React.useRef(null);
  const [vt, setVt] = React.useState({ x: 0, y: 0, scale: 1 });
  const [dragging, setDragging] = React.useState(null);     /* { nodeId, offX, offY } */
  const [panning, setPanning] = React.useState(null);         /* { startX, startY, vtX, vtY } */
  const [wiring, setWiring] = React.useState(null);           /* { fromId, fromPort, mx, my } */

  /* ズーム */
  const handleWheel = React.useCallback((e) => {
    e.preventDefault();
    const factor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
    setVt(prev => {
      const rect = svgRef.current.getBoundingClientRect();
      const cx = e.clientX - rect.left;
      const cy = e.clientY - rect.top;
      const newScale = Math.min(Math.max(prev.scale * factor, 0.1), 5);
      return {
        scale: newScale,
        x: cx - (cx - prev.x) * (newScale / prev.scale),
        y: cy - (cy - prev.y) * (newScale / prev.scale)
      };
    });
  }, []);

  /* パン開始（背景クリック） */
  const handleBgMouseDown = (e) => {
    if (e.button !== 0) return;
    if (e.target === svgRef.current || e.target.tagName === 'svg') {
      setPanning({ startX: e.clientX, startY: e.clientY, vtX: vt.x, vtY: vt.y });
    }
  };

  /* パン / ドラッグ / ワイヤリング のマウス移動 */
  React.useEffect(() => {
    const handleMove = (e) => {
      if (panning) {
        setVt({ ...vt, x: panning.vtX + (e.clientX - panning.startX), y: panning.vtY + (e.clientY - panning.startY), scale: vt.scale });
      }
      if (dragging && mode === 'edit') {
        const rect = svgRef.current.getBoundingClientRect();
        const sx = (e.clientX - rect.left - vt.x) / vt.scale;
        const sy = (e.clientY - rect.top - vt.y) / vt.scale;
        const newX = sx - dragging.offX;
        const newY = sy - dragging.offY;
        onNodesChange && onNodesChange(prev =>
          prev.map(n => n.id === dragging.nodeId
            ? { ...n, canvas: { ...n.canvas, x: newX, y: newY } }
            : n
          )
        );
      }
      if (wiring) {
        const rect = svgRef.current.getBoundingClientRect();
        setWiring(prev => ({
          ...prev,
          mx: (e.clientX - rect.left - vt.x) / vt.scale,
          my: (e.clientY - rect.top - vt.y) / vt.scale
        }));
      }
    };
    const handleUp = (e) => {
      if (wiring && mode === 'edit') {
        /* 接続先ポートの検出 */
        const rect = svgRef.current.getBoundingClientRect();
        const sx = (e.clientX - rect.left - vt.x) / vt.scale;
        const sy = (e.clientY - rect.top - vt.y) / vt.scale;
        const target = nodes.find(n => {
          if (n.id === wiring.fromId) return false;
          const c = n.canvas;
          if (!c) return false;
          const dir = DIRECTIONS[direction];
          let px, py;
          if (dir.inPort === 'left') { px = c.x; py = c.y + c.height / 2; }
          else { px = c.x + c.width / 2; py = c.y; }
          return Math.abs(sx - px) < 15 && Math.abs(sy - py) < 15;
        });
        if (target && wiring.fromPort === 'out') {
          /* 接続: target の parentId を fromId に設定 */
          const testNodes = nodes.map(n => n.id === target.id ? { ...n, parentId: wiring.fromId } : n);
          const err = validateNode(testNodes, { ...target, parentId: wiring.fromId });
          if (!err) {
            onNodesChange && onNodesChange(prev =>
              prev.map(n => n.id === target.id ? { ...n, parentId: wiring.fromId } : n)
            );
          }
        }
        setWiring(null);
      }
      setPanning(null);
      setDragging(null);
    };
    window.addEventListener('mousemove', handleMove);
    window.addEventListener('mouseup', handleUp);
    return () => { window.removeEventListener('mousemove', handleMove); window.removeEventListener('mouseup', handleUp); };
  }, [panning, dragging, wiring, vt, nodes, mode, direction]);

  /* ノードドラッグ開始 */
  const handleNodeMouseDown = (nodeId, e) => {
    if (mode !== 'edit') return;
    e.stopPropagation();
    const node = nodes.find(n => n.id === nodeId);
    if (!node || !node.canvas) return;
    const rect = svgRef.current.getBoundingClientRect();
    const sx = (e.clientX - rect.left - vt.x) / vt.scale;
    const sy = (e.clientY - rect.top - vt.y) / vt.scale;
    setDragging({ nodeId, offX: sx - node.canvas.x, offY: sy - node.canvas.y });
  };

  /* ポートドラッグ開始（ワイヤリング） */
  const handlePortMouseDown = (nodeId, portType, e) => {
    if (mode !== 'edit') return;
    const node = nodes.find(n => n.id === nodeId);
    if (!node || !node.canvas) return;
    const rect = svgRef.current.getBoundingClientRect();
    setWiring({
      fromId: nodeId, fromPort: portType,
      mx: (e.clientX - rect.left - vt.x) / vt.scale,
      my: (e.clientY - rect.top - vt.y) / vt.scale
    });
  };

  /* ノードクリック */
  const handleNodeClick = (node) => {
    onSelectNode && onSelectNode(node);
  };

  /* Fit to view */
  const fitView = () => {
    if (!svgRef.current || nodes.length === 0) return;
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const n of nodes) {
      if (!n.canvas) continue;
      minX = Math.min(minX, n.canvas.x);
      minY = Math.min(minY, n.canvas.y);
      maxX = Math.max(maxX, n.canvas.x + n.canvas.width);
      maxY = Math.max(maxY, n.canvas.y + n.canvas.height);
    }
    if (minX === Infinity) return;
    const rect = svgRef.current.getBoundingClientRect();
    const pad = 40;
    const cw = maxX - minX + pad * 2;
    const ch = maxY - minY + pad * 2;
    const scale = Math.min(rect.width / cw, rect.height / ch, 2);
    setVt({
      scale,
      x: (rect.width - cw * scale) / 2 - (minX - pad) * scale,
      y: (rect.height - ch * scale) / 2 - (minY - pad) * scale
    });
  };

  /* 接続線の描画 */
  const renderConnections = () => {
    const lines = [];
    for (const node of nodes) {
      if (!node.parentId || !node.canvas) continue;
      const parent = nodes.find(n => n.id === node.parentId);
      if (!parent || !parent.canvas) continue;
      const r = allResults[node.id];
      lines.push(
        <ConnectionLine key={`conn-${node.id}`}
          fromCanvas={parent.canvas} toCanvas={node.canvas}
          direction={direction} ok={r ? r.ok : null}
          selected={selectedId === node.id || selectedId === parent.id}
        />
      );
    }
    return lines;
  };

  /* モジュール描画 */
  const renderModules = () => {
    return nodes.filter(n => n.canvas).map(node => {
      const r = allResults[node.id];
      const sel = selectedId === node.id;
      const common = {
        node, result: r, canvas: node.canvas, selected: sel, mode, direction,
        onMouseDown: (e) => handleNodeMouseDown(node.id, e),
        onClick: () => handleNodeClick(node),
        onPortMouseDown: handlePortMouseDown
      };
      switch (node.type) {
        case 'transformer': return <ModuleTransformer key={node.id} {...common} />;
        case 'trunk': return <ModuleTrunk key={node.id} {...common} />;
        case 'load': return <ModuleLoadNode key={node.id} {...common} />;
        default: return null;
      }
    });
  };

  /* ワイヤリング中の仮線 */
  const renderWiringLine = () => {
    if (!wiring) return null;
    const from = nodes.find(n => n.id === wiring.fromId);
    if (!from || !from.canvas) return null;
    const dir = DIRECTIONS[direction];
    let fx, fy;
    if (wiring.fromPort === 'out') {
      fx = dir.outPort === 'right' ? from.canvas.x + from.canvas.width : from.canvas.x + from.canvas.width / 2;
      fy = dir.outPort === 'right' ? from.canvas.y + from.canvas.height / 2 : from.canvas.y + from.canvas.height;
    } else {
      fx = dir.inPort === 'left' ? from.canvas.x : from.canvas.x + from.canvas.width / 2;
      fy = dir.inPort === 'left' ? from.canvas.y + from.canvas.height / 2 : from.canvas.y;
    }
    return <line x1={fx} y1={fy} x2={wiring.mx} y2={wiring.my} stroke="#1976d2" strokeWidth={2} strokeDasharray="4 2" />;
  };

  return (
    <div style={{ width: '100%', height: '100%', position: 'relative', background: '#f8f9fa', overflow: 'hidden' }}>
      <svg ref={svgRef} width="100%" height="100%"
        style={{ cursor: panning ? 'grabbing' : 'grab' }}
        onWheel={handleWheel}
        onMouseDown={handleBgMouseDown}
      >
        {/* グリッド（編集モード） */}
        {mode === 'edit' && (
          <defs>
            <pattern id="grid" width={20 * vt.scale} height={20 * vt.scale} patternUnits="userSpaceOnUse"
              x={vt.x % (20 * vt.scale)} y={vt.y % (20 * vt.scale)}>
              <path d={`M ${20 * vt.scale} 0 L 0 0 0 ${20 * vt.scale}`} fill="none" stroke="#e0e0e0" strokeWidth={0.5} />
            </pattern>
            <rect width="100%" height="100%" fill="url(#grid)" />
          </defs>
        )}
        <g transform={`translate(${vt.x},${vt.y}) scale(${vt.scale})`}>
          {renderConnections()}
          {renderModules()}
          {renderWiringLine()}
        </g>
      </svg>
      {/* ズーム/フィット コントロール */}
      <div style={{ position: 'absolute', bottom: 8, right: 8, display: 'flex', gap: 4 }}>
        <button onClick={() => setVt(v => ({ ...v, scale: v.scale * 1.2 }))}
          style={{ padding: '4px 8px', borderRadius: 4, border: '1px solid #ccc', background: '#fff', cursor: 'pointer', fontSize: 14 }}>+</button>
        <button onClick={() => setVt(v => ({ ...v, scale: v.scale / 1.2 }))}
          style={{ padding: '4px 8px', borderRadius: 4, border: '1px solid #ccc', background: '#fff', cursor: 'pointer', fontSize: 14 }}>−</button>
        <button onClick={fitView}
          style={{ padding: '4px 8px', borderRadius: 4, border: '1px solid #ccc', background: '#fff', cursor: 'pointer', fontSize: 11 }}>Fit</button>
      </div>
      {/* モード表示 */}
      <div style={{ position: 'absolute', top: 8, left: 8, fontSize: 11, color: '#666', background: 'rgba(255,255,255,0.8)', padding: '2px 8px', borderRadius: 4 }}>
        {mode === 'edit' ? '編集モード' : 'ビューモード'}
      </div>
    </div>
  );
}

/* === COMPONENTS === */

/* --- 電気方式 → 電圧選択肢 (§5) --- */
const VOLTAGE_OPTIONS = {
  '単相2線式': [100, 200],
  '単相3線式': [200],
  '三相3線式': [200, 210, 400, 415, 440],
  '三相4線式': [200]
};

/* --- ケーブル種類と電気方式の対応 (§3-3) --- */
function getCableTypeOptions(sys) {
  if (sys === '単相2線式') return ['CV-2C'];
  if (sys === '単相3線式') return ['CV-3C'];
  return ['CVT', 'CVD', 'CV-3C'];
}

/* --- スライダー感度テーブル (§7) --- */
const SLIDER_CFG = {
  capacity_kW:  { step: 0.1, range: 100 },
  capacity_kVA: { step: 0.1, range: 100 },
  capacity_A:   { step: 1,   range: 200 },
  powerFactor:  { step: 0.01, range: 0.30 },
  efficiency:   { step: 0.01, range: 0.30 },
  demandFactor: { step: 1,   range: 50 },
  cableLength:  { step: 0.5, range: 100 },
  ambientTemp:  { step: 5,   range: 15 },
  reductionFactor: { step: 0.01, range: 0.30 }
};

/* --- デフォルト入力値 (§3) --- */
const DEFAULT_PARAMS = {
  trunkName: '', loadName: '',
  system: '三相3線式', voltage: 200, freq: '60Hz', supplyType: '低圧受電',
  circuitType: '一般', mccbATOverride: '自動',
  capacity: 15, unit: 'kW', powerFactor: 0.85, efficiency: 1.0,
  demandFactor: 100, cableLength: 30,
  cableType: 'CVT', wiringMethod: 'ケーブルラック配線',
  ambientTemp: 40, reductionPreset: '1段 S=d 7列以上', reductionFactor: 0.70
};

/* --- 変圧器デフォルト (§19) --- */
const DEFAULT_TR_PARAMS = {
  name: 'TR-1', trType: '三相油入', capacity_kVA: 500,
  primaryV: 6600, secondaryV: 210,
  pctZ: 4.00, xrRatio: 2.98, connection: 'Δ-Y', pctZAuto: true,
  hvSystem: { /* P4-7: reserved for M2-3 (§19-5) */
    cableType: null,            /* 'CV-3C' | 'CVT' | null */
    cableSize_mm2: null,        /* number | null */
    totalCableLength_km: null,  /* number | null */
    capacitance_uF_per_km: null /* number | null */
  }
};

/* --- 幹線デフォルト (§9) --- */
const DEFAULT_TRUNK_PARAMS = {
  name: '', system: '三相3線式', voltage: 210, freq: '60Hz', supplyType: '高圧受電',
  cableLength: 10, cableType: 'CVT', wiringMethod: 'ケーブルラック配線',
  ambientTemp: 40, reductionPreset: '1段 S=d 7列以上', reductionFactor: 0.70,
  powerFactor: 0.85, mccbATOverride: '自動'
};

/* --- Badge コンポーネント (§11-1) --- */
function Badge({ ok, label }) {
  return (
    <span style={{
      display: 'inline-flex', alignItems: 'center', gap: 4,
      padding: '2px 8px', borderRadius: 4, fontSize: 12, fontWeight: 700,
      color: '#fff', background: ok ? '#4caf50' : '#f44336'
    }}>
      {ok ? '○' : '×'} {label}
    </span>
  );
}

/* --- Sec セクションラッパー --- */
function Sec({ title, children }) {
  return (
    <fieldset style={{
      border: '1px solid #ddd', borderRadius: 6, padding: '8px 12px',
      marginBottom: 12
    }}>
      <legend style={{ fontSize: 13, fontWeight: 700, color: '#1976d2', padding: '0 4px' }}>{title}</legend>
      {children}
    </fieldset>
  );
}

/* --- RC フォーム行コンポーネント --- */
function RC({ label, children, show = true }) {
  if (!show) return null;
  return (
    <div style={{
      display: 'flex', alignItems: 'center', marginBottom: 6, minHeight: 30
    }}>
      <label style={{ width: 130, fontSize: 13, flexShrink: 0, color: '#555' }}>{label}</label>
      <div style={{ flex: 1 }}>{children}</div>
    </div>
  );
}

/* --- セレクトボックス共通スタイル --- */
const selStyle = {
  width: '100%', padding: '4px 6px', fontSize: 13, border: '1px solid #ccc',
  borderRadius: 4, background: '#fff', outline: 'none'
};

/* --- 数値入力共通スタイル --- */
const numStyle = {
  width: '100%', padding: '4px 6px', fontSize: 13, border: '1px solid #ccc',
  borderRadius: 4, textAlign: 'right', outline: 'none'
};

/* --- SliderInput コンポーネント (§7) --- */
function SliderInput({ value, displayValue, onChange, onConfirm, cfg, min, max, style: extraStyle }) {
  const [open, setOpen] = React.useState(false);
  const [dragging, setDragging] = React.useState(false);
  const baseRef = React.useRef(value);
  const wrapRef = React.useRef(null);

  /* ポップアップ外クリックで閉じる */
  React.useEffect(() => {
    if (!open) return;
    const handler = (e) => {
      if (wrapRef.current && !wrapRef.current.contains(e.target)) { setOpen(false); }
    };
    document.addEventListener('mousedown', handler);
    return () => document.removeEventListener('mousedown', handler);
  }, [open]);

  const clamp = (v) => {
    let c = v;
    if (min !== undefined) c = Math.max(min, c);
    if (max !== undefined) c = Math.min(max, c);
    /* ステップで丸める */
    c = Math.round(c / cfg.step) * cfg.step;
    /* 浮動小数点の丸め */
    const dp = String(cfg.step).includes('.') ? String(cfg.step).split('.')[1].length : 0;
    return Number(c.toFixed(dp));
  };

  const handleSliderChange = (e) => {
    /* range: 0~200 → center=100 → offset = (v-100)/100 * range */
    const pct = (Number(e.target.value) - 100) / 100;
    const newVal = clamp(baseRef.current + pct * cfg.range);
    onChange(newVal);
  };

  const handleSliderCommit = () => {
    setDragging(false);
    onConfirm();
    baseRef.current = value;
  };

  return (
    <div ref={wrapRef} style={{ position: 'relative' }}>
      <input
        type="text"
        value={displayValue !== undefined ? displayValue : value}
        style={{ ...numStyle, ...extraStyle }}
        onChange={(e) => {
          const v = e.target.value;
          onChange(v === '' ? '' : v);
        }}
        onFocus={() => { setOpen(true); baseRef.current = value; }}
        onBlur={(e) => {
          /* スライダー操作中はblurで確定しない */
          if (dragging) return;
          if (wrapRef.current && wrapRef.current.contains(e.relatedTarget)) return;
          const n = parseFloat(displayValue !== undefined ? displayValue : value);
          if (!isNaN(n)) { onChange(clamp(n)); }
          onConfirm();
        }}
        onKeyDown={(e) => { if (e.key === 'Enter') { e.target.blur(); } }}
      />
      {open && (
        <div style={{
          position: 'absolute', top: '100%', left: 0, right: 0, zIndex: 10,
          background: '#fff', border: '1px solid #ccc', borderRadius: 4,
          padding: '6px 8px', boxShadow: '0 2px 8px rgba(0,0,0,0.15)', marginTop: 2
        }}>
          <input
            type="range" min={0} max={200} value={100}
            style={{ width: '100%', cursor: 'pointer' }}
            onMouseDown={() => { setDragging(true); baseRef.current = typeof value === 'number' ? value : parseFloat(value) || 0; }}
            onInput={handleSliderChange}
            onMouseUp={handleSliderCommit}
            onTouchStart={() => { setDragging(true); baseRef.current = typeof value === 'number' ? value : parseFloat(value) || 0; }}
            onTouchEnd={handleSliderCommit}
          />
          <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: 10, color: '#999' }}>
            <span>{clamp((typeof value === 'number' ? value : parseFloat(value) || 0) - cfg.range)}</span>
            <span>{clamp((typeof value === 'number' ? value : parseFloat(value) || 0) + cfg.range)}</span>
          </div>
        </div>
      )}
    </div>
  );
}

/* --- ResultPanel 選定結果パネル (§11) --- */
function ResultPanel({ result, params }) {
  if (!result) return <div style={{ color: '#999', padding: 16 }}>入力を完了すると結果が表示されます</div>;
  const r = result;
  const isTrunk = r.hasMotor !== undefined;
  const isMotor = isTrunk ? r.hasMotor : params.circuitType === '電動機';

  const panelStyle = {
    background: '#fff', border: '1px solid #e0e0e0', borderRadius: 8,
    padding: 16, marginBottom: 16, borderLeft: `4px solid ${r.ok ? '#4caf50' : '#f44336'}`
  };
  const rowStyle = { display: 'flex', gap: 12, padding: '8px 0', borderBottom: '1px solid #f0f0f0' };
  const cellStyle = { flex: 1, minWidth: 0 };
  const sectionTitle = { fontSize: 13, fontWeight: 700, color: '#1976d2', marginBottom: 4 };
  const dtStyle = { fontSize: 11, color: '#888', marginBottom: 1 };
  const ddStyle = { fontSize: 16, fontWeight: 700 };
  const detailRow = { display: 'flex', justifyContent: 'space-between', fontSize: 12, padding: '2px 0', color: '#555' };

  return (
    <div style={panelStyle}>
      {/* 1段目: [総合判定] [選定ケーブル, MCCB定格, 設計電流] */}
      <div style={rowStyle}>
        <div style={{ display: 'flex', flexDirection: 'column', justifyContent: 'center', minWidth: 60 }}>
          <span style={{
            fontSize: 20, fontWeight: 700, textAlign: 'center',
            color: r.ok ? '#4caf50' : '#f44336'
          }}>{r.ok ? 'OK' : 'NG'}</span>
          <span style={{ fontSize: 10, color: '#888', textAlign: 'center' }}>総合判定</span>
        </div>
        <div style={{ display: 'flex', gap: 16, flex: 1 }}>
          <div style={cellStyle}>
            <div style={dtStyle}>選定ケーブル</div>
            <div style={ddStyle}>{params.cableType} {r.size}{r.parallel > 1 ? `×${r.parallel}` : ''} mm²</div>
          </div>
          <div style={cellStyle}>
            <div style={dtStyle}>MCCB 定格</div>
            <div style={ddStyle}>{r.mccbAT} AT</div>
          </div>
          <div style={cellStyle}>
            <div style={dtStyle}>設計電流</div>
            <div style={ddStyle}>{r.dI} A</div>
          </div>
        </div>
      </div>
      {isTrunk && r.hasMotor && (
        <div style={{ fontSize: 11, color: '#666', background: '#f5f5f5', borderRadius: 4, padding: '3px 8px', marginBottom: 4 }}>
          電動機 {r.sumIM}A × {r.sumIM <= 50 ? '1.25' : '1.1'} + 一般 {r.sumIH}A = {r.sizingI}A
        </div>
      )}
      {!isTrunk && isMotor && (
        <div style={{ fontSize: 11, color: '#666', background: '#f5f5f5', borderRadius: 4, padding: '3px 8px', marginBottom: 4 }}>
          サイジング電流: {r.sizingI} A（{r.dI <= 50 ? '×1.25' : '×1.1'} 補正）
        </div>
      )}

      {/* 2段目: [許容電流] [電圧降下] */}
      <div style={rowStyle}>
        <div style={cellStyle}>
          <div style={{ display: 'flex', alignItems: 'center', gap: 6, marginBottom: 4 }}>
            <Badge ok={r.ampacityOK} label="許容電流" />
          </div>
          <div style={detailRow}><span>基本許容電流</span><span>{r.baseAmpacity} A</span></div>
          <div style={detailRow}><span>温度補正</span><span>{r.tempFactor}</span></div>
          <div style={detailRow}><span>低減率</span><span>{r.reductionFactor}</span></div>
          <div style={{ ...detailRow, fontWeight: 700 }}>
            <span>実効許容電流</span>
            <span style={{ color: r.ampacityOK ? '#4caf50' : '#f44336' }}>{r.effectiveAmpacity} A</span>
          </div>
        </div>
        <div style={cellStyle}>
          <div style={{ display: 'flex', alignItems: 'center', gap: 6, marginBottom: 4 }}>
            <Badge ok={r.vdOK} label="電圧降下" />
          </div>
          <div style={detailRow}><span>Z</span><span>{r.Z} Ω/km</span></div>
          <div style={detailRow}><span>方式係数 K</span><span>{rd(r.K, 4)}</span></div>
          <div style={{ ...detailRow, fontWeight: 700, color: r.vdOK ? '#4caf50' : '#f44336' }}>
            <span>降下量</span><span>{r.vd} V ({r.vdPercent}%)</span>
          </div>
          <div style={detailRow}><span>許容値</span><span>{r.allowVd} V ({r.allowVdPercent}%)</span></div>
        </div>
      </div>

      {/* 3段目: [保護協調] [累積電圧降下] */}
      <div style={{ ...rowStyle, borderBottom: 'none' }}>
        <div style={cellStyle}>
          <div style={{ display: 'flex', alignItems: 'center', gap: 6, marginBottom: 4 }}>
            <Badge ok={r.protOK} label="保護協調" />
          </div>
          <div style={detailRow}><span>MCCB 定格</span><span>{r.mccbAT} AT</span></div>
          {isMotor && (
            <div style={detailRow}><span>閾値 (AT/2.5)</span><span>{rd(r.mccbAT / 2.5)} A</span></div>
          )}
          <div style={{ ...detailRow, fontWeight: 700 }}>
            <span>実効許容電流</span>
            <span style={{ color: r.protOK ? '#4caf50' : '#f44336' }}>
              {r.effectiveAmpacity} A {isMotor ? `≧ ${rd(r.mccbAT / 2.5)} A` : `≧ ${r.mccbAT} A`}
            </span>
          </div>
        </div>
        <div style={cellStyle}>
          {r.cumulativeVd != null && r.cumulativeVd > 0 ? (
            <React.Fragment>
              <div style={{ fontSize: 13, fontWeight: 700, color: '#1976d2', marginBottom: 4 }}>累積電圧降下</div>
              <div style={{ ...detailRow, fontWeight: 700 }}>
                <span>変圧器からの累積</span>
                <span>{r.cumulativeVd} V ({r.cumulativeVdP}%)</span>
              </div>
            </React.Fragment>
          ) : (
            <React.Fragment>
              <div style={{ fontSize: 13, fontWeight: 700, color: '#ccc', marginBottom: 4 }}>累積電圧降下</div>
              <div style={{ fontSize: 12, color: '#ccc' }}>—</div>
            </React.Fragment>
          )}
        </div>
      </div>

      {/* 短絡電流（変圧器接続時） */}
      {r.Isc3 != null && (
        <div style={{ borderTop: '1px solid #f0f0f0', paddingTop: 8, marginTop: 4 }}>
          <div style={sectionTitle}>短絡電流</div>
          <div style={{ display: 'flex', gap: 12 }}>
            <div style={cellStyle}>
              <div style={detailRow}><span>Isc₃</span><span>{rd(r.Isc3 / 1000, 1)} kA</span></div>
              <div style={detailRow}><span>累積 R</span><span>{rd(r.Rcum * 1000, 2)} mΩ</span></div>
              <div style={detailRow}><span>累積 X</span><span>{rd(r.Xcum * 1000, 2)} mΩ</span></div>
            </div>
            <div style={cellStyle}>
              {r.size && (() => {
                const wt = checkWithstand(r.size, r.Isc3, 0.1, r.parallel);
                return (
                  <React.Fragment>
                    <div style={detailRow}><span>耐電流 (K=134, t=0.1s)</span><span>{rd(wt.Iwithstand / 1000, 1)} kA</span></div>
                    <div style={{ ...detailRow, fontWeight: 700 }}>
                      <span>熱耐量</span>
                      <span><Badge ok={wt.ok} label={wt.ok ? 'OK' : 'NG'} /></span>
                    </div>
                  </React.Fragment>
                );
              })()}
            </div>
          </div>
        </div>
      )}
    </div>
  );
}

/* --- TransformerResultPanel 変圧器結果パネル (§19-3) --- */
function TransformerResultPanel({ result, nodes, nodeId, allResults }) {
  if (!result) return null;
  const r = result;
  const cardStyle = { background: '#fff', border: '1px solid #e0e0e0', borderRadius: 8, padding: 16, marginBottom: 16 };
  const dtStyle = { fontSize: 12, color: '#888', marginBottom: 2 };
  const ddStyle = { fontSize: 18, fontWeight: 700, marginBottom: 8 };
  const detailRow = { display: 'flex', justifyContent: 'space-between', fontSize: 13, padding: '3px 0', borderBottom: '1px solid #f0f0f0' };

  let utilization = 0;
  if (nodeId) {
    const allLoads = getDescendants(nodes, nodeId).filter(n => n.type === 'load');
    let totalKW = 0;
    for (const l of allLoads) {
      totalKW += (l.load.capacity || 0) * (l.load.demandFactor || 100) / 100;
    }
    utilization = r.capacity_kVA > 0 ? totalKW / r.capacity_kVA * 100 : 0;
  }

  return (
    <div>
      <div style={cardStyle}>
        <div style={{ display: 'flex', gap: 16 }}>
          <div style={{ flex: 1 }}>
            <div style={dtStyle}>定格二次電流</div>
            <div style={ddStyle}>{rd(r.In)} A</div>
          </div>
          <div style={{ flex: 1 }}>
            <div style={dtStyle}>短絡電流 Isc₃</div>
            <div style={ddStyle}>{rd(r.Isc3 / 1000, 1)} kA</div>
          </div>
          <div style={{ flex: 1 }}>
            <div style={dtStyle}>利用率</div>
            <div style={ddStyle}>{rd(utilization)}%</div>
          </div>
        </div>
      </div>
      <div style={cardStyle}>
        <div style={{ fontSize: 13, fontWeight: 700, marginBottom: 8, color: '#1976d2' }}>ソースインピーダンス</div>
        <div style={detailRow}><span>Rs</span><span>{rd(r.Rs * 1000, 2)} mΩ</span></div>
        <div style={detailRow}><span>Xs</span><span>{rd(r.Xs * 1000, 2)} mΩ</span></div>
        <div style={{ ...detailRow, borderBottom: 'none' }}><span>|Zs|</span><span>{rd(r.Zs * 1000, 2)} mΩ</span></div>
      </div>
    </div>
  );
}

/* --- TransformerForm 変圧器入力フォーム (§19-1) --- */
function TransformerForm({ trParams, setTrParams, onSave, onCancel, isEdit }) {
  const getCapacities = (trType) => {
    if (trType === '三相油入') return TR_RATINGS.three_phase_oil.capacities_kVA;
    if (trType === '単相油入') return TR_RATINGS.single_phase_oil.capacities_kVA;
    if (trType === 'モールド') return TR_RATINGS.mold.capacities_kVA;
    return TR_RATINGS.three_phase_oil.capacities_kVA;
  };

  const getAutoValues = (trType, kVA) => {
    const key = String(kVA);
    if (trType === '三相油入' && TR_RATINGS.three_phase_oil.data[key]) {
      const d = TR_RATINGS.three_phase_oil.data[key];
      return { pctZ: d.pct_z, xrRatio: d.xr_ratio };
    }
    if (trType === '単相油入' && TR_RATINGS.single_phase_oil.data[key]) {
      const d = TR_RATINGS.single_phase_oil.data[key];
      return { pctZ: d.pct_z, xrRatio: d.xr_ratio };
    }
    if (trType === 'モールド' && TR_RATINGS.mold.data[key]) {
      const d = TR_RATINGS.mold.data[key];
      return { pctZ: d.pct_z_min, xrRatio: null };
    }
    return { pctZ: 4.00, xrRatio: null };
  };

  const handleTypeChange = (val) => {
    const caps = getCapacities(val);
    const kVA = caps.includes(trParams.capacity_kVA) ? trParams.capacity_kVA : caps[0];
    const auto = getAutoValues(val, kVA);
    setTrParams(p => ({
      ...p, trType: val, capacity_kVA: kVA,
      ...(p.pctZAuto ? { pctZ: auto.pctZ, xrRatio: auto.xrRatio } : {})
    }));
  };

  const handleCapacityChange = (val) => {
    const kVA = Number(val);
    const auto = getAutoValues(trParams.trType, kVA);
    setTrParams(p => ({
      ...p, capacity_kVA: kVA,
      ...(p.pctZAuto ? { pctZ: auto.pctZ, xrRatio: auto.xrRatio } : {})
    }));
  };

  const capacities = getCapacities(trParams.trType);

  return (
    <div>
      <Sec title="変圧器情報">
        <RC label="変圧器名称">
          <input type="text" value={trParams.name} style={{ ...numStyle, textAlign: 'left' }}
            onChange={e => setTrParams(p => ({ ...p, name: e.target.value }))} />
        </RC>
        <RC label="種別">
          <select value={trParams.trType} style={selStyle} onChange={e => handleTypeChange(e.target.value)}>
            <option>三相油入</option><option>単相油入</option><option>モールド</option>
          </select>
        </RC>
        <RC label="容量 [kVA]">
          <select value={trParams.capacity_kVA} style={selStyle} onChange={e => handleCapacityChange(e.target.value)}>
            {capacities.map(c => <option key={c} value={c}>{c}</option>)}
          </select>
        </RC>
        <RC label="一次電圧 [V]">
          <select value={trParams.primaryV} style={selStyle} onChange={e => setTrParams(p => ({ ...p, primaryV: Number(e.target.value) }))}>
            <option value={3300}>3300</option><option value={6600}>6600</option>
          </select>
        </RC>
        <RC label="二次電圧 [V]">
          <select value={trParams.secondaryV} style={selStyle} onChange={e => setTrParams(p => ({ ...p, secondaryV: Number(e.target.value) }))}>
            <option value={105}>105</option><option value={210}>210</option><option value={420}>420</option>
          </select>
        </RC>
        <RC label="%Z">
          <div style={{ display: 'flex', gap: 6, alignItems: 'center' }}>
            <input type="number" step="0.01" value={trParams.pctZ} style={{ ...numStyle, flex: 1 }}
              disabled={trParams.pctZAuto}
              onChange={e => setTrParams(p => ({ ...p, pctZ: parseFloat(e.target.value) || 0 }))} />
            <label style={{ fontSize: 12, whiteSpace: 'nowrap' }}>
              <input type="checkbox" checked={trParams.pctZAuto}
                onChange={e => {
                  const auto = e.target.checked;
                  const vals = getAutoValues(trParams.trType, trParams.capacity_kVA);
                  setTrParams(p => ({ ...p, pctZAuto: auto, ...(auto ? { pctZ: vals.pctZ, xrRatio: vals.xrRatio } : {}) }));
                }} /> Auto
            </label>
          </div>
          {trParams.trType === 'モールド' && (
            <div style={{ fontSize: 11, color: '#888', marginTop: 2 }}>
              ※ モールド: 短絡電流計算は最小値を使用
            </div>
          )}
        </RC>
        <RC label="X/R 比">
          <input type="number" step="0.01" value={trParams.xrRatio != null ? trParams.xrRatio : ''} style={numStyle}
            disabled={trParams.pctZAuto && trParams.trType !== 'モールド'}
            onChange={e => setTrParams(p => ({ ...p, xrRatio: e.target.value === '' ? null : parseFloat(e.target.value) }))} />
        </RC>
        <RC label="結線方式">
          <select value={trParams.connection} style={selStyle}
            onChange={e => setTrParams(p => ({ ...p, connection: e.target.value }))}>
            {['Δ-Y', 'Y-Y', 'Δ-Δ', 'Y-Δ', 'V-V'].map(c => <option key={c}>{c}</option>)}
          </select>
        </RC>
      </Sec>
      <div style={{ display: 'flex', gap: 8 }}>
        <button onClick={onSave} style={{
          flex: 1, padding: '10px', borderRadius: 6, border: 'none',
          background: '#1976d2', color: '#fff', fontSize: 14, fontWeight: 700, cursor: 'pointer'
        }}>{isEdit ? '更新' : '+ 変圧器登録'}</button>
        {isEdit && (
          <button onClick={onCancel} style={{
            padding: '10px 16px', borderRadius: 6, border: '1px solid #ccc',
            background: '#fff', color: '#666', fontSize: 14, cursor: 'pointer'
          }}>取消</button>
        )}
      </div>
    </div>
  );
}

/* --- TrunkForm 幹線入力フォーム (§9-6) --- */
function TrunkForm({ trunkParams, setTrunkParams, onSave, onCancel, isEdit, childSummary }) {
  const isCustomReduction = trunkParams.reductionPreset === 'カスタム';
  return (
    <div>
      <Sec title="幹線情報">
        <RC label="幹線名称">
          <input type="text" value={trunkParams.name} style={{ ...numStyle, textAlign: 'left' }}
            onChange={e => setTrunkParams(p => ({ ...p, name: e.target.value }))} />
        </RC>
        <RC label="電気方式">
          <span style={{ fontSize: 13 }}>{trunkParams.system} {trunkParams.voltage}V</span>
        </RC>
      </Sec>
      <Sec title="ケーブル条件">
        <RC label="こう長 [m]">
          <input type="number" step="0.5" value={trunkParams.cableLength} style={numStyle}
            onChange={e => setTrunkParams(p => ({ ...p, cableLength: parseFloat(e.target.value) || 0 }))} />
        </RC>
        <RC label="力率 cosθ">
          <input type="number" step="0.01" min="0.10" max="1.00" value={trunkParams.powerFactor} style={numStyle}
            onChange={e => setTrunkParams(p => ({ ...p, powerFactor: parseFloat(e.target.value) || 0.85 }))} />
        </RC>
        <RC label="ケーブル種類">
          <select value={trunkParams.cableType} style={selStyle}
            onChange={e => setTrunkParams(p => ({ ...p, cableType: e.target.value }))}>
            {getCableTypeOptions(trunkParams.system).map(c => <option key={c}>{c}</option>)}
          </select>
        </RC>
        <RC label="配線方式">
          <select value={trunkParams.wiringMethod} style={selStyle}
            onChange={e => setTrunkParams(p => ({ ...p, wiringMethod: e.target.value }))}>
            {['ケーブルラック配線', '配管配線', '直埋布設', '管路布設'].map(w => <option key={w}>{w}</option>)}
          </select>
        </RC>
        <RC label="周囲温度 [℃]">
          <input type="number" step="5" min="20" max="50" value={trunkParams.ambientTemp} style={numStyle}
            onChange={e => setTrunkParams(p => ({ ...p, ambientTemp: Number(e.target.value) }))} />
        </RC>
        <RC label="多条低減プリセット">
          <select value={trunkParams.reductionPreset} style={selStyle}
            onChange={e => {
              const val = e.target.value;
              const preset = RED_PRE.find(p => p.label === val);
              setTrunkParams(p => ({ ...p, reductionPreset: val, ...(preset && preset.factor !== null ? { reductionFactor: preset.factor } : {}) }));
            }}>
            {RED_PRE.map(p => <option key={p.label} value={p.label}>{p.label}{p.factor !== null ? ` (${p.factor})` : ''}</option>)}
          </select>
        </RC>
        {isCustomReduction && (
          <RC label="低減率">
            <input type="number" step="0.01" min="0.10" max="1.00" value={trunkParams.reductionFactor} style={numStyle}
              onChange={e => setTrunkParams(p => ({ ...p, reductionFactor: parseFloat(e.target.value) || 0.70 }))} />
          </RC>
        )}
        {!isCustomReduction && (
          <RC label="低減率">
            <span style={{ fontSize: 13 }}>{trunkParams.reductionFactor}</span>
          </RC>
        )}
        <RC label="MCCB AT">
          <select value={trunkParams.mccbATOverride} style={selStyle}
            onChange={e => setTrunkParams(p => ({ ...p, mccbATOverride: e.target.value }))}>
            <option>自動</option>
            {MCCB_AT.map(at => <option key={at} value={at}>{at} AT</option>)}
          </select>
        </RC>
      </Sec>
      {childSummary && (
        <div style={{ fontSize: 12, color: '#666', background: '#f5f5f5', borderRadius: 4, padding: 8, marginBottom: 12 }}>
          子回路合計: 電動機 {childSummary.sumIM.toFixed(1)}A + 一般 {childSummary.sumIH.toFixed(1)}A = {childSummary.totalI.toFixed(1)}A
        </div>
      )}
      <div style={{ display: 'flex', gap: 8 }}>
        <button onClick={onSave} style={{
          flex: 1, padding: '10px', borderRadius: 6, border: 'none',
          background: '#1976d2', color: '#fff', fontSize: 14, fontWeight: 700, cursor: 'pointer'
        }}>{isEdit ? '幹線を更新' : '+ 幹線登録'}</button>
        {isEdit && (
          <button onClick={onCancel} style={{
            padding: '10px 16px', borderRadius: 6, border: '1px solid #ccc',
            background: '#fff', color: '#666', fontSize: 14, cursor: 'pointer'
          }}>取消</button>
        )}
      </div>
    </div>
  );
}

/* --- TreeTable 登録一覧ツリー表示 (§12) --- */
function TreeTable({ nodes, allResults, selectedId, onSelect, onDelete, onAddChild }) {
  if (nodes.length === 0) return (
    <div style={{ color: '#999', padding: 16, fontSize: 13 }}>
      変圧器または負荷回路を登録してください
    </div>
  );

  const tree = buildTree(nodes);

  const renderNode = (node, depth) => {
    const r = allResults[node.id];
    const isSelected = node.id === selectedId;
    const isTr = node.type === 'transformer';
    const isTrunk = node.type === 'trunk';
    const bgColor = isSelected ? '#e3f2fd' : isTr ? '#e8eaf6' : isTrunk ? '#f5f5f5' : '#fff';
    const tag = isTr ? '[TR]' : isTrunk ? '[主幹]' : '└';
    const name = isTr ? (node.transformer?.name || 'TR')
      : isTrunk ? (node.trunk?.name || '幹線')
      : (node.load?.loadName || '負荷');
    const sysV = isTr ? `${node.transformer?.secondaryV || ''}V`
      : isTrunk ? `${node.trunk?.system || ''} ${node.trunk?.voltage || ''}V`
      : `${node.load?.system || ''} ${node.load?.voltage || ''}V`;
    const cType = isTrunk ? (node.trunk?.cableType || '') : (node.load?.cableType || '');

    return (
      <React.Fragment key={node.id}>
        <tr onClick={() => onSelect(node)}
          style={{ background: bgColor, cursor: 'pointer', borderBottom: '1px solid #eee' }}>
          <td style={{ padding: '6px 4px', paddingLeft: 8 + depth * 20, fontSize: 12, whiteSpace: 'nowrap' }}>
            <span style={{
              display: 'inline-block', padding: '1px 4px', borderRadius: 3, fontSize: 11,
              fontWeight: 700, marginRight: 4,
              background: isTr ? '#3f51b5' : isTrunk ? '#78909c' : 'transparent',
              color: isTr || isTrunk ? '#fff' : '#999'
            }}>{tag}</span>
            {name}
          </td>
          <td style={{ padding: '6px 4px', fontSize: 12 }}>{sysV}</td>
          <td style={{ padding: '6px 4px', fontSize: 12, textAlign: 'right' }}>
            {r && r.dI != null ? `${r.dI}A` : r && r.In != null ? `${rd(r.In)}A` : '-'}
          </td>
          <td style={{ padding: '6px 4px', fontSize: 12 }}>
            {r && r.size ? `${cType} ${r.size}${r.parallel > 1 ? '×' + r.parallel : ''}` : '-'}
          </td>
          <td style={{ padding: '6px 4px', fontSize: 12, textAlign: 'right' }}>
            {r && r.mccbAT ? `${r.mccbAT}` : '-'}
          </td>
          <td style={{ padding: '6px 4px', fontSize: 12, textAlign: 'right' }}>
            {r && r.vd != null ? `${r.vd}V (${r.vdPercent}%)` : '-'}
          </td>
          <td style={{ padding: '6px 4px', fontSize: 12 }}>
            {r && r.ok != null ? <Badge ok={r.ok} label={r.ok ? 'OK' : 'NG'} /> : '-'}
          </td>
          <td style={{ padding: '6px 4px', fontSize: 12, textAlign: 'right' }}>
            {r && r.Isc3 ? `${rd(r.Isc3 / 1000, 1)}kA` : '-'}
          </td>
          <td style={{ padding: '6px 2px', whiteSpace: 'nowrap' }}>
            {(isTr || (isTrunk && depth < 2)) && onAddChild && (
              <button onClick={e => { e.stopPropagation(); onAddChild(node); }}
                style={{ border: 'none', background: 'none', color: '#1976d2', cursor: 'pointer', fontSize: 14, padding: '2px 6px', fontWeight: 700 }}>+</button>
            )}
            <button onClick={e => { e.stopPropagation(); onDelete(node.id); }}
              style={{ border: 'none', background: 'none', color: '#f44336', cursor: 'pointer', fontSize: 14, padding: '2px 6px' }}>×</button>
          </td>
        </tr>
        {node.children && node.children.map(child => renderNode(child, depth + 1))}
      </React.Fragment>
    );
  };

  return (
    <div style={{ overflowX: 'auto' }}>
      <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: 13 }}>
        <thead>
          <tr style={{ background: '#fafafa', borderBottom: '2px solid #ddd' }}>
            <th style={{ padding: '6px 4px', textAlign: 'left', fontSize: 12 }}>名称</th>
            <th style={{ padding: '6px 4px', textAlign: 'left', fontSize: 12 }}>方式/電圧</th>
            <th style={{ padding: '6px 4px', textAlign: 'right', fontSize: 12 }}>設計I</th>
            <th style={{ padding: '6px 4px', textAlign: 'left', fontSize: 12 }}>ケーブル</th>
            <th style={{ padding: '6px 4px', textAlign: 'right', fontSize: 12 }}>AT</th>
            <th style={{ padding: '6px 4px', textAlign: 'right', fontSize: 12 }}>e [V]</th>
            <th style={{ padding: '6px 4px', textAlign: 'left', fontSize: 12 }}>判定</th>
            <th style={{ padding: '6px 4px', textAlign: 'right', fontSize: 12 }}>Isc₃</th>
            <th style={{ padding: '6px 4px', fontSize: 12 }}></th>
          </tr>
        </thead>
        <tbody>
          {tree.map(node => renderNode(node, 0))}
        </tbody>
      </table>
    </div>
  );
}

/* === PDF GENERATION === */

/**
 * genPDF — 電-8-1 様式の電路計算書 HTML を生成 (§15)
 *
 * @param {Array} nodes - 全ノード配列
 * @param {Object} allResults - calculateAll() の結果マップ
 * @returns {string} 完全な HTML 文字列
 */
function genPDF(nodes, allResults) {
  const tree = buildTree(nodes);
  const rows = [];

  /* ツリーを再帰的に走査して行データを生成 */
  function walkTree(node, depth) {
    const r = allResults[node.id];
    if (node.type === 'transformer') {
      const tr = node.transformer || {};
      rows.push({
        type: 'transformer', depth,
        trunkName: tr.name || '',
        system: '', voltage: `${tr.primaryV || ''}/${tr.secondaryV || ''}`,
        mccbAT: '', loadName: tr.trType || '',
        capacity: `${tr.capacity_kVA || ''}kVA`, dI: r ? `${rd(r.In)}` : '',
        cableLength: '', cableSpec: '', wiring: '',
        baseAmpacity: '', reductionFactor: '', effectiveAmpacity: '',
        K: '', cosT: '', Z: '', vd: '', allowVd: '', judge: '',
        pctZ: tr.pctZ != null ? `%Z=${tr.pctZ}` : ''
      });
    } else if (node.type === 'trunk') {
      const t = node.trunk || {};
      const sizeStr = r ? `${r.size}${r.parallel > 1 ? '×' + r.parallel : ''}` : '';
      rows.push({
        type: 'trunk', depth,
        trunkName: t.name || '',
        system: t.system || '', voltage: t.voltage || '',
        mccbAT: r ? r.mccbAT : '',
        loadName: '',
        capacity: r && r.totalI != null ? `${r.totalI}A(合計)` : '',
        dI: r ? r.sizingI : '',
        cableLength: t.cableLength || '',
        cableSpec: r ? `${t.cableType} ${sizeStr}` : '',
        wiring: t.wiringMethod ? t.wiringMethod.replace('配線', '').replace('布設', '') : '',
        baseAmpacity: r ? r.baseAmpacity : '',
        reductionFactor: r ? r.reductionFactor : '',
        effectiveAmpacity: r ? r.effectiveAmpacity : '',
        K: r ? (r.K === Math.sqrt(3) ? '√3' : r.K) : '',
        cosT: t.powerFactor || '',
        Z: r ? r.Z : '',
        vd: r ? `${r.vd}V (${r.vdPercent}%)` : '',
        allowVd: r ? `${r.allowVd}V (${r.allowVdPercent}%)` : '',
        judge: r ? (r.ok ? 'OK' : 'NG') : ''
      });
    } else if (node.type === 'load') {
      const p = node.load || {};
      const sizeStr = r ? `${r.size}${r.parallel > 1 ? '×' + r.parallel : ''}` : '';
      rows.push({
        type: 'load', depth,
        trunkName: '',
        system: p.system || '', voltage: p.voltage || '',
        mccbAT: r ? r.mccbAT : '',
        loadName: p.loadName || '',
        capacity: p.unit === 'A' ? `${p.capacity}A` : `${p.capacity}${p.unit}`,
        dI: r ? r.dI : '',
        cableLength: p.cableLength || '',
        cableSpec: r ? `${p.cableType} ${sizeStr}` : '',
        wiring: p.wiringMethod ? p.wiringMethod.replace('配線', '').replace('布設', '') : '',
        baseAmpacity: r ? r.baseAmpacity : '',
        reductionFactor: r ? r.reductionFactor : '',
        effectiveAmpacity: r ? r.effectiveAmpacity : '',
        K: r ? (r.K === Math.sqrt(3) ? '√3' : r.K) : '',
        cosT: p.powerFactor || '',
        Z: r ? r.Z : '',
        vd: r ? `${r.vd}V (${r.vdPercent}%)` : '',
        allowVd: r ? `${r.allowVd}V (${r.allowVdPercent}%)` : '',
        judge: r ? (r.ok ? 'OK' : 'NG') : ''
      });
    }
    if (node.children) {
      for (const child of node.children) walkTree(child, depth + 1);
    }
  }
  for (const root of tree) walkTree(root, 0);

  /* HTML テーブル行を生成 */
  const tbodyHtml = rows.map(row => {
    const cls = row.type === 'trunk' ? ' class="trunk-row"'
      : row.type === 'transformer' ? ' class="tr-row"' : '';
    const indent = row.depth > 0 ? `padding-left:${8 + row.depth * 16}px` : '';
    const nameStyle = indent ? ` style="${indent}"` : '';
    return `<tr${cls}>
      <td${nameStyle}>${esc(row.trunkName)}</td>
      <td>${esc(String(row.system))}</td>
      <td class="r">${esc(String(row.voltage))}</td>
      <td class="r">${esc(String(row.mccbAT))}</td>
      <td>${esc(row.loadName)}</td>
      <td class="r">${esc(String(row.capacity))}</td>
      <td class="r">${esc(String(row.dI))}</td>
      <td class="r">${esc(String(row.cableLength))}</td>
      <td>${esc(row.cableSpec)}</td>
      <td>${esc(row.wiring)}</td>
      <td class="r">${esc(String(row.baseAmpacity))}</td>
      <td class="r">${esc(String(row.reductionFactor))}</td>
      <td class="r">${esc(String(row.effectiveAmpacity))}</td>
      <td class="r">${esc(String(row.K))}</td>
      <td class="r">${esc(String(row.cosT))}</td>
      <td class="r">${esc(String(row.Z))}</td>
      <td class="r">${esc(row.vd)}</td>
      <td class="r">${esc(row.allowVd)}</td>
      <td class="r judge-${row.judge === 'OK' ? 'ok' : row.judge === 'NG' ? 'ng' : ''}">${esc(row.judge)}</td>
    </tr>`;
  }).join('\n');

  return `<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>低圧幹線ケーブル電路計算書</title>
<style>
@page { size: A3 landscape; margin: 8mm; }
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: 'MS Gothic', 'Hiragino Kaku Gothic ProN', monospace; font-size: 9pt; color: #000; }
h2 { font-size: 13pt; margin-bottom: 6px; }
table { border-collapse: collapse; width: 100%; margin-bottom: 12px; }
th, td { border: 1px solid #333; padding: 2px 4px; font-size: 8pt; white-space: nowrap; vertical-align: middle; }
th { background: #e8e8e8; font-weight: 700; text-align: center; }
td.r { text-align: right; }
.trunk-row { font-weight: 700; background: #dce6f7; }
.tr-row { font-weight: 700; background: #e8e0f0; }
.judge-ok { color: #006400; font-weight: 700; }
.judge-ng { color: #c00; font-weight: 700; }
.footer { font-size: 8pt; margin-top: 8px; line-height: 1.6; border-top: 1px solid #999; padding-top: 4px; }
.footer dt { font-weight: 700; }
@media print { body { -webkit-print-color-adjust: exact; print-color-adjust: exact; } }
</style>
</head>
<body>
<h2>低圧幹線ケーブル電路計算書</h2>
<p style="font-size:8pt;margin-bottom:4px;">出力日: ${new Date().toLocaleDateString('ja-JP')}</p>
<table>
<thead>
<tr>
  <th rowspan="2">幹線番号<br>/名称</th>
  <th rowspan="2">電気方式</th>
  <th rowspan="2">電圧<br>[V]</th>
  <th rowspan="2">遮断器<br>[AT]</th>
  <th rowspan="2">負荷名称</th>
  <th rowspan="2">負荷容量</th>
  <th rowspan="2">設計電流<br>[A]</th>
  <th rowspan="2">L<br>[m]</th>
  <th colspan="5">許容電流</th>
  <th colspan="5">電圧降下</th>
  <th rowspan="2">判定</th>
</tr>
<tr>
  <th>種別/太さ</th>
  <th>配線</th>
  <th>許容<br>[A]</th>
  <th>低減率</th>
  <th>補正後<br>[A]</th>
  <th>K</th>
  <th>cosθ</th>
  <th>Z<br>[Ω/km]</th>
  <th>e [V]<br>(%)</th>
  <th>許容e [V]<br>(%)</th>
</tr>
</thead>
<tbody>
${tbodyHtml}
</tbody>
</table>
<div class="footer">
<dl>
<dt>電圧降下計算式</dt>
<dd>e = K × I × l × Z / 1000 [V]　（l: こう長 [m]）</dd>
<dt>Z（インピーダンス）</dt>
<dd>Z = R·cosθ + X·sinθ [Ω/km]（精密式）</dd>
<dt>K値</dt>
<dd>単相2線式: K=2　/　単相3線式: K=1　/　三相3線式: K=√3　/　三相4線式: K=1</dd>
<dt>保護協調判定基準</dt>
<dd>一般回路: 実効許容電流 ≧ MCCB定格 [AT]　/　電動機回路: 実効許容電流 ≧ AT / 2.5</dd>
</dl>
</div>
</body>
</html>`;
}

/** HTML エスケープ */
function esc(s) { return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }

/* === DIAGRAM OUTPUT (M2-5) === */

/**
 * genDiagramHTML — 系統図を印刷用 HTML/SVG として生成
 */
function genDiagramHTML(nodes, allResults, systemMeta) {
  const direction = (systemMeta && systemMeta.diagramDirection) || 'horizontal';
  /* canvas 座標を確定 */
  const positioned = ensureCanvasPositions(nodes, direction);

  /* SVG バウンディングボックスを計算 */
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const n of positioned) {
    if (!n.canvas) continue;
    minX = Math.min(minX, n.canvas.x);
    minY = Math.min(minY, n.canvas.y);
    maxX = Math.max(maxX, n.canvas.x + n.canvas.width);
    maxY = Math.max(maxY, n.canvas.y + n.canvas.height);
  }
  const pad = 60;
  minX -= pad; minY -= pad; maxX += pad; maxY += pad;
  const svgW = maxX - minX;
  const svgH = maxY - minY;

  /* 接続線 SVG */
  const dir = DIRECTIONS[direction];
  let connSvg = '';
  for (const n of positioned) {
    if (!n.parentId || !n.canvas) continue;
    const parent = positioned.find(p => p.id === n.parentId);
    if (!parent || !parent.canvas) continue;
    let fx, fy, tx, ty;
    if (dir.outPort === 'right') {
      fx = parent.canvas.x + parent.canvas.width; fy = parent.canvas.y + parent.canvas.height / 2;
      tx = n.canvas.x; ty = n.canvas.y + n.canvas.height / 2;
    } else {
      fx = parent.canvas.x + parent.canvas.width / 2; fy = parent.canvas.y + parent.canvas.height;
      tx = n.canvas.x + n.canvas.width / 2; ty = n.canvas.y;
    }
    const mx = (fx + tx) / 2, my = (fy + ty) / 2;
    const r = allResults[n.id];
    const col = r ? (r.ok ? '#333' : '#c00') : '#999';
    const dash = r && !r.ok ? 'stroke-dasharray="4 2"' : '';
    const d = dir.outPort === 'right'
      ? `M${fx},${fy} C${mx},${fy} ${mx},${ty} ${tx},${ty}`
      : `M${fx},${fy} C${fx},${my} ${tx},${my} ${tx},${ty}`;
    connSvg += `<path d="${d}" fill="none" stroke="${col}" stroke-width="1.5" ${dash}/>\n`;
  }

  /* モジュール SVG */
  let modSvg = '';
  for (const n of positioned) {
    if (!n.canvas) continue;
    const { x, y, width: w, height: h } = n.canvas;
    const r = allResults[n.id];

    if (n.type === 'transformer') {
      const tr = n.transformer || {};
      const rad = Math.min(w, h) * 0.22;
      const cx = x + w / 2, cy = y + h / 2;
      const [pri, sec] = (tr.connection || 'Δ-Y').split('-');
      modSvg += `<rect x="${x}" y="${y}" width="${w}" height="${h}" rx="4" fill="#f3e5f5" stroke="#7b1fa2" stroke-width="1.5"/>`;
      modSvg += `<circle cx="${cx - rad * 0.5}" cy="${cy}" r="${rad}" fill="none" stroke="#333" stroke-width="1.5"/>`;
      modSvg += `<circle cx="${cx + rad * 0.5}" cy="${cy}" r="${rad}" fill="none" stroke="#333" stroke-width="1.5"/>`;
      modSvg += `<text x="${cx - rad * 0.5}" y="${cy - rad - 4}" font-size="9" text-anchor="middle" fill="#555">${esc(pri)}</text>`;
      modSvg += `<text x="${cx + rad * 0.5}" y="${cy - rad - 4}" font-size="9" text-anchor="middle" fill="#555">${esc(sec)}</text>`;
      modSvg += `<text x="${cx}" y="${y - 6}" font-size="10" text-anchor="middle" font-weight="700" fill="#333">${esc(tr.name || 'TR')}</text>`;
      modSvg += `<text x="${cx}" y="${y + h + 12}" font-size="8" text-anchor="middle" fill="#666">${esc(String(tr.capacity_kVA || ''))}kVA ${esc(String(tr.primaryV || ''))}/${esc(String(tr.secondaryV || ''))}V</text>`;
      if (r) modSvg += `<text x="${cx}" y="${y + h + 22}" font-size="8" text-anchor="middle" fill="#666">Isc₃=${rd(r.Isc3 / 1000, 1)}kA  %Z=${tr.pctZ}</text>`;

    } else if (n.type === 'trunk') {
      const tr = n.trunk || {};
      const ok = r ? r.ok : null;
      const border = ok === false ? '#c00' : ok ? '#4caf50' : '#999';
      const bg = ok === false ? '#fff5f5' : '#fff';
      const sizeStr = r ? `${r.size}${r.parallel > 1 ? '×' + r.parallel : ''}` : '';
      modSvg += `<rect x="${x}" y="${y}" width="${w}" height="${h}" rx="4" fill="${bg}" stroke="${border}" stroke-width="1.5"/>`;
      /* MCCB */
      const mx = x + 18, my = y + h / 2, mw = 20, mh = 14;
      modSvg += `<rect x="${mx - mw / 2}" y="${my - mh / 2}" width="${mw}" height="${mh}" fill="#fff" stroke="#333" stroke-width="1.2"/>`;
      modSvg += `<line x1="${mx - mw / 4}" y1="${my - mh / 2}" x2="${mx + mw / 4}" y2="${my + mh / 2}" stroke="#333" stroke-width="1.2"/>`;
      if (r) modSvg += `<text x="${x + 36}" y="${my - 6}" font-size="8" fill="#333">${r.mccbAT}AT</text>`;
      modSvg += `<text x="${x + 36}" y="${my + 5}" font-size="8" fill="#555">${esc(tr.cableType)} ${sizeStr}</text>`;
      modSvg += `<text x="${x + 36}" y="${my + 15}" font-size="7" fill="#888">${tr.cableLength}m</text>`;
      modSvg += `<text x="${x + w / 2}" y="${y - 5}" font-size="10" text-anchor="middle" font-weight="600" fill="#333">${esc(tr.name || '幹線')}</text>`;
      if (r) modSvg += `<text x="${x + w - 6}" y="${my + 3}" font-size="8" text-anchor="end" fill="#666">${rd(r.dI, 1)}A  e=${r.vdPercent}%</text>`;
      if (ok != null) {
        modSvg += `<rect x="${x + w - 22}" y="${y + 3}" width="18" height="12" rx="2" fill="${ok ? '#e8f5e9' : '#ffebee'}" stroke="${ok ? '#4caf50' : '#c00'}" stroke-width="0.8"/>`;
        modSvg += `<text x="${x + w - 13}" y="${y + 12}" font-size="7" text-anchor="middle" font-weight="700" fill="${ok ? '#2e7d32' : '#c00'}">${ok ? 'OK' : 'NG'}</text>`;
      }

    } else if (n.type === 'load') {
      const p = n.load || {};
      const ok = r ? r.ok : null;
      const border = ok === false ? '#c00' : ok ? '#4caf50' : '#999';
      const bg = ok === false ? '#fff5f5' : '#fff';
      const sizeStr = r ? `${r.size}${r.parallel > 1 ? '×' + r.parallel : ''}` : '';
      modSvg += `<rect x="${x}" y="${y}" width="${w}" height="${h}" rx="4" fill="${bg}" stroke="${border}" stroke-width="1.5"/>`;
      /* MCCB */
      const mx = x + 18, my = y + h / 2, mw = 20, mh = 14;
      modSvg += `<rect x="${mx - mw / 2}" y="${my - mh / 2}" width="${mw}" height="${mh}" fill="#fff" stroke="#333" stroke-width="1.2"/>`;
      modSvg += `<line x1="${mx - mw / 4}" y1="${my - mh / 2}" x2="${mx + mw / 4}" y2="${my + mh / 2}" stroke="#333" stroke-width="1.2"/>`;
      if (r) modSvg += `<text x="${x + 36}" y="${my - 4}" font-size="8" fill="#333">${r.mccbAT}AT</text>`;
      modSvg += `<text x="${x + 36}" y="${my + 7}" font-size="7" fill="#888">${esc(p.cableType)} ${sizeStr} ${p.cableLength}m</text>`;
      /* 負荷シンボル */
      if (p.circuitType === '電動機') {
        modSvg += `<circle cx="${x + w - 18}" cy="${my}" r="10" fill="#e3f2fd" stroke="#1565c0" stroke-width="1.5"/>`;
        modSvg += `<text x="${x + w - 18}" y="${my + 4}" font-size="10" text-anchor="middle" font-weight="700" fill="#1565c0">M</text>`;
      } else {
        modSvg += `<polygon points="${x + w - 18},${my - 10} ${x + w - 8},${my + 6} ${x + w - 28},${my + 6}" fill="#fff3e0" stroke="#e65100" stroke-width="1.5"/>`;
      }
      modSvg += `<text x="${x + w / 2}" y="${y - 5}" font-size="9" text-anchor="middle" font-weight="600" fill="#333">${esc(p.loadName || p.trunkName || '負荷')}</text>`;
      if (r) modSvg += `<text x="${x + w / 2}" y="${y + h + 11}" font-size="7" text-anchor="middle" fill="#666">${rd(r.dI, 1)}A  e=${r.vdPercent}%</text>`;
      if (ok != null) {
        modSvg += `<rect x="${x + w - 22}" y="${y + 3}" width="18" height="12" rx="2" fill="${ok ? '#e8f5e9' : '#ffebee'}" stroke="${ok ? '#4caf50' : '#c00'}" stroke-width="0.8"/>`;
        modSvg += `<text x="${x + w - 13}" y="${y + 12}" font-size="7" text-anchor="middle" font-weight="700" fill="${ok ? '#2e7d32' : '#c00'}">${ok ? 'OK' : 'NG'}</text>`;
      }
    }
  }

  /* 標題欄 */
  const titleX = maxX - 200, titleY = maxY - 60;
  const titleSvg = `
    <rect x="${titleX}" y="${titleY}" width="180" height="50" fill="#fff" stroke="#333" stroke-width="1"/>
    <text x="${titleX + 90}" y="${titleY + 14}" font-size="11" text-anchor="middle" font-weight="700" fill="#333">幹線系統図</text>
    <line x1="${titleX}" y1="${titleY + 18}" x2="${titleX + 180}" y2="${titleY + 18}" stroke="#333" stroke-width="0.5"/>
    <text x="${titleX + 6}" y="${titleY + 30}" font-size="7" fill="#666">工事名称: ${esc(systemMeta.projectName || '')}</text>
    <text x="${titleX + 6}" y="${titleY + 40}" font-size="7" fill="#666">作成日: ${new Date().toLocaleDateString('ja-JP')}</text>
  `;

  /* 凡例 */
  const legX = minX + 10, legY = maxY - 80;
  const legendSvg = `
    <rect x="${legX}" y="${legY}" width="160" height="70" fill="#fff" stroke="#999" stroke-width="0.5" rx="2"/>
    <text x="${legX + 6}" y="${legY + 12}" font-size="8" font-weight="700" fill="#333">凡例</text>
    <rect x="${legX + 6}" y="${legY + 18}" width="14" height="10" fill="#fff" stroke="#333" stroke-width="1"/>
    <line x1="${legX + 9}" y1="${legY + 18}" x2="${legX + 17}" y2="${legY + 28}" stroke="#333" stroke-width="1"/>
    <text x="${legX + 26}" y="${legY + 27}" font-size="7" fill="#333">MCCB（配線用遮断器）</text>
    <circle cx="${legX + 13}" cy="${legY + 38}" r="6" fill="none" stroke="#333" stroke-width="1"/>
    <circle cx="${legX + 19}" cy="${legY + 38}" r="6" fill="none" stroke="#333" stroke-width="1"/>
    <text x="${legX + 32}" y="${legY + 41}" font-size="7" fill="#333">変圧器</text>
    <circle cx="${legX + 13}" cy="${legY + 54}" r="6" fill="#e3f2fd" stroke="#1565c0" stroke-width="1"/>
    <text x="${legX + 13}" y="${legY + 57}" font-size="6" text-anchor="middle" font-weight="700" fill="#1565c0">M</text>
    <text x="${legX + 26}" y="${legY + 57}" font-size="7" fill="#333">電動機</text>
    <polygon points="${legX + 90},${legY + 20} ${legX + 98},${legY + 30} ${legX + 82},${legY + 30}" fill="#fff3e0" stroke="#e65100" stroke-width="1"/>
    <text x="${legX + 104}" y="${legY + 27}" font-size="7" fill="#333">一般負荷</text>
  `;

  return `<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>幹線系統図</title>
<style>
@page { size: A3 landscape; margin: 10mm; }
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: 'MS Gothic', 'Hiragino Kaku Gothic ProN', monospace; }
svg { width: 100%; height: auto; }
@media print { body { -webkit-print-color-adjust: exact; print-color-adjust: exact; } }
</style>
</head>
<body>
<svg viewBox="${minX} ${minY} ${svgW} ${svgH}" xmlns="http://www.w3.org/2000/svg">
${connSvg}
${modSvg}
${titleSvg}
${legendSvg}
</svg>
</body>
</html>`;
}

/* === APP === */
function App() {
  /* --- State: live（表示用）と calc（計算用）の2層管理 (§6) --- */
  const [params, setParams] = React.useState({ ...DEFAULT_PARAMS });
  const [display, setDisplay] = React.useState({
    capacity: String(DEFAULT_PARAMS.capacity),
    powerFactor: String(DEFAULT_PARAMS.powerFactor),
    efficiency: String(DEFAULT_PARAMS.efficiency),
    demandFactor: String(DEFAULT_PARAMS.demandFactor),
    cableLength: String(DEFAULT_PARAMS.cableLength),
    ambientTemp: String(DEFAULT_PARAMS.ambientTemp),
    reductionFactor: String(DEFAULT_PARAMS.reductionFactor)
  });

  /* --- P4: ツリー状態 (§18-7) --- */
  const [nodes, setNodes] = React.useState([]);
  const [selectedId, setSelectedId] = React.useState(null);
  const [editMode, setEditMode] = React.useState('load');
  const [trParams, setTrParams] = React.useState({ ...DEFAULT_TR_PARAMS });
  const [trunkParams, setTrunkParams] = React.useState({ ...DEFAULT_TRUNK_PARAMS });
  const fileInputRef = React.useRef(null);

  /* --- M2: 系統図ステート --- */
  const [systemMeta, setSystemMeta] = React.useState({
    projectName: '', hvVoltage: 6600, freq: '60Hz',
    substationName: '受電設備', diagramDirection: 'horizontal'
  });
  const [rightPaneView, setRightPaneView] = React.useState('table'); /* 'table' | 'diagram' | 'split' */
  const [diagramMode, setDiagramMode] = React.useState('edit'); /* 'edit' | 'view' */

  /* --- 計算結果（フォームプレビュー用） --- */
  const result = React.useMemo(() => {
    if (editMode !== 'load' || params.capacity <= 0) return null;
    return runCalc(params);
  }, [params, editMode]);

  /* --- 全ノード一括計算 --- */
  const allResults = React.useMemo(() => {
    if (nodes.length === 0) return {};
    return calculateAll(nodes);
  }, [nodes]);

  /* --- M2: canvas 座標が未設定のノードに自動配置を適用 --- */
  React.useEffect(() => {
    if (nodes.length === 0) return;
    const needsLayout = nodes.some(n => !n.canvas || n.canvas.x == null);
    if (!needsLayout) return;
    const updated = ensureCanvasPositions(nodes, systemMeta.diagramDirection);
    if (updated !== nodes) setNodes(updated);
  }, [nodes.length]);

  /* --- 選択中ノードの情報 --- */
  const selectedNode = nodes.find(n => n.id === selectedId);
  const selectedResult = selectedId ? allResults[selectedId] : null;

  /* --- 変圧器プレビュー --- */
  const trPreview = React.useMemo(() => {
    if (editMode !== 'transformer') return null;
    return calcTransformer(trParams);
  }, [trParams, editMode]);

  /* --- 幹線の子回路集計 --- */
  const trunkChildSummary = React.useMemo(() => {
    if (editMode !== 'trunk' || !selectedId) return null;
    return aggregateCurrents(nodes, selectedId, allResults);
  }, [editMode, selectedId, nodes, allResults]);

  /* --- 連動制御ヘルパー (§5) --- */
  const updateSelect = (key, val) => {
    setParams(prev => {
      const next = { ...prev, [key]: val };
      if (key === 'system') {
        const voltages = VOLTAGE_OPTIONS[val];
        if (!voltages.includes(prev.voltage)) next.voltage = voltages[0];
        const cableOpts = getCableTypeOptions(val);
        if (!cableOpts.includes(prev.cableType)) next.cableType = cableOpts[0];
      }
      if (key === 'circuitType') {
        if (val === '一般') next.efficiency = 1.0;
      }
      if (key === 'reductionPreset') {
        const preset = RED_PRE.find(p => p.label === val);
        if (preset && preset.factor !== null) {
          next.reductionFactor = preset.factor;
          setDisplay(d => ({ ...d, reductionFactor: String(preset.factor) }));
        }
      }
      return next;
    });
  };

  const confirmNum = (key) => {
    const raw = display[key];
    const n = parseFloat(raw);
    if (!isNaN(n)) setParams(prev => ({ ...prev, [key]: n }));
    else setDisplay(d => ({ ...d, [key]: String(params[key]) }));
  };

  const updateNumLive = (key, val) => {
    if (typeof val === 'number') {
      setDisplay(d => ({ ...d, [key]: String(val) }));
      setParams(prev => ({ ...prev, [key]: val }));
    } else {
      setDisplay(d => ({ ...d, [key]: val }));
    }
  };

  /* --- フォームリセット --- */
  const resetToNewLoad = () => {
    setSelectedId(null);
    setEditMode('load');
    setParams({ ...DEFAULT_PARAMS });
    setDisplay({
      capacity: String(DEFAULT_PARAMS.capacity),
      powerFactor: String(DEFAULT_PARAMS.powerFactor),
      efficiency: String(DEFAULT_PARAMS.efficiency),
      demandFactor: String(DEFAULT_PARAMS.demandFactor),
      cableLength: String(DEFAULT_PARAMS.cableLength),
      ambientTemp: String(DEFAULT_PARAMS.ambientTemp),
      reductionFactor: String(DEFAULT_PARAMS.reductionFactor)
    });
  };

  /* --- CRUD: 負荷登録 --- */
  const handleRegisterLoad = () => {
    if (!result || !params.trunkName || params.capacity <= 0) return;
    setNodes(prev => {
      let updated = [...prev];
      const trNode = updated.find(n => n.type === 'transformer');
      let trunk = updated.find(n => n.type === 'trunk' && n.trunk.name === params.trunkName);
      if (!trunk) {
        const trId = trNode ? trNode.id : null;
        trunk = {
          id: genId(), type: 'trunk', parentId: trId,
          order: getChildren(updated, trId).length,
          ts: new Date().toISOString(), externalRef: null,
          canvas: null,
          trunk: {
            ...DEFAULT_TRUNK_PARAMS, name: params.trunkName,
            system: params.system, voltage: params.voltage,
            freq: params.freq, supplyType: trNode ? '高圧受電' : params.supplyType
          }
        };
        updated = addNode(updated, trunk);
      }
      const loadNode = {
        id: genId(), type: 'load', parentId: trunk.id,
        order: getChildren(updated, trunk.id).length,
        ts: new Date().toISOString(), externalRef: null,
        canvas: null,
        load: { ...params }
      };
      updated = addNode(updated, loadNode);
      return updated;
    });
    resetToNewLoad();
  };

  /* --- CRUD: ノード更新 --- */
  const handleUpdateNode = () => {
    if (!selectedId) return;
    const node = nodes.find(n => n.id === selectedId);
    if (!node) return;
    if (node.type === 'load') {
      setNodes(prev => updateNode(prev, selectedId, { load: { ...params } }));
    } else if (node.type === 'trunk') {
      setNodes(prev => updateNode(prev, selectedId, { trunk: { ...trunkParams } }));
    } else if (node.type === 'transformer') {
      setNodes(prev => {
        let updated = updateNode(prev, selectedId, { transformer: { ...trParams } });
        if (node.transformer.secondaryV !== trParams.secondaryV) {
          const desc = getDescendants(updated, selectedId);
          for (const d of desc) {
            if (d.type === 'trunk') updated = updateNode(updated, d.id, { trunk: { ...d.trunk, voltage: trParams.secondaryV } });
            else if (d.type === 'load') updated = updateNode(updated, d.id, { load: { ...d.load, voltage: trParams.secondaryV } });
          }
        }
        return updated;
      });
    }
    resetToNewLoad();
  };

  /* --- CRUD: ノード削除 --- */
  const handleDeleteNode = (id) => {
    setNodes(prev => {
      const target = prev.find(n => n.id === id);
      let updated = removeNode(prev, id);
      /* §13: load 削除後に親 trunk の子が 0 件なら trunk も自動削除 */
      if (target && target.type === 'load' && target.parentId) {
        const parentTrunk = updated.find(n => n.id === target.parentId);
        if (parentTrunk && parentTrunk.type === 'trunk' && getChildren(updated, parentTrunk.id).length === 0) {
          updated = removeNode(updated, parentTrunk.id);
        }
      }
      return updated;
    });
    if (selectedId === id) resetToNewLoad();
  };

  /* --- CRUD: 変圧器登録/更新 --- */
  const handleSaveTransformer = () => {
    if (selectedId && selectedNode?.type === 'transformer') {
      handleUpdateNode();
    } else {
      setNodes(prev => {
        const trCount = prev.filter(n => n.type === 'transformer').length;
        return addNode(prev, {
          id: genId(), type: 'transformer', parentId: null,
          order: trCount, ts: new Date().toISOString(), externalRef: null,
          transformer: { ...trParams },
          canvas: null /* 自動配置で割り当て */
        });
      });
      resetToNewLoad();
    }
  };

  /* --- CRUD: 幹線更新 --- */
  const handleSaveTrunk = () => {
    if (selectedId && selectedNode?.type === 'trunk') handleUpdateNode();
  };

  /* --- ツリー: 子ノード追加 --- */
  const handleAddChild = (parentNode) => {
    if (parentNode.type === 'transformer') {
      setSelectedId(null);
      setEditMode('trunk');
      setTrunkParams({ ...DEFAULT_TRUNK_PARAMS, voltage: parentNode.transformer?.secondaryV || 210 });
    } else if (parentNode.type === 'trunk') {
      setSelectedId(null);
      setEditMode('load');
      setParams({ ...DEFAULT_PARAMS, trunkName: parentNode.trunk?.name || '' });
      setDisplay({
        capacity: String(DEFAULT_PARAMS.capacity),
        powerFactor: String(DEFAULT_PARAMS.powerFactor),
        efficiency: String(DEFAULT_PARAMS.efficiency),
        demandFactor: String(DEFAULT_PARAMS.demandFactor),
        cableLength: String(DEFAULT_PARAMS.cableLength),
        ambientTemp: String(DEFAULT_PARAMS.ambientTemp),
        reductionFactor: String(DEFAULT_PARAMS.reductionFactor)
      });
    }
  };

  /* --- 行クリック: ノード選択 --- */
  const handleSelectNode = (node) => {
    setSelectedId(node.id);
    if (node.type === 'transformer') {
      setEditMode('transformer');
      setTrParams({ ...node.transformer });
    } else if (node.type === 'trunk') {
      setEditMode('trunk');
      setTrunkParams({ ...node.trunk });
    } else {
      setEditMode('load');
      const p = { ...node.load };
      setParams(p);
      setDisplay({
        capacity: String(p.capacity), powerFactor: String(p.powerFactor),
        efficiency: String(p.efficiency), demandFactor: String(p.demandFactor),
        cableLength: String(p.cableLength), ambientTemp: String(p.ambientTemp),
        reductionFactor: String(p.reductionFactor)
      });
    }
  };

  /* --- Export (§14, M2-1-4: スキーマ拡張) --- */
  const handleExport = () => {
    const data = { version: 'M2', nodes, systemMeta, exportedAt: new Date().toISOString() };
    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `幹線計算_${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    URL.revokeObjectURL(url);
  };

  /* --- Import (§14) --- */
  const handleImport = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const data = JSON.parse(ev.target.result);
        if (data.nodes && Array.isArray(data.nodes)) {
          const existingIds = new Set(nodes.map(n => n.id));
          const idMap = {};
          const imported = data.nodes.map(n => {
            let newId = n.id;
            if (existingIds.has(n.id)) { newId = genId(); idMap[n.id] = newId; }
            /* P5 形式は canvas フィールドがないため null で補完 */
            return { ...n, id: newId, canvas: n.canvas || null };
          }).map(n => ({
            ...n, parentId: n.parentId ? (idMap[n.parentId] || n.parentId) : null
          }));
          setNodes(prev => [...prev, ...imported]);
          /* M2: systemMeta の復元 */
          if (data.systemMeta) setSystemMeta(prev => ({ ...prev, ...data.systemMeta }));
          alert(`${imported.length} ノードをインポートしました`);
        } else if (data.records && Array.isArray(data.records)) {
          alert('旧形式（P3）のファイルです。P4 以降の形式でエクスポートし直してください。');
        } else { alert('有効なデータが見つかりません'); }
      } catch (err) { alert('JSON の読み込みに失敗しました: ' + err.message); }
      if (fileInputRef.current) fileInputRef.current.value = '';
    };
    reader.readAsText(file);
  };

  /* --- PDF出力 (§15) --- */
  const handlePDF = () => {
    const html = genPDF(nodes, allResults);
    const w = window.open('', '_blank');
    if (w) { w.document.write(html); w.document.close(); }
    else { alert('ポップアップがブロックされました。ブラウザの設定を確認してください。'); }
  };

  /* --- M2-5: 系統図出力 --- */
  const handleDiagramOutput = () => {
    const html = genDiagramHTML(nodes, allResults, systemMeta);
    const w = window.open('', '_blank');
    if (w) { w.document.write(html); w.document.close(); }
    else { alert('ポップアップがブロックされました。ブラウザの設定を確認してください。'); }
  };

  /* --- レンダリング --- */
  const isMotor = params.circuitType === '電動機';
  const isCustomReduction = params.reductionPreset === 'カスタム';
  const voltageOptions = VOLTAGE_OPTIONS[params.system] || [200];
  const cableTypeOptions = getCableTypeOptions(params.system);
  const capacityLabel = params.unit === 'A' ? '電流 [A]' : `負荷容量 [${params.unit}]`;
  const sliderCfgCapacity = params.unit === 'A' ? SLIDER_CFG.capacity_A
    : params.unit === 'kVA' ? SLIDER_CFG.capacity_kVA : SLIDER_CFG.capacity_kW;
  const isGround = params.wiringMethod === '直埋布設' || params.wiringMethod === '管路布設';
  const tempBase = isGround ? 25 : 40;
  const tempFactor = getTempFactor(params.wiringMethod, params.ambientTemp);

  const isEditing = selectedId != null;
  const canRegister = editMode === 'load' && result && params.trunkName && params.capacity > 0 && params.cableLength > 0;

  return (
    <div style={{ height: '100vh', display: 'flex', flexDirection: 'column' }}>
      {/* ヘッダー (§2) */}
      <header style={{
        background: '#1976d2', color: '#fff', padding: '8px 16px',
        display: 'flex', alignItems: 'center', justifyContent: 'space-between', flexShrink: 0
      }}>
        <h1 style={{ fontSize: 18, fontWeight: 700 }}>低圧幹線ケーブル計算ツール</h1>
        <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
          <input type="file" accept=".json" ref={fileInputRef} style={{ display: 'none' }} onChange={handleImport} />
          <button onClick={() => fileInputRef.current?.click()} style={{
            padding: '4px 12px', borderRadius: 4, border: '1px solid rgba(255,255,255,0.7)',
            background: 'transparent', color: '#fff', cursor: 'pointer', fontSize: 13
          }}>Import</button>
          <button onClick={handleExport} disabled={nodes.length === 0} style={{
            padding: '4px 12px', borderRadius: 4, border: '1px solid rgba(255,255,255,0.7)',
            background: 'transparent', color: '#fff',
            cursor: nodes.length ? 'pointer' : 'not-allowed',
            opacity: nodes.length ? 1 : 0.5, fontSize: 13
          }}>Export</button>
          <button onClick={handlePDF} disabled={nodes.length === 0} style={{
            padding: '4px 12px', borderRadius: 4, border: '1px solid rgba(255,255,255,0.7)',
            background: 'transparent', color: '#fff',
            cursor: nodes.length ? 'pointer' : 'not-allowed',
            opacity: nodes.length ? 1 : 0.5, fontSize: 13
          }}>PDF出力</button>
          <button onClick={handleDiagramOutput} disabled={nodes.length === 0} style={{
            padding: '4px 12px', borderRadius: 4, border: '1px solid rgba(255,255,255,0.7)',
            background: 'transparent', color: '#fff',
            cursor: nodes.length ? 'pointer' : 'not-allowed',
            opacity: nodes.length ? 1 : 0.5, fontSize: 13
          }}>系統図</button>
        </div>
      </header>

      {/* メインコンテンツ (§2) */}
      <div style={{ display: 'flex', flex: 1, overflow: 'hidden' }}>

        {/* 左ペイン: 入力フォーム — 460px固定、独立スクロール */}
        <div style={{
          width: 460, flexShrink: 0, overflowY: 'auto',
          background: '#fff', borderRight: '1px solid #ddd', padding: 16
        }}>

          {/* モード切替タブ (M2-1: 複数変圧器サポート) */}
          <div style={{ display: 'flex', gap: 4, marginBottom: 12, flexWrap: 'wrap' }}>
            <button onClick={() => { setEditMode('transformer'); setSelectedId(null); setTrParams({ ...DEFAULT_TR_PARAMS }); }}
              style={{
                padding: '6px 12px', borderRadius: 4,
                border: editMode === 'transformer' ? '2px solid #1976d2' : '1px solid #ccc',
                background: editMode === 'transformer' ? '#e3f2fd' : '#fff',
                cursor: 'pointer', fontSize: 12, fontWeight: 600
              }}>+ 変圧器</button>
            <button onClick={resetToNewLoad}
              style={{
                padding: '6px 12px', borderRadius: 4,
                border: editMode === 'load' && !isEditing ? '2px solid #1976d2' : '1px solid #ccc',
                background: editMode === 'load' && !isEditing ? '#e3f2fd' : '#fff',
                cursor: 'pointer', fontSize: 12, fontWeight: 600
              }}>+ 負荷回路</button>
          </div>

          {/* === 変圧器フォーム === */}
          {editMode === 'transformer' && (
            <TransformerForm
              trParams={trParams} setTrParams={setTrParams}
              onSave={handleSaveTransformer} onCancel={resetToNewLoad}
              isEdit={isEditing && selectedNode?.type === 'transformer'}
            />
          )}

          {/* === 幹線フォーム === */}
          {editMode === 'trunk' && (
            <TrunkForm
              trunkParams={trunkParams} setTrunkParams={setTrunkParams}
              onSave={handleSaveTrunk} onCancel={resetToNewLoad}
              isEdit={isEditing && selectedNode?.type === 'trunk'}
              childSummary={trunkChildSummary}
            />
          )}

          {/* === 負荷回路フォーム（既存） === */}
          {editMode === 'load' && (
            <div>
              <Sec title="回路情報">
                <RC label="幹線番号/名称">
                  <input type="text" value={params.trunkName} style={{ ...numStyle, textAlign: 'left' }}
                    onChange={e => setParams(p => ({ ...p, trunkName: e.target.value }))} placeholder="例: L-1A" />
                </RC>
                <RC label="負荷名称">
                  <input type="text" value={params.loadName} style={{ ...numStyle, textAlign: 'left' }}
                    onChange={e => setParams(p => ({ ...p, loadName: e.target.value }))} placeholder="例: 空調機" />
                </RC>
                <RC label="電気方式">
                  <select value={params.system} style={selStyle} onChange={e => updateSelect('system', e.target.value)}>
                    {['単相2線式', '単相3線式', '三相3線式', '三相4線式'].map(s => <option key={s}>{s}</option>)}
                  </select>
                </RC>
                <RC label="電圧 [V]">
                  <select value={params.voltage} style={selStyle} onChange={e => updateSelect('voltage', Number(e.target.value))}>
                    {voltageOptions.map(v => <option key={v} value={v}>{params.system === '単相3線式' ? '100/200' : v}</option>)}
                  </select>
                </RC>
                <RC label="周波数">
                  <select value={params.freq} style={selStyle} onChange={e => updateSelect('freq', e.target.value)}>
                    <option>50Hz</option><option>60Hz</option>
                  </select>
                </RC>
                <RC label="供給方式">
                  <select value={params.supplyType} style={selStyle} onChange={e => updateSelect('supplyType', e.target.value)}>
                    <option>低圧受電</option><option>高圧受電</option>
                  </select>
                </RC>
                <RC label="回路種別">
                  <select value={params.circuitType} style={selStyle} onChange={e => updateSelect('circuitType', e.target.value)}>
                    <option>一般</option><option>電動機</option>
                  </select>
                </RC>
                <RC label="MCCB AT">
                  <select value={params.mccbATOverride} style={selStyle} onChange={e => updateSelect('mccbATOverride', e.target.value)}>
                    <option>自動</option>
                    {MCCB_AT.map(at => <option key={at} value={at}>{at} AT</option>)}
                  </select>
                </RC>
              </Sec>

              <Sec title="負荷条件">
                <RC label={capacityLabel}>
                  <div style={{ display: 'flex', gap: 6 }}>
                    <div style={{ flex: 1 }}>
                      <SliderInput value={params.capacity} displayValue={display.capacity}
                        cfg={sliderCfgCapacity} min={0}
                        onChange={v => updateNumLive('capacity', v)} onConfirm={() => confirmNum('capacity')} />
                    </div>
                    <select value={params.unit} style={{ ...selStyle, width: 70, flex: 'none' }}
                      onChange={e => updateSelect('unit', e.target.value)}>
                      <option>kW</option><option>kVA</option><option>A</option>
                    </select>
                  </div>
                </RC>
                <RC label="力率 cosθ">
                  <SliderInput value={params.powerFactor} displayValue={display.powerFactor}
                    cfg={SLIDER_CFG.powerFactor} min={0.10} max={1.00}
                    onChange={v => updateNumLive('powerFactor', v)} onConfirm={() => confirmNum('powerFactor')} />
                </RC>
                <RC label="効率 η" show={isMotor}>
                  <SliderInput value={params.efficiency} displayValue={display.efficiency}
                    cfg={SLIDER_CFG.efficiency} min={0.10} max={1.00}
                    onChange={v => updateNumLive('efficiency', v)} onConfirm={() => confirmNum('efficiency')} />
                </RC>
                <RC label="需要率 [%]">
                  <SliderInput value={params.demandFactor} displayValue={display.demandFactor}
                    cfg={SLIDER_CFG.demandFactor} min={1} max={100}
                    onChange={v => updateNumLive('demandFactor', v)} onConfirm={() => confirmNum('demandFactor')} />
                </RC>
                <RC label="こう長 [m]">
                  <SliderInput value={params.cableLength} displayValue={display.cableLength}
                    cfg={SLIDER_CFG.cableLength} min={0.1}
                    onChange={v => updateNumLive('cableLength', v)} onConfirm={() => confirmNum('cableLength')} />
                </RC>
              </Sec>

              <Sec title="ケーブル条件">
                <RC label="ケーブル種類">
                  <select value={params.cableType} style={selStyle} onChange={e => updateSelect('cableType', e.target.value)}>
                    {cableTypeOptions.map(c => <option key={c}>{c}</option>)}
                  </select>
                </RC>
                <RC label="配線方式">
                  <select value={params.wiringMethod} style={selStyle} onChange={e => updateSelect('wiringMethod', e.target.value)}>
                    {['ケーブルラック配線', '配管配線', '直埋布設', '管路布設'].map(w => <option key={w}>{w}</option>)}
                  </select>
                </RC>
                <RC label="周囲温度 [℃]">
                  <SliderInput value={params.ambientTemp} displayValue={display.ambientTemp}
                    cfg={SLIDER_CFG.ambientTemp} min={20} max={50}
                    onChange={v => updateNumLive('ambientTemp', v)} onConfirm={() => confirmNum('ambientTemp')} />
                  <div style={{ fontSize: 11, color: '#888', marginTop: 2 }}>
                    基底 {tempBase}℃ → 補正係数 {rd(tempFactor, 3)}
                    {isGround ? '（地中）' : '（気中）'}
                  </div>
                </RC>
                <RC label="多条低減プリセット">
                  <select value={params.reductionPreset} style={selStyle}
                    onChange={e => updateSelect('reductionPreset', e.target.value)}>
                    {RED_PRE.map(p => (
                      <option key={p.label} value={p.label}>
                        {p.label}{p.factor !== null ? ` (${p.factor})` : ''}
                      </option>
                    ))}
                  </select>
                </RC>
                <RC label="低減率" show={isCustomReduction}>
                  <SliderInput value={params.reductionFactor} displayValue={display.reductionFactor}
                    cfg={SLIDER_CFG.reductionFactor} min={0.10} max={1.00}
                    onChange={v => updateNumLive('reductionFactor', v)} onConfirm={() => confirmNum('reductionFactor')} />
                </RC>
                {!isCustomReduction && (
                  <RC label="低減率">
                    <span style={{ fontSize: 13, color: '#333' }}>{params.reductionFactor}</span>
                  </RC>
                )}
              </Sec>

              {/* 登録/更新ボタン */}
              {isEditing ? (
                <div style={{ display: 'flex', gap: 8 }}>
                  <button onClick={handleUpdateNode} style={{
                    flex: 1, padding: '10px', borderRadius: 6, border: 'none',
                    background: '#1976d2', color: '#fff', fontSize: 14, fontWeight: 700, cursor: 'pointer'
                  }}>更新</button>
                  <button onClick={resetToNewLoad} style={{
                    padding: '10px 16px', borderRadius: 6, border: '1px solid #ccc',
                    background: '#fff', color: '#666', fontSize: 14, cursor: 'pointer'
                  }}>取消</button>
                </div>
              ) : (
                <button onClick={handleRegisterLoad} disabled={!canRegister} style={{
                  width: '100%', padding: '10px', borderRadius: 6, border: 'none',
                  background: canRegister ? '#4caf50' : '#e0e0e0',
                  color: canRegister ? '#fff' : '#999',
                  fontSize: 14, fontWeight: 700,
                  cursor: canRegister ? 'pointer' : 'not-allowed'
                }}>+ 登録</button>
              )}
            </div>
          )}
        </div>

        {/* 右ペイン: 選定結果 + 登録一覧 / 系統図 */}
        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden', background: '#fafafa' }}>

          {/* M2: ビュー切替タブ */}
          <div style={{ display: 'flex', gap: 0, padding: '8px 16px 0', background: '#fafafa', borderBottom: '1px solid #e0e0e0', flexShrink: 0 }}>
            {[
              { key: 'table', label: 'テーブル' },
              { key: 'diagram', label: '系統図' },
              { key: 'split', label: '分割' }
            ].map(tab => (
              <button key={tab.key} onClick={() => setRightPaneView(tab.key)}
                style={{
                  padding: '6px 16px', fontSize: 12, fontWeight: rightPaneView === tab.key ? 700 : 400,
                  border: 'none', borderBottom: rightPaneView === tab.key ? '2px solid #1976d2' : '2px solid transparent',
                  background: 'transparent', color: rightPaneView === tab.key ? '#1976d2' : '#666',
                  cursor: 'pointer'
                }}>{tab.label}</button>
            ))}
            {/* 系統図表示時: 編集/ビューモード切替 */}
            {(rightPaneView === 'diagram' || rightPaneView === 'split') && (
              <div style={{ marginLeft: 'auto', display: 'flex', gap: 4, alignItems: 'center' }}>
                <button onClick={() => setDiagramMode('edit')}
                  style={{
                    padding: '3px 10px', fontSize: 11, borderRadius: 3,
                    border: diagramMode === 'edit' ? '1px solid #1976d2' : '1px solid #ccc',
                    background: diagramMode === 'edit' ? '#e3f2fd' : '#fff',
                    color: diagramMode === 'edit' ? '#1976d2' : '#666', cursor: 'pointer'
                  }}>編集</button>
                <button onClick={() => setDiagramMode('view')}
                  style={{
                    padding: '3px 10px', fontSize: 11, borderRadius: 3,
                    border: diagramMode === 'view' ? '1px solid #1976d2' : '1px solid #ccc',
                    background: diagramMode === 'view' ? '#e3f2fd' : '#fff',
                    color: diagramMode === 'view' ? '#1976d2' : '#666', cursor: 'pointer'
                  }}>ビュー</button>
              </div>
            )}
          </div>

          {/* テーブルビュー */}
          {(rightPaneView === 'table' || rightPaneView === 'split') && (
            <div style={{
              flex: rightPaneView === 'split' ? '0 0 40%' : 1,
              overflowY: 'auto', padding: 16
            }}>
              {/* 結果パネル（モード別） */}
              {editMode === 'transformer' && (
                <TransformerResultPanel
                  result={isEditing ? selectedResult : trPreview}
                  nodes={nodes} nodeId={selectedId} allResults={allResults}
                />
              )}
              {editMode === 'trunk' && selectedResult && (
                <ResultPanel result={selectedResult} params={selectedNode?.trunk || trunkParams} />
              )}
              {editMode === 'load' && (
                <ResultPanel result={isEditing ? selectedResult : result} params={params} />
              )}

              {/* 登録一覧テーブル */}
              <div style={{
                marginTop: 24, padding: 16, background: '#fff',
                border: '1px solid #e0e0e0', borderRadius: 8
              }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 12 }}>
                  <span style={{ fontSize: 14, fontWeight: 700, color: '#333' }}>登録一覧</span>
                  <span style={{ fontSize: 12, color: '#999' }}>{nodes.length} ノード</span>
                </div>
                <TreeTable
                  nodes={nodes} allResults={allResults} selectedId={selectedId}
                  onSelect={handleSelectNode} onDelete={handleDeleteNode}
                  onAddChild={handleAddChild}
                />
              </div>
            </div>
          )}

          {/* 系統図ビュー */}
          {(rightPaneView === 'diagram' || rightPaneView === 'split') && (
            <div style={{ flex: rightPaneView === 'split' ? '1 1 60%' : 1, borderTop: rightPaneView === 'split' ? '1px solid #e0e0e0' : 'none' }}>
              <DiagramCanvas
                nodes={nodes} allResults={allResults} systemMeta={systemMeta}
                selectedId={selectedId} onSelectNode={handleSelectNode}
                mode={diagramMode} onNodesChange={setNodes}
              />
            </div>
          )}

        </div>

      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
