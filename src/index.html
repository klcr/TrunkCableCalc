<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>低圧幹線ケーブル計算ツール</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; overflow: hidden; }
body {
  font-family: 'Noto Sans JP', 'Hiragino Kaku Gothic ProN', Meiryo, sans-serif;
  font-size: 14px;
  color: #333;
  background: #f5f5f5;
}
@media print {
  body { font-family: 'MS Gothic', 'Hiragino Kaku Gothic ProN', monospace; }
}
</style>
</head>
<body>
<div id="root"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>

<script type="text/babel">
/* === DATA TABLES === */
/* __DATA__ */

/* === TREE UTILITIES === */

function genId() {
  return typeof crypto !== 'undefined' && crypto.randomUUID
    ? crypto.randomUUID()
    : Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
}

function getChildren(nodes, parentId) {
  return nodes.filter(n => n.parentId === parentId).sort((a, b) => a.order - b.order);
}

function getParent(nodes, id) {
  const node = nodes.find(n => n.id === id);
  return node && node.parentId ? nodes.find(n => n.id === node.parentId) : null;
}

function getAncestors(nodes, id) {
  const result = [];
  let cur = nodes.find(n => n.id === id);
  while (cur && cur.parentId) {
    cur = nodes.find(n => n.id === cur.parentId);
    if (cur) result.push(cur);
  }
  return result;
}

function getDepth(nodes, id) {
  let d = 0, cur = nodes.find(n => n.id === id);
  while (cur && cur.parentId) {
    cur = nodes.find(n => n.id === cur.parentId);
    d++;
  }
  return d;
}

function getDescendants(nodes, id) {
  const result = [];
  const stack = getChildren(nodes, id).slice();
  while (stack.length) {
    const n = stack.pop();
    result.push(n);
    stack.push(...getChildren(nodes, n.id));
  }
  return result;
}

/* --- グループユーティリティ (M2-6) --- */

const GROUP_COLORS = ['#e3f2fd', '#e8f5e9', '#fff3e0', '#fce4ec', '#f3e5f5', '#e0f2f1', '#fff8e1', '#e8eaf6'];

function getGroupNodes(nodes, rootNodeId) {
  const root = nodes.find(n => n.id === rootNodeId);
  if (!root) return [];
  return [root, ...getDescendants(nodes, rootNodeId)];
}

function findGroupForNode(groups, nodes, nodeId) {
  return groups.find(g => {
    const members = getGroupNodes(nodes, g.rootNodeId);
    return members.some(n => n.id === nodeId);
  }) || null;
}

function autoCreateGroups(nodes, existingGroups) {
  const roots = nodes.filter(n => !n.parentId);
  const assignedRoots = new Set(existingGroups.map(g => g.rootNodeId));
  const newGroups = [];
  roots.forEach((root, i) => {
    if (!assignedRoots.has(root.id)) {
      const name = root.type === 'transformer'
        ? (root.transformer?.name || 'TR-' + (existingGroups.length + newGroups.length + 1))
        : (root.trunk?.name || 'Group-' + (existingGroups.length + newGroups.length + 1));
      newGroups.push({
        id: genId(), name, color: GROUP_COLORS[(existingGroups.length + newGroups.length) % GROUP_COLORS.length],
        rootNodeId: root.id, canvas: { x: 0, y: 0, collapsed: false }
      });
    }
  });
  return newGroups;
}

function buildTree(nodes) {
  const roots = nodes.filter(n => !n.parentId).sort((a, b) => a.order - b.order);
  const attach = (node) => ({
    ...node,
    children: getChildren(nodes, node.id).map(attach)
  });
  return roots.map(attach);
}

function validateNode(nodes, node) {
  const depth = node.parentId ? getDepth(nodes, node.parentId) + 1 : 0;
  if (depth > 3) return 'depth exceeds 3';
  if (node.type === 'transformer' && depth !== 0) return 'transformer must be root';
  if (node.type === 'trunk' && depth < 1 && nodes.some(n => n.type === 'transformer')) return 'trunk must be under transformer';
  if (node.type === 'load') {
    const parent = node.parentId ? nodes.find(n => n.id === node.parentId) : null;
    if (!parent || parent.type !== 'trunk') return 'load must be under trunk';
  }
  return null;
}

function addNode(nodes, node) {
  const err = validateNode(nodes, node);
  if (err) { console.warn('addNode:', err); return nodes; }
  return [...nodes, node];
}

function updateNode(nodes, id, patch) {
  return nodes.map(n => n.id === id ? { ...n, ...patch, id: n.id, type: n.type, ts: new Date().toISOString() } : n);
}

function removeNode(nodes, id) {
  const descIds = new Set(getDescendants(nodes, id).map(n => n.id));
  descIds.add(id);
  return nodes.filter(n => !descIds.has(n.id));
}

/* --- 経路抽出ユーティリティ (M2-3-P2) --- */

/** 変圧器→末端の全経路を列挙。各経路はルートからリーフまでのノードID配列 */
function enumerateAllPaths(nodes) {
  const paths = [];
  const leaves = nodes.filter(n => getChildren(nodes, n.id).length === 0 && n.type !== 'transformer');
  for (const leaf of leaves) {
    const path = [leaf.id];
    let cur = leaf;
    while (cur.parentId) {
      path.unshift(cur.parentId);
      cur = nodes.find(n => n.id === cur.parentId);
      if (!cur) break;
    }
    if (path.length >= 2) paths.push(path);
  }
  return paths;
}

/** 指定ノードを含む経路を取得（ルート→そのノードまで） */
function getPathToNode(nodes, nodeId) {
  const path = [nodeId];
  let cur = nodes.find(n => n.id === nodeId);
  while (cur && cur.parentId) {
    path.unshift(cur.parentId);
    cur = nodes.find(n => n.id === cur.parentId);
  }
  return path;
}

/** 指定ノードを含む末端までの全経路を列挙 */
function getPathsThroughNode(nodes, nodeId) {
  return enumerateAllPaths(nodes).filter(p => p.includes(nodeId));
}

/* === CALC ENGINE === */

/* --- 定数・ヘルパー --- */
const SIZES_CVT = [8, 14, 22, 38, 60, 100, 150, 200, 250, 325];
const SIZES_CV  = [2, 3.5, 5.5, 8, 14, 22, 38, 60, 100, 150, 200, 250, 325];

function getCableSizes(ct) {
  return (ct === 'CVT' || ct === 'CVD') ? SIZES_CVT : SIZES_CV;
}

function getImpTable(ct) {
  return (ct === 'CVT' || ct === 'CVD') ? IMP_CVT : IMP_CV;
}

function getAmpTable(wm) {
  const m = { 'ケーブルラック配線': A_RACK, '配管配線': A_COND, '直埋布設': A_DIRECT, '管路布設': A_DUCT };
  return m[wm] || A_RACK;
}

/** 基本許容電流を取得。データ未整備の場合は null */
function getBaseAmpacity(ct, wm, sz) {
  const t = getAmpTable(wm)[ct];
  if (!t) return null;
  const i = t.sizes_mm2.indexOf(sz);
  return (i >= 0 && i < t.ampacity.length) ? t.ampacity[i] : null;
}

/** インピーダンス [R, X] を取得 */
function getImpedance(ct, freq, sz) {
  const t = getImpTable(ct);
  return (t[freq] && t[freq][String(sz)]) || null;
}

/** 温度補正係数（線形補間対応） */
function getTempFactor(wm, temp) {
  const env = (wm === '直埋布設' || wm === '管路布設') ? 'ground' : 'air';
  const f = TC[env].factors;
  const ts = Object.keys(f).map(Number).sort((a, b) => a - b);
  if (temp <= ts[0]) return f[ts[0]];
  if (temp >= ts[ts.length - 1]) return f[ts[ts.length - 1]];
  for (let i = 0; i < ts.length - 1; i++) {
    if (temp >= ts[i] && temp <= ts[i + 1]) {
      return f[ts[i]] + (f[ts[i + 1]] - f[ts[i]]) * (temp - ts[i]) / (ts[i + 1] - ts[i]);
    }
  }
  return 1.0;
}

/** 電圧降下の方式係数 K と基準電圧 (§8-4) */
function getVdParams(sys, V) {
  switch (sys) {
    case '単相2線式': return { K: 2, baseV: V };
    case '単相3線式': return { K: 1, baseV: 100 };
    case '三相3線式': return { K: Math.sqrt(3), baseV: V };
    case '三相4線式': return { K: 1, baseV: V / Math.sqrt(3) };
    default: return { K: Math.sqrt(3), baseV: V };
  }
}

/** 許容電圧降下率 [%] (§8-5) */
function getAllowVdP(L, sup) {
  const h = sup === '高圧受電';
  if (L <= 60)  return h ? 3 : 2;
  if (L <= 120) return h ? 5 : 4;
  if (L <= 200) return h ? 6 : 5;
  return h ? 7 : 6;
}

/** MCCB 自動選定 (§8-6) */
function selectMCCB(dI, circuitType) {
  const th = circuitType === '電動機' ? dI * 1.25 : dI;
  for (const at of MCCB_AT) { if (at >= th) return at; }
  return MCCB_AT[MCCB_AT.length - 1];
}

function isThreePhase(sys) {
  return sys === '三相3線式' || sys === '三相4線式';
}

/** 丸めユーティリティ */
function rd(v, n = 2) { const m = Math.pow(10, n); return Math.round(v * m) / m; }

/**
 * runCalc — 子回路のケーブルサイズ選定 (§8)
 *
 * @param {Object} p - 入力パラメータ
 * @returns {Object} 計算結果（ok, size, dI, sizingI, mccbAT, 各判定フラグ等）
 */
function runCalc(p) {
  /* 8-1: 設計電流 */
  const V = p.voltage, PF = p.powerFactor, EFF = p.efficiency;
  const three = isThreePhase(p.system);
  let rawI;
  if (p.unit === 'kW') {
    rawI = three
      ? p.capacity * 1000 / (Math.sqrt(3) * V * PF * EFF)
      : p.capacity * 1000 / (V * PF * EFF);
  } else if (p.unit === 'kVA') {
    rawI = three
      ? p.capacity * 1000 / (Math.sqrt(3) * V)
      : p.capacity * 1000 / V;
  } else {
    rawI = p.capacity;
  }
  const dI = rawI * p.demandFactor / 100;

  /* 8-2: 電動機電流補正 */
  const sizingI = p.circuitType === '電動機'
    ? (dI <= 50 ? dI * 1.25 : dI * 1.1)
    : dI;

  /* 電圧降下パラメータ */
  const { K, baseV } = getVdParams(p.system, V);
  const sinT = Math.sqrt(1 - PF * PF);
  const allowVdP = getAllowVdP(p.cableLength, p.supplyType);

  /* 温度補正 */
  const tF = getTempFactor(p.wiringMethod, p.ambientTemp);

  /* MCCB（ケーブルサイズに依存しないため先に決定） */
  const mccbAT = p.mccbATOverride !== '自動'
    ? Number(p.mccbATOverride)
    : selectMCCB(dI, p.circuitType);

  const sizes = getCableSizes(p.cableType);

  /* 8-3: 3条件走査 — 許容電流→電圧降下→保護協調 */
  for (const sz of sizes) {
    /* Step 1: 許容電流 */
    const bA = getBaseAmpacity(p.cableType, p.wiringMethod, sz);
    if (bA === null) continue;
    const eA = bA * tF * p.reductionFactor;
    if (eA < sizingI) continue;

    /* Step 2: 電圧降下（精密式 R·cosθ + X·sinθ） */
    const imp = getImpedance(p.cableType, p.freq, sz);
    if (!imp) continue;
    const Z = imp[0] * PF + imp[1] * sinT;
    const vd = K * dI * (p.cableLength / 1000) * Z;
    const vdP = baseV > 0 ? vd / baseV * 100 : 0;
    if (vdP > allowVdP) continue;

    /* Step 3: 保護協調 */
    const protOK = p.circuitType === '電動機' ? eA >= mccbAT / 2.5 : eA >= mccbAT;
    if (!protOK) continue;

    return {
      ok: true, size: sz, parallel: 1, dI: rd(dI), sizingI: rd(sizingI), mccbAT,
      baseAmpacity: bA, tempFactor: rd(tF, 3), reductionFactor: p.reductionFactor,
      effectiveAmpacity: rd(eA), Z: rd(Z, 4), K,
      vd: rd(vd), vdPercent: rd(vdP),
      allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
      ampacityOK: true, vdOK: true, protOK: true
    };
  }

  /* 325×2 並列試行 — 単線で全サイズ不適合の場合 */
  {
    const sz2 = 325;
    const bA2 = getBaseAmpacity(p.cableType, p.wiringMethod, sz2);
    const imp2 = getImpedance(p.cableType, p.freq, sz2);
    if (bA2 !== null && imp2) {
      const eA2 = bA2 * 2 * tF * p.reductionFactor;
      const Z2 = (imp2[0] * PF + imp2[1] * sinT) / 2;
      const vd2 = K * dI * (p.cableLength / 1000) * Z2;
      const vdP2 = baseV > 0 ? vd2 / baseV * 100 : 0;
      const protOK2 = p.circuitType === '電動機' ? eA2 >= mccbAT / 2.5 : eA2 >= mccbAT;
      if (eA2 >= sizingI && vdP2 <= allowVdP && protOK2) {
        return {
          ok: true, size: sz2, parallel: 2, dI: rd(dI), sizingI: rd(sizingI), mccbAT,
          baseAmpacity: bA2 * 2, tempFactor: rd(tF, 3), reductionFactor: p.reductionFactor,
          effectiveAmpacity: rd(eA2), Z: rd(Z2, 4), K,
          vd: rd(vd2), vdPercent: rd(vdP2),
          allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
          ampacityOK: true, vdOK: true, protOK: true
        };
      }
      /* 325×2 でも不適合 — NG 結果を返す */
      return {
        ok: false, size: sz2, parallel: 2, dI: rd(dI), sizingI: rd(sizingI), mccbAT,
        baseAmpacity: bA2 * 2, tempFactor: rd(tF, 3), reductionFactor: p.reductionFactor,
        effectiveAmpacity: rd(eA2), Z: rd(Z2, 4), K,
        vd: rd(vd2), vdPercent: rd(vdP2),
        allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
        ampacityOK: eA2 >= sizingI, vdOK: vdP2 <= allowVdP,
        protOK: p.circuitType === '電動機' ? eA2 >= mccbAT / 2.5 : eA2 >= mccbAT
      };
    }
  }

  /* 全サイズ不適合（325データなし） — 最大サイズで NG 結果を返す */
  const sz = sizes[sizes.length - 1];
  const bA = getBaseAmpacity(p.cableType, p.wiringMethod, sz);
  const eA = bA !== null ? bA * tF * p.reductionFactor : 0;
  const imp = getImpedance(p.cableType, p.freq, sz);
  const Z = imp ? imp[0] * PF + imp[1] * sinT : 0;
  const vd = K * dI * (p.cableLength / 1000) * Z;
  const vdP = baseV > 0 ? vd / baseV * 100 : 0;

  return {
    ok: false, size: sz, parallel: 1, dI: rd(dI), sizingI: rd(sizingI), mccbAT,
    baseAmpacity: bA || 0, tempFactor: rd(tF, 3), reductionFactor: p.reductionFactor,
    effectiveAmpacity: rd(eA), Z: rd(Z, 4), K,
    vd: rd(vd), vdPercent: rd(vdP),
    allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
    ampacityOK: eA >= sizingI, vdOK: vdP <= allowVdP,
    protOK: p.circuitType === '電動機' ? eA >= mccbAT / 2.5 : eA >= mccbAT
  };
}

/**
 * runParentCalc — 親幹線のケーブルサイズ選定 (§9)
 *
 * @param {Array} children - 子回路の配列 [{ params, result }, ...]
 * @param {Object} cfg - 親幹線設定（cableLength, powerFactor, cableType, wiringMethod, ambientTemp, reductionFactor, mccbATOverride）
 * @returns {Object|null} 計算結果。children が空なら null
 */
function runParentCalc(children, cfg) {
  if (!children || children.length === 0) return null;

  /* 子回路の電気方式等を継承 */
  const first = children[0].params;
  const sys = first.system, V = first.voltage, freq = first.freq, sup = first.supplyType;

  /* 9-3: 設計電流の分類集計 */
  let sumIM = 0, sumIH = 0, hasMotor = false;
  for (const c of children) {
    if (c.params.circuitType === '電動機') { sumIM += c.result.dI; hasMotor = true; }
    else sumIH += c.result.dI;
  }
  const totalI = sumIM + sumIH;
  const sizingI = hasMotor
    ? (sumIM <= 50 ? sumIM * 1.25 + sumIH : sumIM * 1.1 + sumIH)
    : totalI;

  const PF = cfg.powerFactor;
  const { K, baseV } = getVdParams(sys, V);
  const sinT = Math.sqrt(1 - PF * PF);
  const allowVdP = getAllowVdP(cfg.cableLength, sup);
  const tF = getTempFactor(cfg.wiringMethod, cfg.ambientTemp);

  /* 9-4: MCCB */
  const mccbTh = hasMotor ? totalI * 1.25 : totalI;
  const mccbAT = cfg.mccbATOverride !== '自動'
    ? Number(cfg.mccbATOverride)
    : (() => { for (const at of MCCB_AT) { if (at >= mccbTh) return at; } return MCCB_AT[MCCB_AT.length - 1]; })();

  const sizes = getCableSizes(cfg.cableType);

  /* ケーブルサイズ走査 */
  for (const sz of sizes) {
    const bA = getBaseAmpacity(cfg.cableType, cfg.wiringMethod, sz);
    if (bA === null) continue;
    const eA = bA * tF * cfg.reductionFactor;
    if (eA < sizingI) continue;

    const imp = getImpedance(cfg.cableType, freq, sz);
    if (!imp) continue;
    const Z = imp[0] * PF + imp[1] * sinT;
    const vd = K * totalI * (cfg.cableLength / 1000) * Z;
    const vdP = baseV > 0 ? vd / baseV * 100 : 0;
    if (vdP > allowVdP) continue;

    /* 9-5: 保護協調 */
    const protOK = hasMotor ? eA >= mccbAT / 2.5 : eA >= mccbAT;
    if (!protOK) continue;

    return {
      ok: true, size: sz, parallel: 1, totalI: rd(totalI), sumIM: rd(sumIM), sumIH: rd(sumIH),
      hasMotor, sizingI: rd(sizingI), mccbAT,
      baseAmpacity: bA, tempFactor: rd(tF, 3), reductionFactor: cfg.reductionFactor,
      effectiveAmpacity: rd(eA), Z: rd(Z, 4), K,
      vd: rd(vd), vdPercent: rd(vdP),
      allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
      ampacityOK: true, vdOK: true, protOK: true
    };
  }

  /* 325×2 並列試行 */
  {
    const sz2 = 325;
    const bA2 = getBaseAmpacity(cfg.cableType, cfg.wiringMethod, sz2);
    const imp2 = getImpedance(cfg.cableType, freq, sz2);
    if (bA2 !== null && imp2) {
      const eA2 = bA2 * 2 * tF * cfg.reductionFactor;
      const Z2 = (imp2[0] * PF + imp2[1] * sinT) / 2;
      const vd2 = K * totalI * (cfg.cableLength / 1000) * Z2;
      const vdP2 = baseV > 0 ? vd2 / baseV * 100 : 0;
      const protOK2 = hasMotor ? eA2 >= mccbAT / 2.5 : eA2 >= mccbAT;
      if (eA2 >= sizingI && vdP2 <= allowVdP && protOK2) {
        return {
          ok: true, size: sz2, parallel: 2, totalI: rd(totalI), sumIM: rd(sumIM), sumIH: rd(sumIH),
          hasMotor, sizingI: rd(sizingI), mccbAT,
          baseAmpacity: bA2 * 2, tempFactor: rd(tF, 3), reductionFactor: cfg.reductionFactor,
          effectiveAmpacity: rd(eA2), Z: rd(Z2, 4), K,
          vd: rd(vd2), vdPercent: rd(vdP2),
          allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
          ampacityOK: true, vdOK: true, protOK: true
        };
      }
      return {
        ok: false, size: sz2, parallel: 2, totalI: rd(totalI), sumIM: rd(sumIM), sumIH: rd(sumIH),
        hasMotor, sizingI: rd(sizingI), mccbAT,
        baseAmpacity: bA2 * 2, tempFactor: rd(tF, 3), reductionFactor: cfg.reductionFactor,
        effectiveAmpacity: rd(eA2), Z: rd(Z2, 4), K,
        vd: rd(vd2), vdPercent: rd(vdP2),
        allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
        ampacityOK: eA2 >= sizingI, vdOK: vdP2 <= allowVdP,
        protOK: hasMotor ? eA2 >= mccbAT / 2.5 : eA2 >= mccbAT
      };
    }
  }

  /* 全サイズ不適合（325データなし） */
  const sz = sizes[sizes.length - 1];
  const bA = getBaseAmpacity(cfg.cableType, cfg.wiringMethod, sz);
  const eA = bA !== null ? bA * tF * cfg.reductionFactor : 0;
  const imp = getImpedance(cfg.cableType, freq, sz);
  const Z = imp ? imp[0] * PF + imp[1] * sinT : 0;
  const vd = K * totalI * (cfg.cableLength / 1000) * Z;
  const vdP = baseV > 0 ? vd / baseV * 100 : 0;

  return {
    ok: false, size: sz, parallel: 1, totalI: rd(totalI), sumIM: rd(sumIM), sumIH: rd(sumIH),
    hasMotor, sizingI: rd(sizingI), mccbAT,
    baseAmpacity: bA || 0, tempFactor: rd(tF, 3), reductionFactor: cfg.reductionFactor,
    effectiveAmpacity: rd(eA), Z: rd(Z, 4), K,
    vd: rd(vd), vdPercent: rd(vdP),
    allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
    ampacityOK: eA >= sizingI, vdOK: vdP <= allowVdP,
    protOK: hasMotor ? eA >= mccbAT / 2.5 : eA >= mccbAT
  };
}

/**
 * calcTransformer — 変圧器ノードの計算 (§19-3)
 */
function calcTransformer(tr) {
  const S = tr.capacity_kVA * 1000;
  const Vs = tr.secondaryV;
  const threePhase = tr.trType !== '単相油入';
  let Rs, Xs;
  if (tr.xrRatio != null && tr.xrRatio > 0) {
    const pctR = tr.pctZ / Math.sqrt(1 + tr.xrRatio * tr.xrRatio);
    const pctX = pctR * tr.xrRatio;
    Rs = (pctR / 100) * Vs * Vs / S;
    Xs = (pctX / 100) * Vs * Vs / S;
  } else {
    Rs = (tr.pctZ / 100) * Vs * Vs / S;
    Xs = 0;
  }
  const Zs = Math.sqrt(Rs * Rs + Xs * Xs);
  const In = threePhase ? S / (Math.sqrt(3) * Vs) : S / Vs;
  const Isc3 = threePhase ? Vs / (Math.sqrt(3) * Zs) : Vs / Zs;
  return { Rs, Xs, Zs, In, Isc3, pctZ: tr.pctZ, capacity_kVA: tr.capacity_kVA, threePhase };
}

/**
 * aggregateCurrents — ボトムアップ電流合算 (§9-3)
 */
function aggregateCurrents(nodes, trunkId, allResults) {
  const children = getChildren(nodes, trunkId);
  let sumIM = 0, sumIH = 0;
  for (const child of children) {
    if (child.type === 'trunk') {
      const sub = aggregateCurrents(nodes, child.id, allResults);
      sumIM += sub.sumIM;
      sumIH += sub.sumIH;
    } else if (child.type === 'load') {
      const r = allResults[child.id];
      if (!r) continue;
      if (child.load.circuitType === '電動機') sumIM += r.dI;
      else sumIH += r.dI;
    }
  }
  return { sumIM, sumIH, totalI: sumIM + sumIH, hasMotor: sumIM > 0 };
}

/**
 * runTrunkCalc — 幹線ノードのケーブルサイズ選定
 */
function runTrunkCalc(trunk, agg) {
  const { sumIM, sumIH, totalI, hasMotor } = agg;
  if (totalI === 0) return null;

  const sys = trunk.system, V = trunk.voltage, freq = trunk.freq, sup = trunk.supplyType;
  const PF = trunk.powerFactor;
  const sizingI = hasMotor
    ? (sumIM <= 50 ? sumIM * 1.25 + sumIH : sumIM * 1.1 + sumIH)
    : totalI;

  const { K, baseV } = getVdParams(sys, V);
  const sinT = Math.sqrt(1 - PF * PF);
  const allowVdP = getAllowVdP(trunk.cableLength, sup);
  const tF = getTempFactor(trunk.wiringMethod, trunk.ambientTemp);

  const mccbTh = hasMotor ? totalI * 1.25 : totalI;
  const mccbAT = trunk.mccbATOverride !== '自動'
    ? Number(trunk.mccbATOverride)
    : (() => { for (const at of MCCB_AT) { if (at >= mccbTh) return at; } return MCCB_AT[MCCB_AT.length - 1]; })();

  const sizes = getCableSizes(trunk.cableType);

  for (const sz of sizes) {
    const bA = getBaseAmpacity(trunk.cableType, trunk.wiringMethod, sz);
    if (bA === null) continue;
    const eA = bA * tF * trunk.reductionFactor;
    if (eA < sizingI) continue;

    const imp = getImpedance(trunk.cableType, freq, sz);
    if (!imp) continue;
    const Z = imp[0] * PF + imp[1] * sinT;
    const vd = K * totalI * (trunk.cableLength / 1000) * Z;
    const vdP = baseV > 0 ? vd / baseV * 100 : 0;
    if (vdP > allowVdP) continue;

    const protOK = hasMotor ? eA >= mccbAT / 2.5 : eA >= mccbAT;
    if (!protOK) continue;

    return {
      ok: true, size: sz, parallel: 1, dI: rd(totalI), totalI: rd(totalI),
      sumIM: rd(sumIM), sumIH: rd(sumIH), hasMotor, sizingI: rd(sizingI), mccbAT,
      baseAmpacity: bA, tempFactor: rd(tF, 3), reductionFactor: trunk.reductionFactor,
      effectiveAmpacity: rd(eA), Z: rd(Z, 4), K,
      vd: rd(vd), vdPercent: rd(vdP),
      allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
      ampacityOK: true, vdOK: true, protOK: true, baseV
    };
  }

  /* 325×2 並列試行 */
  {
    const sz2 = 325;
    const bA2 = getBaseAmpacity(trunk.cableType, trunk.wiringMethod, sz2);
    const imp2 = getImpedance(trunk.cableType, freq, sz2);
    if (bA2 !== null && imp2) {
      const eA2 = bA2 * 2 * tF * trunk.reductionFactor;
      const Z2 = (imp2[0] * PF + imp2[1] * sinT) / 2;
      const vd2 = K * totalI * (trunk.cableLength / 1000) * Z2;
      const vdP2 = baseV > 0 ? vd2 / baseV * 100 : 0;
      const protOK2 = hasMotor ? eA2 >= mccbAT / 2.5 : eA2 >= mccbAT;
      if (eA2 >= sizingI && vdP2 <= allowVdP && protOK2) {
        return {
          ok: true, size: sz2, parallel: 2, dI: rd(totalI), totalI: rd(totalI),
          sumIM: rd(sumIM), sumIH: rd(sumIH), hasMotor, sizingI: rd(sizingI), mccbAT,
          baseAmpacity: bA2 * 2, tempFactor: rd(tF, 3), reductionFactor: trunk.reductionFactor,
          effectiveAmpacity: rd(eA2), Z: rd(Z2, 4), K,
          vd: rd(vd2), vdPercent: rd(vdP2),
          allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
          ampacityOK: true, vdOK: true, protOK: true, baseV
        };
      }
      return {
        ok: false, size: sz2, parallel: 2, dI: rd(totalI), totalI: rd(totalI),
        sumIM: rd(sumIM), sumIH: rd(sumIH), hasMotor, sizingI: rd(sizingI), mccbAT,
        baseAmpacity: bA2 * 2, tempFactor: rd(tF, 3), reductionFactor: trunk.reductionFactor,
        effectiveAmpacity: rd(eA2), Z: rd(Z2, 4), K,
        vd: rd(vd2), vdPercent: rd(vdP2),
        allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
        ampacityOK: eA2 >= sizingI, vdOK: vdP2 <= allowVdP,
        protOK: hasMotor ? eA2 >= mccbAT / 2.5 : eA2 >= mccbAT, baseV
      };
    }
  }

  /* 全サイズ不適合（325データなし） */
  const sz = sizes[sizes.length - 1];
  const bA = getBaseAmpacity(trunk.cableType, trunk.wiringMethod, sz);
  const eA = bA !== null ? bA * tF * trunk.reductionFactor : 0;
  const imp = getImpedance(trunk.cableType, freq, sz);
  const Z = imp ? imp[0] * PF + imp[1] * sinT : 0;
  const vd = K * totalI * (trunk.cableLength / 1000) * Z;
  const vdP = baseV > 0 ? vd / baseV * 100 : 0;

  return {
    ok: false, size: sz, parallel: 1, dI: rd(totalI), totalI: rd(totalI),
    sumIM: rd(sumIM), sumIH: rd(sumIH), hasMotor, sizingI: rd(sizingI), mccbAT,
    baseAmpacity: bA || 0, tempFactor: rd(tF, 3), reductionFactor: trunk.reductionFactor,
    effectiveAmpacity: rd(eA), Z: rd(Z, 4), K,
    vd: rd(vd), vdPercent: rd(vdP),
    allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
    ampacityOK: eA >= sizingI, vdOK: vdP <= allowVdP,
    protOK: hasMotor ? eA >= mccbAT / 2.5 : eA >= mccbAT, baseV
  };
}

/**
 * calcCumulativeVd — トップダウン累積電圧降下 (§20-3)
 */
function calcCumulativeVd(nodes, nodeId, parentCumVd, allResults) {
  const r = allResults[nodeId];
  const cumVd = parentCumVd + (r && r.vd ? r.vd : 0);
  if (r) {
    r.cumulativeVd = rd(cumVd);
    const bV = r.baseV || (r.allowVdPercent && r.allowVd ? r.allowVd / r.allowVdPercent * 100 : 0);
    r.cumulativeVdP = bV > 0 ? rd(cumVd / bV * 100) : 0;
  }
  for (const child of getChildren(nodes, nodeId)) {
    calcCumulativeVd(nodes, child.id, cumVd, allResults);
  }
}

/**
 * calcFaultCurrents — トップダウン R+jX ベクトル累積による短絡電流計算 (§20-2, §20-3)
 */
function calcFaultCurrents(nodes, allResults) {
  /* M2-1: 複数変圧器対応 — 全 transformer ノードをループ */
  const transformers = nodes.filter(n => n.type === 'transformer');
  for (const tr of transformers) {
    const trR = allResults[tr.id];
    if (!trR) continue;
    /* M2-2: HV cable impedance LV conversion (§20-2) */
    const hv = tr.transformer.hvSystem;
    let Rsrc = trR.Rs, Xsrc = trR.Xs;
    if (hv && hv.cableType && hv.cableSize_mm2 && hv.totalCableLength_km) {
      const freq = tr.transformer.freq || '60Hz';
      const hvTable = IMP_HV[hv.cableType];
      const hvImp = hvTable && hvTable[freq] && hvTable[freq][String(hv.cableSize_mm2)];
      if (hvImp) {
        const ratio = Math.pow(tr.transformer.secondaryV / tr.transformer.primaryV, 2);
        Rsrc += hvImp[0] * hv.totalCableLength_km * ratio;
        Xsrc += hvImp[1] * hv.totalCableLength_km * ratio;
      }
    }
    propagateFault(nodes, tr.id, Rsrc, Xsrc, tr.transformer.secondaryV, allResults);
  }
}

function propagateFault(nodes, nodeId, Rcum, Xcum, Vs, allResults) {
  const r = allResults[nodeId];
  if (r) {
    r.Rcum = Rcum;
    r.Xcum = Xcum;
    r.Zcum = Math.sqrt(Rcum * Rcum + Xcum * Xcum);
    r.Isc3 = Vs / (Math.sqrt(3) * r.Zcum);
  }
  for (const child of getChildren(nodes, nodeId)) {
    let Rc = 0, Xc = 0;
    if (child.type === 'trunk' || child.type === 'load') {
      const cfg = child.type === 'trunk' ? child.trunk : child.load;
      const childR = allResults[child.id];
      if (childR && childR.size) {
        const imp = getImpedance(cfg.cableType, cfg.freq, childR.size);
        if (imp) {
          const Lkm = cfg.cableLength / 1000;
          const par = childR.parallel || 1;
          Rc = imp[0] * Lkm / par;
          Xc = imp[1] * Lkm / par;
        }
      }
    }
    propagateFault(nodes, child.id, Rcum + Rc, Xcum + Xc, Vs, allResults);
  }
}

/**
 * checkWithstand — 短時間耐電流検証 (§20-6)
 */
function checkWithstand(size_mm2, Isc3, t, parallel) {
  t = t || 0.1;
  parallel = parallel || 1;
  const K = 134; /* Cu_XLPE: WITHSTAND.K_constants.Cu_XLPE.K */
  const Iw = K * size_mm2 * parallel / Math.sqrt(t);
  return { ok: Isc3 <= Iw, Iwithstand: rd(Iw), Isc3: rd(Isc3), K, t };
}

/**
 * getFrame — MCCB 定格電流からフレームサイズを逆引き (§20-4a)
 */
function getFrame(at) {
  for (const [frame, info] of Object.entries(MCCB_ICU.frames)) {
    if (info.ratings_AT.includes(at)) return frame;
  }
  return null;
}

/**
 * getIcu — MCCB 遮断容量 [kA] を取得 (§20-4a)
 */
function getIcu(at, voltage, icuClass) {
  const frame = getFrame(at);
  if (!frame) return null;
  const vKey = voltage <= 230 ? '230V' : '415V';
  const entry = MCCB_ICU.icu_kA[frame];
  if (!entry || !entry[vKey]) return null;
  return entry[vKey][icuClass] || entry[vKey]['standard'] || null;
}

/**
 * calcGroundFaultCurrent — HV 側一線地絡電流 Ig = 3ωCV (§20-5)
 */
function calcGroundFaultCurrent(tr) {
  const hv = tr.transformer.hvSystem;
  if (!hv || !hv.capacitance_uF_per_km || !hv.totalCableLength_km) return null;
  const f = (tr.transformer.freq || '60Hz') === '50Hz' ? 50 : 60;
  const omega = 2 * Math.PI * f;
  const C_total = hv.capacitance_uF_per_km * hv.totalCableLength_km * 1e-6;
  const V = tr.transformer.primaryV;
  return 3 * omega * C_total * (V / Math.sqrt(3));
}

/**
 * calcGroundingResistance — B種接地抵抗上限 (電技解釈第17条)
 */
function calcGroundingResistance(Ig, vcbTripTime_s) {
  if (!Ig || Ig <= 0) return null;
  return {
    Ig: rd(Ig, 2),
    Rb_05s: rd(150 / Ig, 1),
    Rb_1s: rd(600 / Ig, 1),
    Rb_2s: rd(300 / Ig, 1),
    vcbTripTime_s
  };
}

/**
 * findAncestorTransformer — ノードの祖先変圧器を取得
 */
function findAncestorTransformer(nodes, nodeId) {
  let current = nodes.find(n => n.id === nodeId);
  while (current) {
    if (current.type === 'transformer') return current;
    current = current.parentId ? nodes.find(n => n.id === current.parentId) : null;
  }
  return null;
}

/**
 * calcLVGroundFault — LV 側地絡電流（対称座標法 §20-7）
 */
function calcLVGroundFault(node, allResults, nodes) {
  const r = allResults[node.id];
  if (!r || r.Rcum == null || r.Xcum == null) return null;

  const Z1_R = r.Rcum;
  const Z1_X = r.Xcum;

  const cfg = node.type === 'load' ? node.load : node.trunk;
  const cableType = cfg?.cableType || 'CVT';
  const isThreeCore = cableType === 'CV-3C' || cableType === 'CV-2C';
  const zeroRatio = isThreeCore ? Z_ZERO.cable_ratios.three_core : Z_ZERO.cable_ratios.single_core;

  const Z0_R = Z1_R * zeroRatio.R0_R1;
  const Z0_X = Z1_X * (zeroRatio.X0_X1_typical || zeroRatio.X0_X1 || 4.0);

  const tr = findAncestorTransformer(nodes, node.id);
  if (!tr) return null;
  const connection = tr.transformer.connection || 'Δ-Y';
  const connMap = { 'Δ-Y': 'Dyn', 'Y-Y': 'Yyn', 'Δ-Δ': 'Dd', 'Y-Δ': 'Dd', 'V-V': 'Dyn' };
  const connKey = connMap[connection] || 'Dyn';
  const winding = Z_ZERO.transformer_winding_multipliers[connKey];
  if (!winding || winding.factor == null) return null;

  const trR = allResults[tr.id];
  if (!trR) return null;
  const ZT_R = trR.Rs * winding.factor;
  const ZT_X = trR.Xs * winding.factor;

  const Z0_total_R = Z0_R + ZT_R;
  const Z0_total_X = Z0_X + ZT_X;

  const Vs = cfg?.voltage || 210;
  const Ea = Vs / Math.sqrt(3);
  const Ztotal_R = 2 * Z1_R + Z0_total_R;
  const Ztotal_X = 2 * Z1_X + Z0_total_X;
  const Ztotal = Math.sqrt(Ztotal_R * Ztotal_R + Ztotal_X * Ztotal_X);
  if (Ztotal === 0) return null;
  const Ig_lv = 3 * Ea / Ztotal;

  return { Ig_lv: rd(Ig_lv), Z1: rd(Math.sqrt(Z1_R * Z1_R + Z1_X * Z1_X), 4), Z0: rd(Math.sqrt(Z0_total_R * Z0_total_R + Z0_total_X * Z0_total_X), 4) };
}

/**
 * checkELCB — ELCB 保護協調チェック (§20-8)
 */
function checkELCB(loadParams, Ig_lv) {
  if (!loadParams.hasELCB) return null;
  const IΔn = loadParams.elcbSensitivity_mA / 1000;

  if (loadParams.groundingMethod === 'TT') {
    const RA = loadParams.groundResistance_ohm || 100;
    const touchV = RA * IΔn;
    return {
      ok: touchV <= 50,
      touchV: rd(touchV, 1),
      RA, IΔn_mA: loadParams.elcbSensitivity_mA,
      method: 'TT',
      formula: 'RA × IΔn = ' + RA + ' × ' + IΔn + ' = ' + rd(touchV, 1) + ' V'
    };
  }

  if (loadParams.groundingMethod === 'TN' && Ig_lv) {
    return {
      ok: true,
      method: 'TN',
      Ig_lv: rd(Ig_lv),
      IΔn_mA: loadParams.elcbSensitivity_mA
    };
  }

  return null;
}

/**
 * calculateAll — 全ノード一括計算
 */
function calculateAll(nodes) {
  const results = {};

  /* 1. ボトムアップ: 全 load ノードを計算 */
  for (const n of nodes) {
    if (n.type === 'load') results[n.id] = runCalc(n.load);
  }

  /* 2. ボトムアップ: trunk ノードを深い順に計算 */
  const trunks = nodes.filter(n => n.type === 'trunk')
    .map(n => ({ node: n, depth: getDepth(nodes, n.id) }))
    .sort((a, b) => b.depth - a.depth);
  for (const { node } of trunks) {
    const agg = aggregateCurrents(nodes, node.id, results);
    const r = runTrunkCalc(node.trunk, agg);
    if (r) results[node.id] = r;
  }

  /* 3. transformer ノード */
  for (const n of nodes) {
    if (n.type === 'transformer') results[n.id] = calcTransformer(n.transformer);
  }

  /* 4. トップダウン: 累積電圧降下 */
  const roots = nodes.filter(n => !n.parentId);
  for (const root of roots) {
    calcCumulativeVd(nodes, root.id, 0, results);
  }

  /* 5. トップダウン: 短絡電流 */
  calcFaultCurrents(nodes, results);

  /* 6. 遮断容量チェック (§20-4a) */
  for (const n of nodes) {
    const r = results[n.id];
    if (!r || r.Isc3 == null) continue;
    const cfg = n.type === 'load' ? n.load : n.type === 'trunk' ? n.trunk : null;
    if (!cfg) continue;
    const icuKA = getIcu(r.mccbAT, cfg.voltage || 210, cfg.icuClass || 'standard');
    if (icuKA != null) {
      r.icuKA = icuKA;
      r.icuOK = icuKA * 1000 >= r.Isc3;
    }
  }

  /* 7. HV 側一線地絡電流・B種接地 (§20-5) */
  for (const n of nodes) {
    if (n.type !== 'transformer') continue;
    const r = results[n.id];
    if (!r) continue;
    const Ig = calcGroundFaultCurrent(n);
    if (Ig != null) {
      const vcbTime = n.transformer.hvSystem?.vcbTripTime_s || 1.0;
      r.groundFault = calcGroundingResistance(Ig, vcbTime);
    }
  }

  /* 8. ELCB 保護協調 + LV 側地絡電流 (§20-7, §20-8) */
  for (const n of nodes) {
    if (n.type !== 'load') continue;
    const r = results[n.id];
    if (!r) continue;
    if (n.load.hasELCB) {
      const gf = calcLVGroundFault(n, results, nodes);
      if (gf) r.lvGroundFault = gf;
      r.elcbCheck = checkELCB(n.load, gf?.Ig_lv);
    }
  }

  /* 9. 電気方式/電圧の親子不一致チェック */
  for (const n of nodes) {
    const r = results[n.id];
    if (!r) continue;
    if (!n.parentId) continue;
    const parent = nodes.find(p => p.id === n.parentId);
    if (!parent) continue;

    if (n.type === 'load' && parent.type === 'trunk') {
      if (n.load.system !== parent.trunk.system || n.load.voltage !== parent.trunk.voltage) {
        r.systemMismatch = true;
        r.systemMismatchDetail = '子: ' + n.load.system + ' ' + n.load.voltage + 'V \u2260 親: ' + parent.trunk.system + ' ' + parent.trunk.voltage + 'V';
        r.ok = false;
      }
    }
    if (n.type === 'trunk' && parent.type === 'trunk') {
      if (n.trunk.system !== parent.trunk.system || n.trunk.voltage !== parent.trunk.voltage) {
        r.systemMismatch = true;
        r.systemMismatchDetail = '子: ' + n.trunk.system + ' ' + n.trunk.voltage + 'V \u2260 親: ' + parent.trunk.system + ' ' + parent.trunk.voltage + 'V';
        r.ok = false;
      }
    }
    if (n.type === 'trunk' && parent.type === 'transformer') {
      if (n.trunk.voltage !== parent.transformer.secondaryV) {
        r.systemMismatch = true;
        r.systemMismatchDetail = '幹線: ' + n.trunk.voltage + 'V \u2260 TR二次: ' + parent.transformer.secondaryV + 'V';
        r.ok = false;
      }
    }
  }

  return results;
}

/* === DIAGRAM: DIRECTION FRAMEWORK (M2-4-7) === */

const DIRECTIONS = {
  horizontal: {
    mainAxis: 'x', crossAxis: 'y',
    inPort: 'left', outPort: 'right',
    label: '横型（左→右）'
  },
  vertical: {
    mainAxis: 'y', crossAxis: 'x',
    inPort: 'top', outPort: 'bottom',
    label: '縦型（上→下）'
  }
};

/* モジュールサイズ定数 */
const MOD = {
  TR_W: 200, TR_H: 80,
  TRUNK_W: 260, TRUNK_H: 64,
  LOAD_W: 220, LOAD_H: 56,
  RECV_W: 100, RECV_H: 50,
  PORT_R: 5,
  GAP_MAIN: 120,    /* 主軸方向（左→右）の間隔 */
  GAP_CROSS: 20,    /* 交差軸方向（上→下）の兄弟間隔 */
  MARGIN: 40
};

/* === DIAGRAM: SYMBOLS (M2-4-3) === */

function SvgTransformer({ x, y, w, h, connection }) {
  const r = Math.min(w, h) * 0.22;
  const cx = x + w / 2, cy = y + h / 2;
  const [pri, sec] = (connection || 'Δ-Y').split('-');
  return (
    <g>
      <rect x={x} y={y} width={w} height={h} rx={4} fill="#f3e5f5" stroke="#7b1fa2" strokeWidth={1.5} />
      <circle cx={cx - r * 0.5} cy={cy} r={r} fill="none" stroke="#333" strokeWidth={1.5} />
      <circle cx={cx + r * 0.5} cy={cy} r={r} fill="none" stroke="#333" strokeWidth={1.5} />
      <text x={cx - r * 0.5} y={cy - r - 4} fontSize={9} textAnchor="middle" fill="#555">{pri}</text>
      <text x={cx + r * 0.5} y={cy - r - 4} fontSize={9} textAnchor="middle" fill="#555">{sec}</text>
    </g>
  );
}

function SvgMCCB({ x, y, w, h }) {
  w = w || 20; h = h || 14;
  return (
    <g>
      <rect x={x - w / 2} y={y - h / 2} width={w} height={h} fill="#fff" stroke="#333" strokeWidth={1.2} />
      <line x1={x - w / 4} y1={y - h / 2} x2={x + w / 4} y2={y + h / 2} stroke="#333" strokeWidth={1.2} />
    </g>
  );
}

function SvgMotor({ x, y, r }) {
  r = r || 12;
  return (
    <g>
      <circle cx={x} cy={y} r={r} fill="#e3f2fd" stroke="#1565c0" strokeWidth={1.5} />
      <text x={x} y={y + 4} fontSize={10} textAnchor="middle" fontWeight={700} fill="#1565c0">M</text>
    </g>
  );
}

function SvgLoad({ x, y, r }) {
  r = r || 12;
  return (
    <g>
      <polygon points={`${x},${y - r} ${x + r},${y + r * 0.6} ${x - r},${y + r * 0.6}`}
        fill="#fff3e0" stroke="#e65100" strokeWidth={1.5} />
    </g>
  );
}

function SvgBusBar({ x, y, width }) {
  return <rect x={x} y={y - 2} width={width} height={4} fill="#333" rx={1} />;
}

function SvgPort({ x, y, active, onMouseDown, type }) {
  return (
    <circle cx={x} cy={y} r={MOD.PORT_R}
      fill={active ? '#1976d2' : '#fff'} stroke={active ? '#1976d2' : '#999'} strokeWidth={1.5}
      style={{ cursor: 'crosshair' }}
      onMouseDown={onMouseDown}
      data-port-type={type}
    />
  );
}

function SvgVCB({ x, y }) {
  const r = 8;
  return (
    <g>
      <circle cx={x} cy={y} r={r} fill="#fff" stroke="#333" strokeWidth={1.5} />
      <line x1={x - 4} y1={y - 4} x2={x + 4} y2={y + 4} stroke="#333" strokeWidth={1.2} />
      <line x1={x + 4} y1={y - 4} x2={x - 4} y2={y + 4} stroke="#333" strokeWidth={1.2} />
    </g>
  );
}

/* === DIAGRAM: COLLAPSED GROUP MODULE (M2-6 G5) === */

function ModuleGroupCollapsed({ group, nodes, allResults, canvas, onClick }) {
  const x = canvas.x, y = canvas.y, w = 160, h = 70;
  const memberNodes = getGroupNodes(nodes, group.rootNodeId);
  const trNode = memberNodes.find(n => n.type === 'transformer');
  const trunkCount = memberNodes.filter(n => n.type === 'trunk').length;
  const loadCount = memberNodes.filter(n => n.type === 'load').length;
  const allOk = memberNodes.every(n => { const r = allResults[n.id]; return !r || r.ok == null || r.ok; });
  const borderColor = group.color === '#e3f2fd' ? '#1976d2' : group.color === '#e8f5e9' ? '#4caf50' : '#ff9800';

  return (
    <g style={{ cursor: 'pointer' }} onClick={onClick}>
      <rect x={x} y={y} width={w} height={h} rx={8} fill={group.color} stroke={borderColor} strokeWidth={2} />
      <text x={x + w / 2} y={y + 16} fontSize={12} textAnchor="middle" fontWeight={700} fill="#333">{group.name}</text>
      {trNode && <text x={x + w / 2} y={y + 30} fontSize={9} textAnchor="middle" fill="#666">
        {trNode.transformer?.capacity_kVA || ''}kVA {trNode.transformer?.secondaryV || ''}V
      </text>}
      <text x={x + w / 2} y={y + 44} fontSize={9} textAnchor="middle" fill="#888">
        {trunkCount}幹線 {loadCount}回路
      </text>
      <g>
        <rect x={x + w / 2 - 14} y={y + h - 18} width={28} height={14} rx={3}
          fill={allOk ? '#e8f5e9' : '#ffebee'} stroke={allOk ? '#4caf50' : '#c00'} strokeWidth={0.8} />
        <text x={x + w / 2} y={y + h - 8} fontSize={8} textAnchor="middle" fontWeight={700}
          fill={allOk ? '#2e7d32' : '#c00'}>{allOk ? 'OK' : 'NG'}</text>
      </g>
      {/* 展開ボタン */}
      <text x={x + w - 12} y={y + 14} fontSize={14} fill={borderColor} style={{ cursor: 'pointer' }}>+</text>
    </g>
  );
}

/* === DIAGRAM: AUTO LAYOUT (M2-4-8) === */

function autoLayout(nodes, direction) {
  const dir = DIRECTIONS[direction || 'horizontal'];
  const tree = buildTree(nodes);
  if (tree.length === 0) return {};
  const positions = {};

  /* サブツリーの交差軸方向のサイズを再帰的に計測 */
  function measureCross(node) {
    if (!node.children || node.children.length === 0) {
      const s = nodeSize(node.type);
      return dir.crossAxis === 'y' ? s.h : s.w;
    }
    let total = 0;
    for (let i = 0; i < node.children.length; i++) {
      if (i > 0) total += MOD.GAP_CROSS;
      total += measureCross(node.children[i]);
    }
    const s = nodeSize(node.type);
    const minSelf = dir.crossAxis === 'y' ? s.h : s.w;
    return Math.max(total, minSelf);
  }

  function nodeSize(type) {
    switch (type) {
      case 'transformer': return { w: MOD.TR_W, h: MOD.TR_H };
      case 'trunk': return { w: MOD.TRUNK_W, h: MOD.TRUNK_H };
      case 'load': return { w: MOD.LOAD_W, h: MOD.LOAD_H };
      default: return { w: 100, h: 50 };
    }
  }

  /* 再帰的に座標を割り当て */
  function assign(node, mainPos, crossStart) {
    const s = nodeSize(node.type);
    const subtreeCross = measureCross(node);
    const selfCross = dir.crossAxis === 'y' ? s.h : s.w;
    const selfMain = dir.mainAxis === 'x' ? s.w : s.h;
    const cx = crossStart + (subtreeCross - selfCross) / 2;

    if (dir.mainAxis === 'x') {
      positions[node.id] = { x: mainPos, y: cx, width: s.w, height: s.h };
    } else {
      positions[node.id] = { x: cx, y: mainPos, width: s.w, height: s.h };
    }

    if (node.children && node.children.length > 0) {
      let childCross = crossStart;
      const childMain = mainPos + selfMain + MOD.GAP_MAIN;
      for (let i = 0; i < node.children.length; i++) {
        if (i > 0) childCross += MOD.GAP_CROSS;
        assign(node.children[i], childMain, childCross);
        childCross += measureCross(node.children[i]);
      }
    }
  }

  /* 各ルートを配置 */
  let crossOffset = MOD.MARGIN;
  for (let i = 0; i < tree.length; i++) {
    if (i > 0) crossOffset += MOD.GAP_CROSS * 2;
    assign(tree[i], MOD.MARGIN, crossOffset);
    crossOffset += measureCross(tree[i]);
  }

  return positions;
}

/* canvas 座標が未設定のノードに自動配置を適用 */
function ensureCanvasPositions(nodes, direction) {
  const needsLayout = nodes.some(n => !n.canvas || n.canvas.x == null);
  if (!needsLayout) return nodes;
  const positions = autoLayout(nodes, direction);
  return nodes.map(n => {
    if (n.canvas && n.canvas.x != null) return n;
    const pos = positions[n.id];
    return pos ? { ...n, canvas: pos } : { ...n, canvas: { x: 0, y: 0, width: 100, height: 50 } };
  });
}

/* === DIAGRAM: CONNECTION LINE (M2-4-4) === */

function ConnectionLine({ fromCanvas, toCanvas, direction, ok, selected }) {
  const dir = DIRECTIONS[direction || 'horizontal'];
  let fx, fy, tx, ty;
  if (dir.outPort === 'right') {
    fx = fromCanvas.x + fromCanvas.width;
    fy = fromCanvas.y + fromCanvas.height / 2;
    tx = toCanvas.x;
    ty = toCanvas.y + toCanvas.height / 2;
  } else {
    fx = fromCanvas.x + fromCanvas.width / 2;
    fy = fromCanvas.y + fromCanvas.height;
    tx = toCanvas.x + toCanvas.width / 2;
    ty = toCanvas.y;
  }
  const mx = (fx + tx) / 2;
  const my = (fy + ty) / 2;
  const d = dir.outPort === 'right'
    ? `M${fx},${fy} C${mx},${fy} ${mx},${ty} ${tx},${ty}`
    : `M${fx},${fy} C${fx},${my} ${tx},${my} ${tx},${ty}`;
  return (
    <path d={d}
      fill="none"
      stroke={selected ? '#1976d2' : ok === false ? '#c00' : '#666'}
      strokeWidth={selected ? 2.5 : 1.5}
      strokeDasharray={ok === false ? '4 2' : 'none'}
    />
  );
}

/* === DIAGRAM: MODULE COMPONENTS (M2-4-2) === */

function ModuleTransformer({ node, result, canvas, selected, mode, direction, onMouseDown, onClick, onPortMouseDown }) {
  const { x, y, width: w, height: h } = canvas;
  const dir = DIRECTIONS[direction || 'horizontal'];
  const tr = node.transformer || {};
  const inX = dir.inPort === 'left' ? x : x + w / 2;
  const inY = dir.inPort === 'left' ? y + h / 2 : y;
  const outX = dir.outPort === 'right' ? x + w : x + w / 2;
  const outY = dir.outPort === 'right' ? y + h / 2 : y + h;
  return (
    <g style={{ cursor: mode === 'edit' ? 'grab' : 'pointer' }}
       onMouseDown={mode === 'edit' ? onMouseDown : undefined}
       onClick={onClick}>
      <SvgTransformer x={x} y={y} w={w} h={h} connection={tr.connection} />
      {selected && <rect x={x - 2} y={y - 2} width={w + 4} height={h + 4} rx={6} fill="none" stroke="#1976d2" strokeWidth={2} strokeDasharray="4 2" />}
      <text x={x + w / 2} y={y - 6} fontSize={10} textAnchor="middle" fontWeight={700} fill="#333">{tr.name || 'TR'}</text>
      <text x={x + w / 2} y={y + h + 12} fontSize={8} textAnchor="middle" fill="#666">
        {tr.capacity_kVA || ''}kVA {tr.primaryV || ''}/{tr.secondaryV || ''}V
      </text>
      {result && <text x={x + w / 2} y={y + h + 22} fontSize={8} textAnchor="middle" fill="#666">
        Isc₃={rd(result.Isc3 / 1000, 1)}kA  %Z={tr.pctZ}
      </text>}
      {mode === 'edit' && (
        <>
          <SvgPort x={inX} y={inY} type="in" onMouseDown={e => { e.stopPropagation(); onPortMouseDown && onPortMouseDown(node.id, 'in', e); }} />
          <SvgPort x={outX} y={outY} type="out" onMouseDown={e => { e.stopPropagation(); onPortMouseDown && onPortMouseDown(node.id, 'out', e); }} />
        </>
      )}
    </g>
  );
}

function ModuleTrunk({ node, result, canvas, selected, mode, direction, onMouseDown, onClick, onPortMouseDown }) {
  const { x, y, width: w, height: h } = canvas;
  const dir = DIRECTIONS[direction || 'horizontal'];
  const tr = node.trunk || {};
  const ok = result ? result.ok : null;
  const borderColor = ok === false ? '#c00' : ok ? '#4caf50' : '#999';
  const bgColor = ok === false ? '#fff5f5' : '#fff';
  const outX = dir.outPort === 'right' ? x + w : x + w / 2;
  const outY = dir.outPort === 'right' ? y + h / 2 : y + h;
  const inX = dir.inPort === 'left' ? x : x + w / 2;
  const inY = dir.inPort === 'left' ? y + h / 2 : y;
  const sizeStr = result ? `${result.size}${result.parallel > 1 ? '×' + result.parallel : ''}` : '';
  return (
    <g style={{ cursor: mode === 'edit' ? 'grab' : 'pointer' }}
       onMouseDown={mode === 'edit' ? onMouseDown : undefined}
       onClick={onClick}>
      <rect x={x} y={y} width={w} height={h} rx={4} fill={bgColor} stroke={borderColor} strokeWidth={1.5} />
      {selected && <rect x={x - 2} y={y - 2} width={w + 4} height={h + 4} rx={6} fill="none" stroke="#1976d2" strokeWidth={2} strokeDasharray="4 2" />}
      {/* MCCB シンボル (左端内部) */}
      <SvgMCCB x={x + 18} y={y + h / 2} />
      {result && <text x={x + 36} y={y + h / 2 - 6} fontSize={8} fill="#333">{result.mccbAT}AT</text>}
      {/* ケーブル表記 */}
      <text x={x + 36} y={y + h / 2 + 5} fontSize={8} fill="#555">{tr.cableType} {sizeStr}</text>
      <text x={x + 36} y={y + h / 2 + 15} fontSize={7} fill="#888">{tr.cableLength}m</text>
      {/* 名称 */}
      <text x={x + w / 2} y={y - 5} fontSize={10} textAnchor="middle" fontWeight={600} fill="#333">{tr.name || '幹線'}</text>
      {/* 電流・電圧降下 */}
      {result && (
        <text x={x + w - 6} y={y + h / 2 + 3} fontSize={8} textAnchor="end" fill="#666">
          {rd(result.dI, 1)}A  e={result.vdPercent}%
        </text>
      )}
      {/* 判定バッジ */}
      {ok != null && (
        <g>
          <rect x={x + w - 22} y={y + 3} width={18} height={12} rx={2} fill={ok ? '#e8f5e9' : '#ffebee'} stroke={ok ? '#4caf50' : '#c00'} strokeWidth={0.8} />
          <text x={x + w - 13} y={y + 12} fontSize={7} textAnchor="middle" fontWeight={700} fill={ok ? '#2e7d32' : '#c00'}>{ok ? 'OK' : 'NG'}</text>
        </g>
      )}
      {mode === 'edit' && (
        <>
          <SvgPort x={inX} y={inY} type="in" onMouseDown={e => { e.stopPropagation(); onPortMouseDown && onPortMouseDown(node.id, 'in', e); }} />
          <SvgPort x={outX} y={outY} type="out" onMouseDown={e => { e.stopPropagation(); onPortMouseDown && onPortMouseDown(node.id, 'out', e); }} />
        </>
      )}
    </g>
  );
}

function ModuleLoadNode({ node, result, canvas, selected, mode, direction, onMouseDown, onClick, onPortMouseDown }) {
  const { x, y, width: w, height: h } = canvas;
  const dir = DIRECTIONS[direction || 'horizontal'];
  const p = node.load || {};
  const ok = result ? result.ok : null;
  const borderColor = ok === false ? '#c00' : ok ? '#4caf50' : '#999';
  const bgColor = ok === false ? '#fff5f5' : '#fff';
  const inX = dir.inPort === 'left' ? x : x + w / 2;
  const inY = dir.inPort === 'left' ? y + h / 2 : y;
  const sizeStr = result ? `${result.size}${result.parallel > 1 ? '×' + result.parallel : ''}` : '';
  const isMotor = p.circuitType === '電動機';
  return (
    <g style={{ cursor: mode === 'edit' ? 'grab' : 'pointer' }}
       onMouseDown={mode === 'edit' ? onMouseDown : undefined}
       onClick={onClick}>
      <rect x={x} y={y} width={w} height={h} rx={4} fill={bgColor} stroke={borderColor} strokeWidth={1.5} />
      {selected && <rect x={x - 2} y={y - 2} width={w + 4} height={h + 4} rx={6} fill="none" stroke="#1976d2" strokeWidth={2} strokeDasharray="4 2" />}
      {/* MCCB シンボル */}
      <SvgMCCB x={x + 18} y={y + h / 2} />
      {result && <text x={x + 36} y={y + h / 2 - 4} fontSize={8} fill="#333">{result.mccbAT}AT</text>}
      <text x={x + 36} y={y + h / 2 + 7} fontSize={7} fill="#888">{p.cableType} {sizeStr} {p.cableLength}m</text>
      {/* 負荷シンボル (右端) */}
      {isMotor
        ? <SvgMotor x={x + w - 18} y={y + h / 2} r={10} />
        : <SvgLoad x={x + w - 18} y={y + h / 2} r={10} />
      }
      {/* 名称 */}
      <text x={x + w / 2} y={y - 5} fontSize={9} textAnchor="middle" fontWeight={600} fill="#333">{p.loadName || p.trunkName || '負荷'}</text>
      {/* 電流 */}
      {result && (
        <text x={x + w / 2} y={y + h + 11} fontSize={7} textAnchor="middle" fill="#666">
          {rd(result.dI, 1)}A  e={result.vdPercent}%
        </text>
      )}
      {/* 判定バッジ */}
      {ok != null && (
        <g>
          <rect x={x + w - 22} y={y + 3} width={18} height={12} rx={2} fill={ok ? '#e8f5e9' : '#ffebee'} stroke={ok ? '#4caf50' : '#c00'} strokeWidth={0.8} />
          <text x={x + w - 13} y={y + 12} fontSize={7} textAnchor="middle" fontWeight={700} fill={ok ? '#2e7d32' : '#c00'}>{ok ? 'OK' : 'NG'}</text>
        </g>
      )}
      {mode === 'edit' && (
        <SvgPort x={inX} y={inY} type="in" onMouseDown={e => { e.stopPropagation(); onPortMouseDown && onPortMouseDown(node.id, 'in', e); }} />
      )}
    </g>
  );
}

/* === DIAGRAM: CANVAS COMPONENT (M2-4-1, M2-4-5, M2-4-6) === */

function DiagramCanvas({ nodes, allResults, systemMeta, selectedId, onSelectNode, mode, onNodesChange, groups, crossLinks, onToggleGroupCollapse }) {
  const direction = (systemMeta && systemMeta.diagramDirection) || 'horizontal';
  const svgRef = React.useRef(null);
  const [vt, setVt] = React.useState({ x: 0, y: 0, scale: 1 });
  const [dragging, setDragging] = React.useState(null);     /* { nodeId, offX, offY } */
  const [panning, setPanning] = React.useState(null);         /* { startX, startY, vtX, vtY } */
  const [wiring, setWiring] = React.useState(null);           /* { fromId, fromPort, mx, my } */

  /* ホイール操作: 通常=上下スクロール, Shift=左右スクロール, Ctrl=ズーム */
  const handleWheel = React.useCallback((e) => {
    e.preventDefault();
    if (e.ctrlKey || e.metaKey) {
      /* Ctrl+ホイール: カーソル中心ズーム */
      const factor = e.deltaY < 0 ? 1.1 : 1 / 1.1;
      setVt(prev => {
        const rect = svgRef.current.getBoundingClientRect();
        const cx = e.clientX - rect.left;
        const cy = e.clientY - rect.top;
        const newScale = Math.min(Math.max(prev.scale * factor, 0.1), 5);
        return {
          scale: newScale,
          x: cx - (cx - prev.x) * (newScale / prev.scale),
          y: cy - (cy - prev.y) * (newScale / prev.scale)
        };
      });
    } else if (e.shiftKey) {
      /* Shift+ホイール: 左右スクロール */
      setVt(prev => ({ ...prev, x: prev.x - e.deltaY }));
    } else {
      /* 通常ホイール: 上下スクロール */
      setVt(prev => ({ ...prev, y: prev.y - e.deltaY }));
    }
  }, []);

  /* パン開始（背景クリック / ビューモードでは全域） */
  const handleBgMouseDown = (e) => {
    if (e.button !== 0) return;
    if (mode !== 'edit') {
      /* ビューモード: どこでもパン開始 */
      setPanning({ startX: e.clientX, startY: e.clientY, vtX: vt.x, vtY: vt.y });
      return;
    }
    /* 編集モード: 背景クリックのみパン */
    if (e.target === svgRef.current || e.target.tagName === 'svg') {
      setPanning({ startX: e.clientX, startY: e.clientY, vtX: vt.x, vtY: vt.y });
    }
  };

  /* パン / ドラッグ / ワイヤリング のマウス移動 */
  React.useEffect(() => {
    const handleMove = (e) => {
      if (panning) {
        setVt({ ...vt, x: panning.vtX + (e.clientX - panning.startX), y: panning.vtY + (e.clientY - panning.startY), scale: vt.scale });
      }
      if (dragging && mode === 'edit') {
        const rect = svgRef.current.getBoundingClientRect();
        const sx = (e.clientX - rect.left - vt.x) / vt.scale;
        const sy = (e.clientY - rect.top - vt.y) / vt.scale;
        const newX = sx - dragging.offX;
        const newY = sy - dragging.offY;
        onNodesChange && onNodesChange(prev =>
          prev.map(n => n.id === dragging.nodeId
            ? { ...n, canvas: { ...n.canvas, x: newX, y: newY } }
            : n
          )
        );
      }
      if (wiring) {
        const rect = svgRef.current.getBoundingClientRect();
        setWiring(prev => ({
          ...prev,
          mx: (e.clientX - rect.left - vt.x) / vt.scale,
          my: (e.clientY - rect.top - vt.y) / vt.scale
        }));
      }
    };
    const handleUp = (e) => {
      /* ビューモード: パン解除 + クリック判定（移動量が小さければノード選択） */
      if (panning && panning.clickNodeId) {
        const dx = e.clientX - panning.startX;
        const dy = e.clientY - panning.startY;
        if (Math.abs(dx) < 4 && Math.abs(dy) < 4) {
          const clickedNode = nodes.find(n => n.id === panning.clickNodeId);
          if (clickedNode) onSelectNode && onSelectNode(clickedNode);
        }
      }
      if (wiring && mode === 'edit') {
        /* 接続先ポートの検出 */
        const rect = svgRef.current.getBoundingClientRect();
        const sx = (e.clientX - rect.left - vt.x) / vt.scale;
        const sy = (e.clientY - rect.top - vt.y) / vt.scale;
        const target = nodes.find(n => {
          if (n.id === wiring.fromId) return false;
          const c = n.canvas;
          if (!c) return false;
          const dir = DIRECTIONS[direction];
          let px, py;
          if (dir.inPort === 'left') { px = c.x; py = c.y + c.height / 2; }
          else { px = c.x + c.width / 2; py = c.y; }
          return Math.abs(sx - px) < 15 && Math.abs(sy - py) < 15;
        });
        if (target && wiring.fromPort === 'out') {
          /* 接続: target の parentId を fromId に設定 */
          const testNodes = nodes.map(n => n.id === target.id ? { ...n, parentId: wiring.fromId } : n);
          const err = validateNode(testNodes, { ...target, parentId: wiring.fromId });
          if (!err) {
            onNodesChange && onNodesChange(prev =>
              prev.map(n => n.id === target.id ? { ...n, parentId: wiring.fromId } : n)
            );
          }
        }
        setWiring(null);
      }
      setPanning(null);
      setDragging(null);
    };
    window.addEventListener('mousemove', handleMove);
    window.addEventListener('mouseup', handleUp);
    return () => { window.removeEventListener('mousemove', handleMove); window.removeEventListener('mouseup', handleUp); };
  }, [panning, dragging, wiring, vt, nodes, mode, direction]);

  /* ノードドラッグ開始 / ビューモードではパン開始 */
  const handleNodeMouseDown = (nodeId, e) => {
    if (mode !== 'edit') {
      /* ビューモード: ノード上でもパン開始（クリック判定は handleUp で） */
      e.stopPropagation();
      setPanning({ startX: e.clientX, startY: e.clientY, vtX: vt.x, vtY: vt.y, clickNodeId: nodeId });
      return;
    }
    e.stopPropagation();
    const node = nodes.find(n => n.id === nodeId);
    if (!node || !node.canvas) return;
    const rect = svgRef.current.getBoundingClientRect();
    const sx = (e.clientX - rect.left - vt.x) / vt.scale;
    const sy = (e.clientY - rect.top - vt.y) / vt.scale;
    setDragging({ nodeId, offX: sx - node.canvas.x, offY: sy - node.canvas.y });
  };

  /* ポートドラッグ開始（ワイヤリング） */
  const handlePortMouseDown = (nodeId, portType, e) => {
    if (mode !== 'edit') return;
    const node = nodes.find(n => n.id === nodeId);
    if (!node || !node.canvas) return;
    const rect = svgRef.current.getBoundingClientRect();
    setWiring({
      fromId: nodeId, fromPort: portType,
      mx: (e.clientX - rect.left - vt.x) / vt.scale,
      my: (e.clientY - rect.top - vt.y) / vt.scale
    });
  };

  /* ノードクリック */
  const handleNodeClick = (node) => {
    onSelectNode && onSelectNode(node);
  };

  /* Fit to view */
  const fitView = () => {
    if (!svgRef.current || nodes.length === 0) return;
    let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
    for (const n of nodes) {
      if (!n.canvas) continue;
      minX = Math.min(minX, n.canvas.x);
      minY = Math.min(minY, n.canvas.y);
      maxX = Math.max(maxX, n.canvas.x + n.canvas.width);
      maxY = Math.max(maxY, n.canvas.y + n.canvas.height);
    }
    if (minX === Infinity) return;
    const rect = svgRef.current.getBoundingClientRect();
    const pad = 40;
    const cw = maxX - minX + pad * 2;
    const ch = maxY - minY + pad * 2;
    const scale = Math.min(rect.width / cw, rect.height / ch, 2);
    setVt({
      scale,
      x: (rect.width - cw * scale) / 2 - (minX - pad) * scale,
      y: (rect.height - ch * scale) / 2 - (minY - pad) * scale
    });
  };

  /* 接続線の描画 (M2-6: 折りたたみグループのノード接続を非表示) */
  const renderConnections = () => {
    const lines = [];
    for (const node of nodes) {
      if (!node.parentId || !node.canvas || collapsedNodeIds.has(node.id)) continue;
      const parent = nodes.find(n => n.id === node.parentId);
      if (!parent || !parent.canvas) continue;
      const r = allResults[node.id];
      lines.push(
        <ConnectionLine key={`conn-${node.id}`}
          fromCanvas={parent.canvas} toCanvas={node.canvas}
          direction={direction} ok={r ? r.ok : null}
          selected={selectedId === node.id || selectedId === parent.id}
        />
      );
    }
    return lines;
  };

  /* モジュール描画 (M2-6: 折りたたみグループのノードを非表示) */
  const renderModules = () => {
    return nodes.filter(n => n.canvas && !collapsedNodeIds.has(n.id)).map(node => {
      const r = allResults[node.id];
      const sel = selectedId === node.id;
      const common = {
        node, result: r, canvas: node.canvas, selected: sel, mode, direction,
        onMouseDown: (e) => handleNodeMouseDown(node.id, e),
        onClick: () => handleNodeClick(node),
        onPortMouseDown: handlePortMouseDown
      };
      switch (node.type) {
        case 'transformer': return <ModuleTransformer key={node.id} {...common} />;
        case 'trunk': return <ModuleTrunk key={node.id} {...common} />;
        case 'load': return <ModuleLoadNode key={node.id} {...common} />;
        default: return null;
      }
    });
  };

  /* ワイヤリング中の仮線 */
  const renderWiringLine = () => {
    if (!wiring) return null;
    const from = nodes.find(n => n.id === wiring.fromId);
    if (!from || !from.canvas) return null;
    const dir = DIRECTIONS[direction];
    let fx, fy;
    if (wiring.fromPort === 'out') {
      fx = dir.outPort === 'right' ? from.canvas.x + from.canvas.width : from.canvas.x + from.canvas.width / 2;
      fy = dir.outPort === 'right' ? from.canvas.y + from.canvas.height / 2 : from.canvas.y + from.canvas.height;
    } else {
      fx = dir.inPort === 'left' ? from.canvas.x : from.canvas.x + from.canvas.width / 2;
      fy = dir.inPort === 'left' ? from.canvas.y + from.canvas.height / 2 : from.canvas.y;
    }
    return <line x1={fx} y1={fy} x2={wiring.mx} y2={wiring.my} stroke="#1976d2" strokeWidth={2} strokeDasharray="4 2" />;
  };

  /* M2-6: 折りたたみグループの所属ノードIDセット */
  const collapsedNodeIds = React.useMemo(() => {
    const grps = groups || [];
    const ids = new Set();
    grps.filter(g => g.canvas.collapsed).forEach(g => {
      getGroupNodes(nodes, g.rootNodeId).forEach(n => ids.add(n.id));
    });
    return ids;
  }, [groups, nodes]);

  /* M2-6: グループ描画（展開=背景枠、折りたたみ=サマリーボックス） */
  const renderGroupContainers = () => {
    const grps = groups || [];
    const elements = [];
    grps.forEach(grp => {
      const memberNodes = getGroupNodes(nodes, grp.rootNodeId).filter(n => n.canvas);
      if (memberNodes.length === 0) return;

      if (grp.canvas.collapsed) {
        /* 折りたたみ: サマリーボックス */
        let cx = 0, cy = 0;
        memberNodes.forEach(n => { cx += n.canvas.x; cy += n.canvas.y; });
        cx /= memberNodes.length; cy /= memberNodes.length;
        const canvasPos = { x: grp.canvas.x || cx, y: grp.canvas.y || cy };
        elements.push(
          <ModuleGroupCollapsed key={'grp-col-' + grp.id}
            group={grp} nodes={nodes} allResults={allResults}
            canvas={canvasPos}
            onClick={() => onToggleGroupCollapse && onToggleGroupCollapse(grp.id)}
          />
        );
      } else {
        /* 展開: 背景枠 */
        const pad = 15;
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        for (const n of memberNodes) {
          minX = Math.min(minX, n.canvas.x);
          minY = Math.min(minY, n.canvas.y);
          maxX = Math.max(maxX, n.canvas.x + n.canvas.width);
          maxY = Math.max(maxY, n.canvas.y + n.canvas.height);
        }
        if (minX === Infinity) return;
        const borderColor = grp.color === '#e3f2fd' ? '#90caf9' : grp.color === '#e8f5e9' ? '#a5d6a7' : grp.color === '#fff3e0' ? '#ffcc80' : '#bbb';
        elements.push(
          <g key={'grp-bg-' + grp.id}>
            <rect x={minX - pad} y={minY - pad - 16} width={maxX - minX + pad * 2} height={maxY - minY + pad * 2 + 16}
              rx={8} fill={grp.color} fillOpacity={0.35} stroke={borderColor} strokeWidth={1.5} strokeDasharray="6 3" />
            <text x={minX - pad + 6} y={minY - pad - 3} fontSize={11} fontWeight={700} fill={borderColor}>{grp.name}</text>
          </g>
        );
      }
    });
    return elements;
  };

  /* M2-6: クロスリンク描画 */
  const renderCrossLinks = () => {
    const grps = groups || [];
    const links = crossLinks || [];
    return links.map(cl => {
      const fromGrp = grps.find(g => g.id === cl.fromGroupId);
      const toGrp = grps.find(g => g.id === cl.toGroupId);
      if (!fromGrp || !toGrp) return null;
      /* グループの重心を計算 */
      const getCentroid = (grp) => {
        const members = getGroupNodes(nodes, grp.rootNodeId).filter(n => n.canvas);
        if (members.length === 0) return null;
        const cx = members.reduce((s, n) => s + n.canvas.x + n.canvas.width / 2, 0) / members.length;
        const cy = members.reduce((s, n) => s + n.canvas.y + n.canvas.height / 2, 0) / members.length;
        const maxX = Math.max(...members.map(n => n.canvas.x + n.canvas.width));
        const minX = Math.min(...members.map(n => n.canvas.x));
        return { cx, cy, maxX, minX };
      };
      const from = getCentroid(fromGrp);
      const to = getCentroid(toGrp);
      if (!from || !to) return null;
      const fx = from.maxX + 10, fy = from.cy;
      const tx = to.minX - 10, ty = to.cy;
      const mx = (fx + tx) / 2;
      const dashPattern = cl.lineStyle === 'dotted' ? '2 4' : cl.lineStyle === 'solid' ? '' : '8 4';
      const color = cl.color || '#ff9800';
      return (
        <g key={'cl-' + cl.id}>
          <path d={`M${fx},${fy} C${mx},${fy} ${mx},${ty} ${tx},${ty}`}
            fill="none" stroke={color} strokeWidth={2} strokeDasharray={dashPattern} />
          {cl.label && (
            <text x={mx} y={(fy + ty) / 2 - 6} fontSize={9} textAnchor="middle" fill={color} fontWeight={600}>
              {cl.label}
            </text>
          )}
        </g>
      );
    });
  };

  return (
    <div style={{ width: '100%', height: '100%', position: 'relative', background: '#f8f9fa', overflow: 'hidden' }}>
      <svg ref={svgRef} width="100%" height="100%"
        style={{ cursor: panning ? 'grabbing' : (mode === 'edit' ? 'default' : 'grab') }}
        onWheel={handleWheel}
        onMouseDown={handleBgMouseDown}
      >
        {/* グリッド（編集モード） */}
        {mode === 'edit' && (
          <defs>
            <pattern id="grid" width={20 * vt.scale} height={20 * vt.scale} patternUnits="userSpaceOnUse"
              x={vt.x % (20 * vt.scale)} y={vt.y % (20 * vt.scale)}>
              <path d={`M ${20 * vt.scale} 0 L 0 0 0 ${20 * vt.scale}`} fill="none" stroke="#e0e0e0" strokeWidth={0.5} />
            </pattern>
            <rect width="100%" height="100%" fill="url(#grid)" />
          </defs>
        )}
        <g transform={`translate(${vt.x},${vt.y}) scale(${vt.scale})`}>
          {renderGroupContainers()}
          {renderConnections()}
          {renderCrossLinks()}
          {renderModules()}
          {renderWiringLine()}
        </g>
      </svg>
      {/* ズーム/フィット コントロール */}
      <div style={{ position: 'absolute', bottom: 8, right: 8, display: 'flex', gap: 4 }}>
        <button onClick={() => setVt(v => ({ ...v, scale: v.scale * 1.2 }))}
          style={{ padding: '4px 8px', borderRadius: 4, border: '1px solid #ccc', background: '#fff', cursor: 'pointer', fontSize: 14 }}>+</button>
        <button onClick={() => setVt(v => ({ ...v, scale: v.scale / 1.2 }))}
          style={{ padding: '4px 8px', borderRadius: 4, border: '1px solid #ccc', background: '#fff', cursor: 'pointer', fontSize: 14 }}>−</button>
        <button onClick={fitView}
          style={{ padding: '4px 8px', borderRadius: 4, border: '1px solid #ccc', background: '#fff', cursor: 'pointer', fontSize: 11 }}>Fit</button>
      </div>
      {/* モード表示 */}
      <div style={{ position: 'absolute', top: 8, left: 8, fontSize: 11, color: '#666', background: 'rgba(255,255,255,0.8)', padding: '2px 8px', borderRadius: 4 }}>
        {mode === 'edit' ? '編集モード' : 'ビューモード'}
      </div>
    </div>
  );
}

/* === COMPONENTS === */

/* --- M2-6: 出力ドロップダウン --- */
function OutputDropdown({ label, disabled, groups, onAll, onGroup }) {
  const [open, setOpen] = React.useState(false);
  const ref = React.useRef(null);
  React.useEffect(() => {
    if (!open) return;
    const close = (e) => { if (ref.current && !ref.current.contains(e.target)) setOpen(false); };
    document.addEventListener('mousedown', close);
    return () => document.removeEventListener('mousedown', close);
  }, [open]);
  const hasGroups = groups && groups.length > 1;
  const btnStyle = {
    padding: '4px 12px', borderRadius: 4, border: '1px solid rgba(255,255,255,0.7)',
    background: 'transparent', color: '#fff',
    cursor: disabled ? 'not-allowed' : 'pointer',
    opacity: disabled ? 0.5 : 1, fontSize: 13
  };
  if (!hasGroups) return <button onClick={onAll} disabled={disabled} style={btnStyle}>{label}</button>;
  return (
    <div ref={ref} style={{ position: 'relative', display: 'inline-block' }}>
      <button onClick={() => !disabled && setOpen(!open)} disabled={disabled} style={btnStyle}>{label} ▾</button>
      {open && (
        <div style={{
          position: 'absolute', top: '100%', right: 0, marginTop: 4, minWidth: 160,
          background: '#fff', borderRadius: 6, boxShadow: '0 4px 12px rgba(0,0,0,0.2)',
          zIndex: 1000, overflow: 'hidden'
        }}>
          <div onClick={() => { onAll(); setOpen(false); }}
            style={{ padding: '8px 12px', fontSize: 12, cursor: 'pointer', borderBottom: '1px solid #eee', fontWeight: 600 }}
            onMouseEnter={e => e.target.style.background = '#f5f5f5'}
            onMouseLeave={e => e.target.style.background = '#fff'}>
            全体（結合出力）
          </div>
          {groups.map(g => (
            <div key={g.id} onClick={() => { onGroup(g.id); setOpen(false); }}
              style={{ padding: '8px 12px', fontSize: 12, cursor: 'pointer', display: 'flex', alignItems: 'center', gap: 6 }}
              onMouseEnter={e => e.target.style.background = '#f5f5f5'}
              onMouseLeave={e => e.target.style.background = '#fff'}>
              <span style={{ width: 10, height: 10, borderRadius: 2, background: g.color, border: '1px solid #ccc', flexShrink: 0 }}></span>
              {g.name}
            </div>
          ))}
        </div>
      )}
    </div>
  );
}

/* --- 電気方式 → 電圧選択肢 (§5) --- */
const VOLTAGE_OPTIONS = {
  '単相2線式': [100, 200],
  '単相3線式': [200],
  '三相3線式': [200, 210, 400, 415, 440],
  '三相4線式': [200]
};

/* --- ケーブル種類と電気方式の対応 (§3-3) --- */
function getCableTypeOptions(sys) {
  if (sys === '単相2線式') return ['CV-2C'];
  if (sys === '単相3線式') return ['CV-3C'];
  return ['CVT', 'CVD', 'CV-3C'];
}

/* --- スライダー感度テーブル (§7) --- */
const SLIDER_CFG = {
  capacity_kW:  { step: 0.1, range: 100 },
  capacity_kVA: { step: 0.1, range: 100 },
  capacity_A:   { step: 1,   range: 200 },
  powerFactor:  { step: 0.01, range: 0.30 },
  efficiency:   { step: 0.01, range: 0.30 },
  demandFactor: { step: 1,   range: 50 },
  cableLength:  { step: 0.5, range: 100 },
  ambientTemp:  { step: 5,   range: 15 },
  reductionFactor: { step: 0.01, range: 0.30 }
};

/* --- デフォルト入力値 (§3) --- */
const DEFAULT_PARAMS = {
  trunkName: '', loadName: '',
  system: '三相3線式', voltage: 200, freq: '60Hz', supplyType: '低圧受電',
  circuitType: '一般', mccbATOverride: '自動', icuClass: 'standard',
  capacity: 15, unit: 'kW', powerFactor: 0.85, efficiency: 1.0,
  demandFactor: 100, cableLength: 30,
  cableType: 'CVT', wiringMethod: 'ケーブルラック配線',
  ambientTemp: 40, reductionPreset: '1段 S=d 7列以上', reductionFactor: 0.70,
  hasELCB: false, elcbSensitivity_mA: 30, groundingMethod: 'TT', groundResistance_ohm: 100
};

/* --- 変圧器デフォルト (§19) --- */
const DEFAULT_TR_PARAMS = {
  name: 'TR-1', trType: '三相油入', capacity_kVA: 500,
  primaryV: 6600, secondaryV: 210,
  pctZ: 4.00, xrRatio: 2.98, connection: 'Δ-Y', pctZAuto: true,
  hvSystem: { /* P4-7: reserved for M2-3 (§19-5) */
    cableType: null,            /* 'CV-3C' | 'CVT' | null */
    cableSize_mm2: null,        /* number | null */
    totalCableLength_km: null,  /* number | null */
    capacitance_uF_per_km: null, /* number | null */
    vcbTripTime_s: 1.0          /* VCB 遮断時間 [s]（B種接地計算用） */
  }
};

/* --- 幹線デフォルト (§9) --- */
const DEFAULT_TRUNK_PARAMS = {
  name: '', system: '三相3線式', voltage: 210, freq: '60Hz', supplyType: '高圧受電',
  cableLength: 10, cableType: 'CVT', wiringMethod: 'ケーブルラック配線',
  ambientTemp: 40, reductionPreset: '1段 S=d 7列以上', reductionFactor: 0.70,
  powerFactor: 0.85, mccbATOverride: '自動', icuClass: 'standard'
};

/* --- 一括取込ダイアログ --- */

const BULK_COLUMNS = [
  { key: 'trunkName',       label: '幹線名',     required: true },
  { key: 'loadName',        label: '負荷名称',   required: false },
  { key: 'system',          label: '電気方式',   required: false },
  { key: 'voltage',         label: '電圧',       required: false },
  { key: 'capacity',        label: '容量',       required: true },
  { key: 'unit',            label: '単位',       required: false },
  { key: 'circuitType',     label: '回路種別',   required: false },
  { key: 'powerFactor',     label: '力率',       required: false },
  { key: 'efficiency',      label: '効率',       required: false },
  { key: 'demandFactor',    label: '需要率',     required: false },
  { key: 'cableLength',     label: 'こう長',     required: false },
  { key: 'freq',            label: '周波数',     required: false },
  { key: 'cableType',       label: 'ケーブル種類', required: false },
  { key: 'wiringMethod',    label: '配線方式',   required: false },
  { key: 'ambientTemp',     label: '周囲温度',   required: false },
  { key: 'reductionFactor', label: '低減率',     required: false },
  { key: 'mccbATOverride',  label: 'MCCB AT',    required: false },
  { key: 'trName',          label: '変圧器名',   required: false },
];

const BULK_HEADER_ROW = BULK_COLUMNS.map(c => c.label).join('\t');

const VALID_SYSTEMS = ['単相2線式', '単相3線式', '三相3線式', '三相4線式'];
const VALID_UNITS = ['kW', 'kVA', 'A'];
const VALID_CIRCUIT_TYPES = ['一般', '電動機'];
const VALID_FREQS = ['50Hz', '60Hz'];
const VALID_CABLE_TYPES = ['CVT', 'CVD', 'CV-3C', 'CV-2C'];
const VALID_WIRING_METHODS = ['ケーブルラック配線', '配管配線', '直埋布設', '管路布設'];

function parseBulkRow(cells) {
  const d = { ...DEFAULT_PARAMS };
  const errors = [];

  const get = (idx) => (cells[idx] || '').trim();

  /* 幹線名（必須） */
  const trunkName = get(0);
  if (!trunkName) errors.push('幹線名が未入力');
  else d.trunkName = trunkName;

  /* 負荷名称 */
  if (get(1)) d.loadName = get(1);

  /* 電気方式 */
  if (get(2)) {
    if (VALID_SYSTEMS.includes(get(2))) d.system = get(2);
    else errors.push('電気方式が不正: ' + get(2));
  }

  /* 電圧 */
  if (get(3)) {
    const v = parseFloat(get(3));
    if (!isNaN(v) && v > 0) d.voltage = v;
    else errors.push('電圧が不正: ' + get(3));
  }

  /* 容量（必須） */
  if (get(4)) {
    const c = parseFloat(get(4));
    if (!isNaN(c) && c > 0) d.capacity = c;
    else errors.push('容量が不正: ' + get(4));
  } else {
    errors.push('容量が未入力');
  }

  /* 単位 */
  if (get(5)) {
    if (VALID_UNITS.includes(get(5))) d.unit = get(5);
    else errors.push('単位が不正: ' + get(5));
  }

  /* 回路種別 */
  if (get(6)) {
    if (VALID_CIRCUIT_TYPES.includes(get(6))) d.circuitType = get(6);
    else errors.push('回路種別が不正: ' + get(6));
  }

  /* 力率 */
  if (get(7)) {
    const pf = parseFloat(get(7));
    if (!isNaN(pf) && pf >= 0.1 && pf <= 1.0) d.powerFactor = pf;
    else errors.push('力率が不正: ' + get(7));
  }

  /* 効率 */
  if (get(8)) {
    const ef = parseFloat(get(8));
    if (!isNaN(ef) && ef >= 0.1 && ef <= 1.0) d.efficiency = ef;
    else errors.push('効率が不正: ' + get(8));
  }

  /* 需要率 */
  if (get(9)) {
    const df = parseFloat(get(9));
    if (!isNaN(df) && df >= 1 && df <= 100) d.demandFactor = df;
    else errors.push('需要率が不正: ' + get(9));
  }

  /* こう長 */
  if (get(10)) {
    const cl = parseFloat(get(10));
    if (!isNaN(cl) && cl > 0) d.cableLength = cl;
    else errors.push('こう長が不正: ' + get(10));
  }

  /* 周波数 */
  if (get(11)) {
    if (VALID_FREQS.includes(get(11))) d.freq = get(11);
    else errors.push('周波数が不正: ' + get(11));
  }

  /* ケーブル種類 */
  if (get(12)) {
    if (VALID_CABLE_TYPES.includes(get(12))) d.cableType = get(12);
    else errors.push('ケーブル種類が不正: ' + get(12));
  }

  /* 配線方式 */
  if (get(13)) {
    if (VALID_WIRING_METHODS.includes(get(13))) d.wiringMethod = get(13);
    else errors.push('配線方式が不正: ' + get(13));
  }

  /* 周囲温度 */
  if (get(14)) {
    const t = parseFloat(get(14));
    if (!isNaN(t) && t >= 20 && t <= 50) d.ambientTemp = t;
    else errors.push('周囲温度が不正: ' + get(14));
  }

  /* 低減率 */
  if (get(15)) {
    const rf = parseFloat(get(15));
    if (!isNaN(rf) && rf >= 0.1 && rf <= 1.0) d.reductionFactor = rf;
    else errors.push('低減率が不正: ' + get(15));
  }

  /* MCCB AT */
  if (get(16)) {
    if (get(16) === '自動') d.mccbATOverride = '自動';
    else {
      const at = parseInt(get(16), 10);
      if (!isNaN(at) && at > 0) d.mccbATOverride = at;
      else errors.push('MCCB ATが不正: ' + get(16));
    }
  }

  /* 変圧器名 */
  const trName = get(17) || '';

  return { params: d, errors, trName };
}

function BulkImportDialog({ open, onClose, onImport }) {
  const [text, setText] = React.useState('');
  const [parsed, setParsed] = React.useState(null); /* [{ params, result, errors, rowIndex, trName }] */

  if (!open) return null;

  const handleParse = () => {
    const lines = text.split('\n').filter(l => l.trim());
    if (lines.length === 0) { setParsed([]); return; }

    /* ヘッダー行検出: 最初の行が既知ヘッダーと一致するかチェック */
    let startIdx = 0;
    const firstCells = lines[0].split('\t');
    if (firstCells[0].trim() === '幹線名' || firstCells[0].trim() === BULK_COLUMNS[0].label) {
      startIdx = 1;
    }

    const rows = [];
    for (let i = startIdx; i < lines.length; i++) {
      const cells = lines[i].split('\t');
      const { params, errors, trName } = parseBulkRow(cells);
      let result = null;
      if (errors.length === 0 && params.capacity > 0) {
        try { result = runCalc(params); } catch (e) { errors.push('計算エラー: ' + e.message); }
      }
      rows.push({ params, result, errors, rowIndex: i + 1, trName });
    }
    setParsed(rows);
  };

  const handleCopyHeader = () => {
    navigator.clipboard.writeText(BULK_HEADER_ROW).then(() => {
      /* copied */
    }).catch(() => {
      /* fallback: select text */
    });
  };

  const validRows = parsed ? parsed.filter(r => r.errors.length === 0) : [];

  const overlayStyle = {
    position: 'fixed', top: 0, left: 0, right: 0, bottom: 0,
    background: 'rgba(0,0,0,0.5)', zIndex: 10000,
    display: 'flex', alignItems: 'center', justifyContent: 'center'
  };
  const dialogStyle = {
    background: '#fff', borderRadius: 12, padding: 24,
    width: '90vw', maxWidth: 1100, maxHeight: '90vh', overflow: 'auto',
    boxShadow: '0 8px 32px rgba(0,0,0,0.3)'
  };

  return (
    <div style={overlayStyle} onClick={onClose}>
      <div style={dialogStyle} onClick={e => e.stopPropagation()}>
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 16 }}>
          <h3 style={{ margin: 0, fontSize: 18, fontWeight: 700 }}>一括取込</h3>
          <button onClick={onClose}
            style={{ border: 'none', background: 'none', fontSize: 24, cursor: 'pointer', color: '#999' }}>&times;</button>
        </div>

        <div style={{ marginBottom: 8, fontSize: 12, color: '#666' }}>
          スプレッドシートからタブ区切りデータを貼り付けてください。ヘッダー行は自動検出されます。
        </div>

        <div style={{ marginBottom: 8 }}>
          <button onClick={handleCopyHeader}
            style={{ fontSize: 11, padding: '4px 12px', borderRadius: 4, border: '1px solid #1976d2', background: '#e3f2fd', color: '#1976d2', cursor: 'pointer' }}>
            ヘッダー行をコピー
          </button>
          <span style={{ marginLeft: 8, fontSize: 11, color: '#999' }}>
            ({BULK_COLUMNS.length}列: {BULK_COLUMNS.slice(0, 5).map(c => c.label).join(', ')}...)
          </span>
        </div>

        <textarea
          value={text}
          onChange={e => { setText(e.target.value); setParsed(null); }}
          placeholder={'幹線名\t負荷名称\t電気方式\t電圧\t容量\t...\nP-1\tM1\t三相3線式\t200\t15\t...'}
          style={{
            width: '100%', height: 140, fontFamily: 'monospace', fontSize: 12,
            border: '1px solid #ccc', borderRadius: 6, padding: 8, resize: 'vertical',
            boxSizing: 'border-box'
          }}
        />

        <div style={{ display: 'flex', gap: 8, marginTop: 8, marginBottom: 16 }}>
          <button onClick={handleParse}
            style={{ padding: '6px 20px', borderRadius: 6, border: '1px solid #1976d2', background: '#1976d2', color: '#fff', cursor: 'pointer', fontWeight: 700 }}>
            解析
          </button>
          <button onClick={() => { setText(''); setParsed(null); }}
            style={{ padding: '6px 16px', borderRadius: 6, border: '1px solid #ccc', background: '#fff', cursor: 'pointer' }}>
            クリア
          </button>
        </div>

        {parsed && (
          <React.Fragment>
            <div style={{ fontSize: 13, fontWeight: 700, marginBottom: 8 }}>
              解析結果: {parsed.length}行 (有効: {validRows.length}件{parsed.length - validRows.length > 0 ? ', エラー: ' + (parsed.length - validRows.length) + '件' : ''})
            </div>
            <div style={{ maxHeight: 300, overflow: 'auto', border: '1px solid #e0e0e0', borderRadius: 6 }}>
              <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: 11 }}>
                <thead>
                  <tr style={{ background: '#f5f5f5', position: 'sticky', top: 0 }}>
                    <th style={{ padding: '4px 6px', textAlign: 'left', borderBottom: '1px solid #ccc' }}>#</th>
                    <th style={{ padding: '4px 6px', textAlign: 'left', borderBottom: '1px solid #ccc' }}>幹線名</th>
                    <th style={{ padding: '4px 6px', textAlign: 'left', borderBottom: '1px solid #ccc' }}>負荷名</th>
                    <th style={{ padding: '4px 6px', textAlign: 'left', borderBottom: '1px solid #ccc' }}>方式</th>
                    <th style={{ padding: '4px 6px', textAlign: 'right', borderBottom: '1px solid #ccc' }}>電圧</th>
                    <th style={{ padding: '4px 6px', textAlign: 'right', borderBottom: '1px solid #ccc' }}>容量</th>
                    <th style={{ padding: '4px 6px', textAlign: 'left', borderBottom: '1px solid #ccc' }}>種別</th>
                    <th style={{ padding: '4px 6px', textAlign: 'right', borderBottom: '1px solid #ccc' }}>力率</th>
                    <th style={{ padding: '4px 6px', textAlign: 'right', borderBottom: '1px solid #ccc' }}>こう長</th>
                    <th style={{ padding: '4px 6px', textAlign: 'left', borderBottom: '1px solid #ccc' }}>変圧器</th>
                    <th style={{ padding: '4px 6px', textAlign: 'left', borderBottom: '1px solid #ccc' }}>判定</th>
                  </tr>
                </thead>
                <tbody>
                  {parsed.map((row, i) => (
                    <tr key={i} style={{ background: row.errors.length > 0 ? '#ffebee' : (i % 2 === 0 ? '#fff' : '#fafafa') }}>
                      <td style={{ padding: '3px 6px' }}>{row.rowIndex}</td>
                      <td style={{ padding: '3px 6px' }}>{row.params.trunkName}</td>
                      <td style={{ padding: '3px 6px' }}>{row.params.loadName}</td>
                      <td style={{ padding: '3px 6px' }}>{row.params.system}</td>
                      <td style={{ padding: '3px 6px', textAlign: 'right' }}>{row.params.voltage}V</td>
                      <td style={{ padding: '3px 6px', textAlign: 'right' }}>{row.params.capacity}{row.params.unit}</td>
                      <td style={{ padding: '3px 6px' }}>{row.params.circuitType}</td>
                      <td style={{ padding: '3px 6px', textAlign: 'right' }}>{row.params.powerFactor}</td>
                      <td style={{ padding: '3px 6px', textAlign: 'right' }}>{row.params.cableLength}m</td>
                      <td style={{ padding: '3px 6px' }}>{row.trName || '-'}</td>
                      <td style={{ padding: '3px 6px' }}>
                        {row.errors.length > 0
                          ? <span style={{ color: '#f44336', fontWeight: 700 }} title={row.errors.join('\n')}>{'× ' + row.errors[0]}</span>
                          : row.result
                            ? <span style={{ color: row.result.ok ? '#4caf50' : '#ff9800', fontWeight: 700 }}>{row.result.ok ? '○ OK' : '△ 計算NG'}</span>
                            : <span style={{ color: '#999' }}>-</span>
                        }
                      </td>
                    </tr>
                  ))}
                </tbody>
              </table>
            </div>

            <div style={{ display: 'flex', justifyContent: 'flex-end', gap: 8, marginTop: 16 }}>
              <button onClick={onClose}
                style={{ padding: '8px 20px', borderRadius: 6, border: '1px solid #ccc', background: '#fff', cursor: 'pointer' }}>
                キャンセル
              </button>
              <button
                disabled={validRows.length === 0}
                onClick={() => { onImport(validRows); onClose(); }}
                style={{
                  padding: '8px 20px', borderRadius: 6, border: 'none', fontWeight: 700, cursor: validRows.length > 0 ? 'pointer' : 'default',
                  background: validRows.length > 0 ? '#1976d2' : '#ccc', color: '#fff'
                }}>
                取込 ({validRows.length}件)
              </button>
            </div>
          </React.Fragment>
        )}
      </div>
    </div>
  );
}

/* --- Badge コンポーネント (§11-1) --- */
function Badge({ ok, label }) {
  return (
    <span style={{
      display: 'inline-flex', alignItems: 'center', gap: 4,
      padding: '2px 8px', borderRadius: 4, fontSize: 12, fontWeight: 700,
      color: '#fff', background: ok ? '#4caf50' : '#f44336'
    }}>
      {ok ? '○' : '×'} {label}
    </span>
  );
}

/* --- Sec セクションラッパー --- */
function Sec({ title, children }) {
  return (
    <fieldset style={{
      border: '1px solid #ddd', borderRadius: 6, padding: '8px 12px',
      marginBottom: 12
    }}>
      <legend style={{ fontSize: 13, fontWeight: 700, color: '#1976d2', padding: '0 4px' }}>{title}</legend>
      {children}
    </fieldset>
  );
}

/* --- RC フォーム行コンポーネント --- */
function RC({ label, children, show = true }) {
  if (!show) return null;
  return (
    <div style={{
      display: 'flex', alignItems: 'center', marginBottom: 6, minHeight: 30
    }}>
      <label style={{ width: 130, fontSize: 13, flexShrink: 0, color: '#555' }}>{label}</label>
      <div style={{ flex: 1 }}>{children}</div>
    </div>
  );
}

/* --- セレクトボックス共通スタイル --- */
const selStyle = {
  width: '100%', padding: '4px 6px', fontSize: 13, border: '1px solid #ccc',
  borderRadius: 4, background: '#fff', outline: 'none'
};

/* --- 数値入力共通スタイル --- */
const numStyle = {
  width: '100%', padding: '4px 6px', fontSize: 13, border: '1px solid #ccc',
  borderRadius: 4, textAlign: 'right', outline: 'none'
};

/* --- SliderInput コンポーネント (§7) --- */
function SliderInput({ value, displayValue, onChange, onConfirm, cfg, min, max, style: extraStyle }) {
  const [open, setOpen] = React.useState(false);
  const [dragging, setDragging] = React.useState(false);
  const baseRef = React.useRef(value);
  const wrapRef = React.useRef(null);

  /* ポップアップ外クリックで閉じる */
  React.useEffect(() => {
    if (!open) return;
    const handler = (e) => {
      if (wrapRef.current && !wrapRef.current.contains(e.target)) { setOpen(false); }
    };
    document.addEventListener('mousedown', handler);
    return () => document.removeEventListener('mousedown', handler);
  }, [open]);

  const clamp = (v) => {
    let c = v;
    if (min !== undefined) c = Math.max(min, c);
    if (max !== undefined) c = Math.min(max, c);
    /* ステップで丸める */
    c = Math.round(c / cfg.step) * cfg.step;
    /* 浮動小数点の丸め */
    const dp = String(cfg.step).includes('.') ? String(cfg.step).split('.')[1].length : 0;
    return Number(c.toFixed(dp));
  };

  const handleSliderChange = (e) => {
    /* range: 0~200 → center=100 → offset = (v-100)/100 * range */
    const pct = (Number(e.target.value) - 100) / 100;
    const newVal = clamp(baseRef.current + pct * cfg.range);
    onChange(newVal);
  };

  const handleSliderCommit = () => {
    setDragging(false);
    onConfirm();
    baseRef.current = value;
  };

  return (
    <div ref={wrapRef} style={{ position: 'relative' }}>
      <input
        type="text"
        value={displayValue !== undefined ? displayValue : value}
        style={{ ...numStyle, ...extraStyle }}
        onChange={(e) => {
          const v = e.target.value;
          onChange(v === '' ? '' : v);
        }}
        onFocus={() => { setOpen(true); baseRef.current = value; }}
        onBlur={(e) => {
          /* スライダー操作中はblurで確定しない */
          if (dragging) return;
          if (wrapRef.current && wrapRef.current.contains(e.relatedTarget)) return;
          const n = parseFloat(displayValue !== undefined ? displayValue : value);
          if (!isNaN(n)) { onChange(clamp(n)); }
          onConfirm();
        }}
        onKeyDown={(e) => { if (e.key === 'Enter') { e.target.blur(); } }}
      />
      {open && (
        <div style={{
          position: 'absolute', top: '100%', left: 0, right: 0, zIndex: 10,
          background: '#fff', border: '1px solid #ccc', borderRadius: 4,
          padding: '6px 8px', boxShadow: '0 2px 8px rgba(0,0,0,0.15)', marginTop: 2
        }}>
          <input
            type="range" min={0} max={200} value={100}
            style={{ width: '100%', cursor: 'pointer' }}
            onMouseDown={() => { setDragging(true); baseRef.current = typeof value === 'number' ? value : parseFloat(value) || 0; }}
            onInput={handleSliderChange}
            onMouseUp={handleSliderCommit}
            onTouchStart={() => { setDragging(true); baseRef.current = typeof value === 'number' ? value : parseFloat(value) || 0; }}
            onTouchEnd={handleSliderCommit}
          />
          <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: 10, color: '#999' }}>
            <span>{clamp((typeof value === 'number' ? value : parseFloat(value) || 0) - cfg.range)}</span>
            <span>{clamp((typeof value === 'number' ? value : parseFloat(value) || 0) + cfg.range)}</span>
          </div>
        </div>
      )}
    </div>
  );
}

/* --- ProfileTab 短絡電流プロファイルカーブ (§20-4b, M2-3-P) --- */
function ProfileTab({ nodes, allResults, selectedId, onSelectNode }) {
  const [pathIdx, setPathIdx] = React.useState(0);
  const [logScale, setLogScale] = React.useState(true);
  const [showIw, setShowIw] = React.useState(true);
  const [showIcu, setShowIcu] = React.useState(true);
  const [showELCB, setShowELCB] = React.useState(false);
  const [hovered, setHovered] = React.useState(null);

  /* P2: 経路列挙と選択 */
  const allPaths = React.useMemo(() => enumerateAllPaths(nodes), [nodes]);

  /* selectedId が変わったら、そのノードを含む経路に自動切替 */
  React.useEffect(() => {
    if (!selectedId || allPaths.length === 0) return;
    const idx = allPaths.findIndex(p => p.includes(selectedId));
    if (idx >= 0 && idx !== pathIdx) setPathIdx(idx);
  }, [selectedId, allPaths]);

  const currentPath = allPaths[pathIdx] || [];
  const pathNodes = currentPath.map(id => nodes.find(n => n.id === id)).filter(Boolean);
  const pathResults = currentPath.map(id => allResults[id]).filter(Boolean);

  /* 経路切替 */
  const prevPath = () => setPathIdx(i => (i - 1 + allPaths.length) % allPaths.length);
  const nextPath = () => setPathIdx(i => (i + 1) % allPaths.length);

  /* 空状態 */
  if (allPaths.length === 0 || pathNodes.length < 2) {
    return (
      <div style={{ padding: 32, textAlign: 'center', color: '#999' }}>
        <div style={{ fontSize: 14, marginBottom: 8 }}>プロファイルを表示するには</div>
        <div style={{ fontSize: 12 }}>変圧器と2つ以上のノードを登録してください</div>
      </div>
    );
  }

  /* P3: データ準備 */
  const dataPoints = pathNodes.map((node, i) => {
    const r = allResults[node.id];
    const Isc3 = r ? r.Isc3 : null;
    const size = r ? r.size : null;
    const parallel = r ? (r.parallel || 1) : 1;
    const wt = (size && Isc3) ? checkWithstand(size, Isc3, 0.1, parallel) : null;
    const label = node.type === 'transformer'
      ? (node.transformer?.name || 'TR')
      : node.type === 'trunk'
        ? (node.trunk?.name || '幹線')
        : (node.load?.name || '負荷');
    const icuKA = r ? r.icuKA : null;
    const icuOK = r ? r.icuOK : null;
    const elcbIΔn = (r && r.elcbCheck) ? r.elcbCheck.IΔn_mA / 1000 * 1000 : null; /* in A */
    return { id: node.id, type: node.type, label, Isc3, Iw: wt ? wt.Iwithstand : null, wtOK: wt ? wt.ok : null, size, parallel, icuKA, icuOK, elcbIΔn };
  });

  const validIsc = dataPoints.filter(d => d.Isc3 != null && d.Isc3 > 0);
  if (validIsc.length === 0) {
    return (
      <div style={{ padding: 32, textAlign: 'center', color: '#999' }}>
        <div style={{ fontSize: 14, marginBottom: 8 }}>短絡電流データがありません</div>
        <div style={{ fontSize: 12 }}>変圧器を登録し、容量と%Zを設定してください</div>
      </div>
    );
  }

  /* P3: スケール計算 */
  const allValues = validIsc.map(d => d.Isc3);
  if (showIw) validIsc.forEach(d => { if (d.Iw) allValues.push(d.Iw); });
  if (showIcu) validIsc.forEach(d => { if (d.icuKA) allValues.push(d.icuKA * 1000); });
  if (showELCB) validIsc.forEach(d => { if (d.elcbIΔn) allValues.push(d.elcbIΔn); });
  const maxVal = Math.max(...allValues);
  const minVal = Math.min(...allValues.filter(v => v > 0));

  const MARGIN = { top: 40, right: 30, bottom: 60, left: 65 };
  const W = 600, H = 340;
  const plotW = W - MARGIN.left - MARGIN.right;
  const plotH = H - MARGIN.top - MARGIN.bottom;

  const n = dataPoints.length;
  const xScale = (i) => MARGIN.left + (n > 1 ? (i / (n - 1)) * plotW : plotW / 2);

  const yDomain = logScale
    ? [Math.pow(10, Math.floor(Math.log10(minVal * 0.8))), Math.pow(10, Math.ceil(Math.log10(maxVal * 1.2)))]
    : [0, maxVal * 1.2];
  const yScale = (v) => {
    if (v <= 0) return MARGIN.top + plotH;
    if (logScale) {
      const logMin = Math.log10(yDomain[0]), logMax = Math.log10(yDomain[1]);
      const t = (Math.log10(v) - logMin) / (logMax - logMin);
      return MARGIN.top + plotH * (1 - t);
    }
    return MARGIN.top + plotH * (1 - v / yDomain[1]);
  };

  /* Y軸目盛り */
  const yTicks = [];
  if (logScale) {
    const logMin = Math.floor(Math.log10(yDomain[0]));
    const logMax = Math.ceil(Math.log10(yDomain[1]));
    for (let e = logMin; e <= logMax; e++) yTicks.push(Math.pow(10, e));
  } else {
    const step = maxVal > 50 ? 20 : maxVal > 20 ? 10 : maxVal > 10 ? 5 : maxVal > 5 ? 2 : 1;
    for (let v = 0; v <= yDomain[1]; v += step) yTicks.push(v);
  }

  /* P3: Isc₃ 折れ線パスデータ */
  const iscPoints = dataPoints
    .map((d, i) => d.Isc3 != null && d.Isc3 > 0 ? { x: xScale(i), y: yScale(d.Isc3), i } : null)
    .filter(Boolean);
  const iscPath = iscPoints.map((p, j) => `${j === 0 ? 'M' : 'L'}${p.x},${p.y}`).join(' ');

  /* P4: Iw しきい値線（ノード区間ごとの水平ステップ） */
  const iwSegments = [];
  if (showIw) {
    for (let i = 0; i < dataPoints.length; i++) {
      const d = dataPoints[i];
      if (d.Iw != null && d.type !== 'transformer') {
        const x1 = i > 0 ? (xScale(i - 1) + xScale(i)) / 2 : xScale(i) - plotW / (2 * n);
        const x2 = i < dataPoints.length - 1 ? (xScale(i) + xScale(i + 1)) / 2 : xScale(i) + plotW / (2 * n);
        iwSegments.push({ x1: Math.max(x1, MARGIN.left), x2: Math.min(x2, MARGIN.left + plotW), y: yScale(d.Iw), Iw: d.Iw, label: d.label, ok: d.wtOK });
      }
    }
  }

  /* P6: 交差点検出（Isc₃ > Iw or Isc₃ > Icu の区間） */
  const violations = dataPoints.filter(d => d.Isc3 && ((d.Iw && d.Isc3 > d.Iw) || (d.icuKA && d.Isc3 > d.icuKA * 1000)));

  /* パンくず表示 */
  const breadcrumb = pathNodes.map(n => {
    if (n.type === 'transformer') return n.transformer?.name || 'TR';
    if (n.type === 'trunk') return n.trunk?.name || '幹線';
    return n.load?.name || '負荷';
  }).join(' → ');

  /* ツールチップ */
  const tooltipData = hovered != null ? dataPoints[hovered] : null;

  const fmtKA = (v) => v != null ? (v >= 1000 ? rd(v / 1000, 1) + ' kA' : rd(v) + ' A') : '—';
  const fmtIsc = (v) => v != null ? rd(v / 1000, 2) + ' kA' : '—';

  return (
    <div style={{ padding: 16, height: '100%', display: 'flex', flexDirection: 'column', overflow: 'auto' }}>
      {/* P5: 経路選択ヘッダ */}
      <div style={{ display: 'flex', alignItems: 'center', gap: 8, marginBottom: 12, flexShrink: 0 }}>
        <button onClick={prevPath} disabled={allPaths.length <= 1}
          style={{ padding: '2px 8px', fontSize: 12, border: '1px solid #ccc', borderRadius: 3, background: '#fff', cursor: 'pointer' }}>◀</button>
        <div style={{ flex: 1, fontSize: 12, color: '#333', overflow: 'hidden', textOverflow: 'ellipsis', whiteSpace: 'nowrap' }}>
          <span style={{ color: '#999', marginRight: 6 }}>経路 {pathIdx + 1}/{allPaths.length}:</span>
          {breadcrumb}
        </div>
        <button onClick={nextPath} disabled={allPaths.length <= 1}
          style={{ padding: '2px 8px', fontSize: 12, border: '1px solid #ccc', borderRadius: 3, background: '#fff', cursor: 'pointer' }}>▶</button>
      </div>

      {/* P3/P4: SVG チャート */}
      <div style={{ flex: 1, minHeight: 0, display: 'flex', justifyContent: 'center' }}>
        <svg viewBox={`0 0 ${W} ${H}`} style={{ width: '100%', maxWidth: W, height: 'auto' }}>
          {/* グリッド */}
          {yTicks.map(v => (
            <g key={v}>
              <line x1={MARGIN.left} x2={MARGIN.left + plotW} y1={yScale(v)} y2={yScale(v)}
                stroke="#e8e8e8" strokeWidth={0.5} />
              <text x={MARGIN.left - 8} y={yScale(v)} textAnchor="end" dominantBaseline="middle"
                fontSize={10} fill="#888">{v >= 1000 ? (v / 1000) + 'k' : v}</text>
            </g>
          ))}
          {/* 軸ラベル */}
          <text x={14} y={MARGIN.top + plotH / 2} textAnchor="middle" dominantBaseline="middle"
            fontSize={11} fill="#666" transform={`rotate(-90, 14, ${MARGIN.top + plotH / 2})`}>Isc₃ [kA]</text>

          {/* プロットエリア枠 */}
          <rect x={MARGIN.left} y={MARGIN.top} width={plotW} height={plotH}
            fill="none" stroke="#ccc" strokeWidth={0.5} />

          {/* P4: Iw しきい値線 */}
          {iwSegments.map((seg, i) => (
            <g key={'iw' + i}>
              <line x1={seg.x1} x2={seg.x2} y1={seg.y} y2={seg.y}
                stroke={seg.ok ? '#66bb6a' : '#ef5350'} strokeWidth={1.5} strokeDasharray="6,3" />
              {i === 0 && (
                <text x={seg.x2 + 4} y={seg.y} dominantBaseline="middle"
                  fontSize={9} fill="#66bb6a">Iw</text>
              )}
            </g>
          ))}

          {/* M2-3-B: Icu しきい値線 */}
          {showIcu && dataPoints.map((d, i) => {
            if (d.icuKA == null || d.type === 'transformer') return null;
            const icuA = d.icuKA * 1000;
            const x1 = i > 0 ? (xScale(i - 1) + xScale(i)) / 2 : xScale(i) - plotW / (2 * n);
            const x2 = i < dataPoints.length - 1 ? (xScale(i) + xScale(i + 1)) / 2 : xScale(i) + plotW / (2 * n);
            return (
              <g key={'icu' + i}>
                <line x1={Math.max(x1, MARGIN.left)} x2={Math.min(x2, MARGIN.left + plotW)}
                  y1={yScale(icuA)} y2={yScale(icuA)}
                  stroke={d.icuOK ? '#ff9800' : '#ef5350'} strokeWidth={1.5} strokeDasharray="4,4" />
                {i === 1 && (
                  <text x={Math.min(x2, MARGIN.left + plotW) + 4} y={yScale(icuA)} dominantBaseline="middle"
                    fontSize={9} fill="#ff9800">Icu</text>
                )}
              </g>
            );
          })}

          {/* M2-3-E: IΔn しきい値線 */}
          {showELCB && dataPoints.map((d, i) => {
            if (d.elcbIΔn == null || d.type === 'transformer') return null;
            const x1 = i > 0 ? (xScale(i - 1) + xScale(i)) / 2 : xScale(i) - plotW / (2 * n);
            const x2 = i < dataPoints.length - 1 ? (xScale(i) + xScale(i + 1)) / 2 : xScale(i) + plotW / (2 * n);
            return (
              <g key={'elcb' + i}>
                <line x1={Math.max(x1, MARGIN.left)} x2={Math.min(x2, MARGIN.left + plotW)}
                  y1={yScale(d.elcbIΔn)} y2={yScale(d.elcbIΔn)}
                  stroke="#9c27b0" strokeWidth={1.5} strokeDasharray="3,5" />
                {i === dataPoints.length - 1 && (
                  <text x={Math.min(x2, MARGIN.left + plotW) + 4} y={yScale(d.elcbIΔn)} dominantBaseline="middle"
                    fontSize={9} fill="#9c27b0">IΔn</text>
                )}
              </g>
            );
          })}

          {/* P3: Isc₃ 折れ線 */}
          <path d={iscPath} fill="none" stroke="#1976d2" strokeWidth={2} />

          {/* P3/P6: ノード点 */}
          {dataPoints.map((d, i) => {
            if (d.Isc3 == null || d.Isc3 <= 0) return null;
            const x = xScale(i), y = yScale(d.Isc3);
            const isViolation = (d.Iw && d.Isc3 > d.Iw) || (d.icuKA && d.Isc3 > d.icuKA * 1000);
            const isSelected = d.id === selectedId;
            return (
              <g key={d.id}
                onMouseEnter={() => setHovered(i)} onMouseLeave={() => setHovered(null)}
                onClick={() => { const node = nodes.find(n => n.id === d.id); if (node) onSelectNode(node); }}
                style={{ cursor: 'pointer' }}>
                {/* ノード点 */}
                <circle cx={x} cy={y} r={isSelected ? 6 : 4.5}
                  fill={isViolation ? '#ef5350' : '#1976d2'} stroke={isSelected ? '#0d47a1' : '#fff'} strokeWidth={isSelected ? 2 : 1.5} />
                {/* Isc₃ 値ラベル */}
                <text x={x} y={y - 10} textAnchor="middle" fontSize={9} fontWeight={600}
                  fill={isViolation ? '#c62828' : '#1565c0'}>{rd(d.Isc3 / 1000, 1)}</text>
              </g>
            );
          })}

          {/* X軸ノードラベル */}
          {dataPoints.map((d, i) => {
            const x = xScale(i);
            const typeIcon = d.type === 'transformer' ? '[TR]' : d.type === 'trunk' ? '[幹]' : '';
            return (
              <g key={'xl' + i}>
                <text x={x} y={MARGIN.top + plotH + 14} textAnchor="middle" fontSize={9} fill="#666">{typeIcon}</text>
                <text x={x} y={MARGIN.top + plotH + 26} textAnchor="middle" fontSize={9} fill="#333"
                  fontWeight={d.id === selectedId ? 700 : 400}>{d.label.length > 8 ? d.label.slice(0, 7) + '…' : d.label}</text>
                {d.size && (
                  <text x={x} y={MARGIN.top + plotH + 38} textAnchor="middle" fontSize={8} fill="#999">
                    {d.size}{d.parallel > 1 ? '×' + d.parallel : ''}sq
                  </text>
                )}
              </g>
            );
          })}

          {/* P6: ホバーツールチップ */}
          {tooltipData && (() => {
            const i = hovered;
            const x = Math.min(Math.max(xScale(i), MARGIN.left + 80), MARGIN.left + plotW - 80);
            const y = dataPoints[i].Isc3 > 0 ? yScale(dataPoints[i].Isc3) : MARGIN.top;
            const hasIcu = tooltipData.icuKA != null;
            const tipH = 64 + (hasIcu ? 12 : 0);
            const tipY = y > MARGIN.top + plotH / 2 ? y - tipH - 8 : y + 16;
            let lineY = tipY + 14;
            return (
              <g>
                <rect x={x - 75} y={tipY} width={150} height={tipH} rx={4}
                  fill="rgba(33,33,33,0.92)" stroke="none" />
                <text x={x} y={lineY} textAnchor="middle" fontSize={10} fontWeight={700} fill="#fff">{tooltipData.label}</text>
                <text x={x - 65} y={lineY += 14} fontSize={9} fill="#90caf9">Isc₃ = {fmtIsc(tooltipData.Isc3)}</text>
                {tooltipData.Iw && (
                  <text x={x - 65} y={lineY += 12} fontSize={9} fill={tooltipData.wtOK ? '#a5d6a7' : '#ef9a9a'}>
                    Iw = {fmtIsc(tooltipData.Iw)} ({tooltipData.wtOK ? '余裕 ×' + rd(tooltipData.Iw / tooltipData.Isc3, 1) : 'NG'})
                  </text>
                )}
                {hasIcu && (
                  <text x={x - 65} y={lineY += 12} fontSize={9} fill={tooltipData.icuOK ? '#ffe0b2' : '#ef9a9a'}>
                    Icu = {tooltipData.icuKA} kA ({tooltipData.icuOK ? '余裕 ×' + rd(tooltipData.icuKA * 1000 / tooltipData.Isc3, 1) : 'NG'})
                  </text>
                )}
                {tooltipData.size && (
                  <text x={x - 65} y={lineY += 12} fontSize={9} fill="#bbb">
                    {tooltipData.size}{tooltipData.parallel > 1 ? '×' + tooltipData.parallel : ''} mm²
                  </text>
                )}
              </g>
            );
          })()}
        </svg>
      </div>

      {/* P7: レイヤートグル + スケール切替 */}
      <div style={{ display: 'flex', gap: 12, alignItems: 'center', marginTop: 8, flexShrink: 0, fontSize: 12, color: '#666', flexWrap: 'wrap' }}>
        <label style={{ display: 'flex', alignItems: 'center', gap: 4, cursor: 'pointer' }}>
          <input type="checkbox" checked={showIcu} onChange={e => setShowIcu(e.target.checked)} />
          遮断容量 (Icu)
        </label>
        <label style={{ display: 'flex', alignItems: 'center', gap: 4, cursor: 'pointer' }}>
          <input type="checkbox" checked={showIw} onChange={e => setShowIw(e.target.checked)} />
          ケーブル耐量 (Iw)
        </label>
        <label style={{ display: 'flex', alignItems: 'center', gap: 4, cursor: 'pointer' }}>
          <input type="checkbox" checked={showELCB} onChange={e => setShowELCB(e.target.checked)} />
          ELCB感度 (IΔn)
        </label>
        <div style={{ marginLeft: 'auto', display: 'flex', gap: 4 }}>
          <button onClick={() => setLogScale(true)}
            style={{ padding: '2px 8px', fontSize: 11, border: logScale ? '1px solid #1976d2' : '1px solid #ccc',
              borderRadius: 3, background: logScale ? '#e3f2fd' : '#fff', color: logScale ? '#1976d2' : '#666', cursor: 'pointer' }}>対数</button>
          <button onClick={() => setLogScale(false)}
            style={{ padding: '2px 8px', fontSize: 11, border: !logScale ? '1px solid #1976d2' : '1px solid #ccc',
              borderRadius: 3, background: !logScale ? '#e3f2fd' : '#fff', color: !logScale ? '#1976d2' : '#666', cursor: 'pointer' }}>線形</button>
        </div>
      </div>

      {/* 警告サマリー */}
      {violations.length > 0 && (
        <div style={{ marginTop: 8, padding: '8px 12px', background: '#fff3e0', borderRadius: 4, border: '1px solid #ffe0b2', fontSize: 12, flexShrink: 0 }}>
          <span style={{ color: '#e65100', fontWeight: 700 }}>保護能力超過: </span>
          {violations.map(v => {
            const issues = [];
            if (v.Iw && v.Isc3 > v.Iw) issues.push('Isc₃ > Iw');
            if (v.icuKA && v.Isc3 > v.icuKA * 1000) issues.push('Isc₃ > Icu');
            return v.label + ' (' + issues.join(', ') + ')';
          }).join(', ')}
        </div>
      )}
    </div>
  );
}

/* --- ResultPanel 選定結果パネル (§11) --- */
function ResultPanel({ result, params }) {
  if (!result) return <div style={{ color: '#999', padding: 16 }}>入力を完了すると結果が表示されます</div>;
  const r = result;
  const isTrunk = r.hasMotor !== undefined;
  const isMotor = isTrunk ? r.hasMotor : params.circuitType === '電動機';

  const panelStyle = {
    background: '#fff', border: '1px solid #e0e0e0', borderRadius: 8,
    padding: 16, marginBottom: 16, borderLeft: `4px solid ${r.ok ? '#4caf50' : '#f44336'}`
  };
  const rowStyle = { display: 'flex', gap: 12, padding: '8px 0', borderBottom: '1px solid #f0f0f0' };
  const cellStyle = { flex: 1, minWidth: 0 };
  const sectionTitle = { fontSize: 13, fontWeight: 700, color: '#1976d2', marginBottom: 4 };
  const dtStyle = { fontSize: 11, color: '#888', marginBottom: 1 };
  const ddStyle = { fontSize: 16, fontWeight: 700 };
  const detailRow = { display: 'flex', justifyContent: 'space-between', fontSize: 12, padding: '2px 0', color: '#555' };

  return (
    <div style={panelStyle}>
      {/* 1段目: [総合判定] [選定ケーブル, MCCB定格, 設計電流] */}
      <div style={rowStyle}>
        <div style={{ display: 'flex', flexDirection: 'column', justifyContent: 'center', minWidth: 60 }}>
          <span style={{
            fontSize: 20, fontWeight: 700, textAlign: 'center',
            color: r.ok ? '#4caf50' : '#f44336'
          }}>{r.ok ? 'OK' : 'NG'}</span>
          <span style={{ fontSize: 10, color: '#888', textAlign: 'center' }}>総合判定</span>
        </div>
        <div style={{ display: 'flex', gap: 16, flex: 1 }}>
          <div style={cellStyle}>
            <div style={dtStyle}>選定ケーブル</div>
            <div style={ddStyle}>{params.cableType} {r.size}{r.parallel > 1 ? `×${r.parallel}` : ''} mm²</div>
          </div>
          <div style={cellStyle}>
            <div style={dtStyle}>MCCB 定格</div>
            <div style={ddStyle}>{r.mccbAT} AT</div>
          </div>
          <div style={cellStyle}>
            <div style={dtStyle}>設計電流</div>
            <div style={ddStyle}>{r.dI} A</div>
          </div>
        </div>
      </div>
      {isTrunk && r.hasMotor && (
        <div style={{ fontSize: 11, color: '#666', background: '#f5f5f5', borderRadius: 4, padding: '3px 8px', marginBottom: 4 }}>
          電動機 {r.sumIM}A × {r.sumIM <= 50 ? '1.25' : '1.1'} + 一般 {r.sumIH}A = {r.sizingI}A
        </div>
      )}
      {!isTrunk && isMotor && (
        <div style={{ fontSize: 11, color: '#666', background: '#f5f5f5', borderRadius: 4, padding: '3px 8px', marginBottom: 4 }}>
          サイジング電流: {r.sizingI} A（{r.dI <= 50 ? '×1.25' : '×1.1'} 補正）
        </div>
      )}

      {/* 2段目: [許容電流] [電圧降下] */}
      <div style={rowStyle}>
        <div style={cellStyle}>
          <div style={{ display: 'flex', alignItems: 'center', gap: 6, marginBottom: 4 }}>
            <Badge ok={r.ampacityOK} label="許容電流" />
          </div>
          <div style={detailRow}><span>基本許容電流</span><span>{r.baseAmpacity} A</span></div>
          <div style={detailRow}><span>温度補正</span><span>{r.tempFactor}</span></div>
          <div style={detailRow}><span>低減率</span><span>{r.reductionFactor}</span></div>
          <div style={{ ...detailRow, fontWeight: 700 }}>
            <span>実効許容電流</span>
            <span style={{ color: r.ampacityOK ? '#4caf50' : '#f44336' }}>{r.effectiveAmpacity} A</span>
          </div>
        </div>
        <div style={cellStyle}>
          <div style={{ display: 'flex', alignItems: 'center', gap: 6, marginBottom: 4 }}>
            <Badge ok={r.vdOK} label="電圧降下" />
          </div>
          <div style={detailRow}><span>Z</span><span>{r.Z} Ω/km</span></div>
          <div style={detailRow}><span>方式係数 K</span><span>{rd(r.K, 4)}</span></div>
          <div style={{ ...detailRow, fontWeight: 700, color: r.vdOK ? '#4caf50' : '#f44336' }}>
            <span>降下量</span><span>{r.vd} V ({r.vdPercent}%)</span>
          </div>
          <div style={detailRow}><span>許容値</span><span>{r.allowVd} V ({r.allowVdPercent}%)</span></div>
        </div>
      </div>

      {/* 3段目: [保護協調] [累積電圧降下] */}
      <div style={{ ...rowStyle, borderBottom: 'none' }}>
        <div style={cellStyle}>
          <div style={{ display: 'flex', alignItems: 'center', gap: 6, marginBottom: 4 }}>
            <Badge ok={r.protOK} label="保護協調" />
          </div>
          <div style={detailRow}><span>MCCB 定格</span><span>{r.mccbAT} AT</span></div>
          {isMotor && (
            <div style={detailRow}><span>閾値 (AT/2.5)</span><span>{rd(r.mccbAT / 2.5)} A</span></div>
          )}
          <div style={{ ...detailRow, fontWeight: 700 }}>
            <span>実効許容電流</span>
            <span style={{ color: r.protOK ? '#4caf50' : '#f44336' }}>
              {r.effectiveAmpacity} A {isMotor ? `≧ ${rd(r.mccbAT / 2.5)} A` : `≧ ${r.mccbAT} A`}
            </span>
          </div>
        </div>
        <div style={cellStyle}>
          {r.cumulativeVd != null && r.cumulativeVd > 0 ? (
            <React.Fragment>
              <div style={{ fontSize: 13, fontWeight: 700, color: '#1976d2', marginBottom: 4 }}>累積電圧降下</div>
              <div style={{ ...detailRow, fontWeight: 700 }}>
                <span>変圧器からの累積</span>
                <span>{r.cumulativeVd} V ({r.cumulativeVdP}%)</span>
              </div>
            </React.Fragment>
          ) : (
            <React.Fragment>
              <div style={{ fontSize: 13, fontWeight: 700, color: '#ccc', marginBottom: 4 }}>累積電圧降下</div>
              <div style={{ fontSize: 12, color: '#ccc' }}>—</div>
            </React.Fragment>
          )}
        </div>
      </div>

      {/* 短絡電流（変圧器接続時） */}
      {r.Isc3 != null && (
        <div style={{ borderTop: '1px solid #f0f0f0', paddingTop: 8, marginTop: 4 }}>
          <div style={sectionTitle}>短絡電流</div>
          <div style={{ display: 'flex', gap: 12 }}>
            <div style={cellStyle}>
              <div style={detailRow}><span>Isc₃</span><span>{rd(r.Isc3 / 1000, 1)} kA</span></div>
              <div style={detailRow}><span>累積 R</span><span>{rd(r.Rcum * 1000, 2)} mΩ</span></div>
              <div style={detailRow}><span>累積 X</span><span>{rd(r.Xcum * 1000, 2)} mΩ</span></div>
            </div>
            <div style={cellStyle}>
              {r.size && (() => {
                const wt = checkWithstand(r.size, r.Isc3, 0.1, r.parallel);
                return (
                  <React.Fragment>
                    <div style={detailRow}><span>耐電流 (K=134, t=0.1s)</span><span>{rd(wt.Iwithstand / 1000, 1)} kA</span></div>
                    <div style={{ ...detailRow, fontWeight: 700 }}>
                      <span>熱耐量</span>
                      <span><Badge ok={wt.ok} label={wt.ok ? 'OK' : 'NG'} /></span>
                    </div>
                  </React.Fragment>
                );
              })()}
              {r.icuKA != null && (
                <div style={{ ...detailRow, fontWeight: 700, marginTop: 4 }}>
                  <span>遮断容量 Icu</span>
                  <span>{r.icuKA} kA <Badge ok={r.icuOK} label={r.icuOK ? 'OK' : 'NG'} /></span>
                </div>
              )}
            </div>
          </div>
        </div>
      )}

      {/* 地絡保護（ELCB 設定回路のみ） */}
      {r.elcbCheck && (
        <div style={{ borderTop: '1px solid #f0f0f0', paddingTop: 8, marginTop: 4 }}>
          <div style={sectionTitle}>地絡保護</div>
          <div style={detailRow}>
            <span>ELCB 感度 IΔn</span>
            <span>{r.elcbCheck.IΔn_mA} mA</span>
          </div>
          {r.elcbCheck.method === 'TT' && (
            <React.Fragment>
              <div style={{ ...detailRow, fontWeight: 700 }}>
                <span>接触電圧 RA×IΔn</span>
                <span>{r.elcbCheck.touchV} V <Badge ok={r.elcbCheck.ok} label={r.elcbCheck.ok ? 'OK' : 'NG'} /></span>
              </div>
              <div style={{ fontSize: 11, color: '#888', marginTop: 2 }}>{r.elcbCheck.formula}</div>
            </React.Fragment>
          )}
          {r.lvGroundFault && (
            <div style={detailRow}>
              <span>LV側地絡電流</span>
              <span>{r.lvGroundFault.Ig_lv} A</span>
            </div>
          )}
        </div>
      )}

      {/* 電気方式/電圧 親子不一致警告 */}
      {r.systemMismatch && (
        <div style={{ borderTop: '1px solid #f0f0f0', paddingTop: 8, marginTop: 4 }}>
          <div style={{ display: 'flex', alignItems: 'center', gap: 6, marginBottom: 4 }}>
            <Badge ok={false} label="方式不一致" />
          </div>
          <div style={{ fontSize: 12, color: '#e65100', padding: '4px 8px', background: '#fff3e0', borderRadius: 4 }}>
            {r.systemMismatchDetail}
          </div>
        </div>
      )}
    </div>
  );
}

/* --- TransformerResultPanel 変圧器結果パネル (§19-3) --- */
function TransformerResultPanel({ result, nodes, nodeId, allResults }) {
  if (!result) return null;
  const r = result;
  const cardStyle = { background: '#fff', border: '1px solid #e0e0e0', borderRadius: 8, padding: 16, marginBottom: 16 };
  const dtStyle = { fontSize: 12, color: '#888', marginBottom: 2 };
  const ddStyle = { fontSize: 18, fontWeight: 700, marginBottom: 8 };
  const detailRow = { display: 'flex', justifyContent: 'space-between', fontSize: 13, padding: '3px 0', borderBottom: '1px solid #f0f0f0' };

  let utilization = 0;
  if (nodeId) {
    const allLoads = getDescendants(nodes, nodeId).filter(n => n.type === 'load');
    let totalKW = 0;
    for (const l of allLoads) {
      totalKW += (l.load.capacity || 0) * (l.load.demandFactor || 100) / 100;
    }
    utilization = r.capacity_kVA > 0 ? totalKW / r.capacity_kVA * 100 : 0;
  }

  return (
    <div>
      <div style={cardStyle}>
        <div style={{ display: 'flex', gap: 16 }}>
          <div style={{ flex: 1 }}>
            <div style={dtStyle}>定格二次電流</div>
            <div style={ddStyle}>{rd(r.In)} A</div>
          </div>
          <div style={{ flex: 1 }}>
            <div style={dtStyle}>短絡電流 Isc₃</div>
            <div style={ddStyle}>{rd(r.Isc3 / 1000, 1)} kA</div>
          </div>
          <div style={{ flex: 1 }}>
            <div style={dtStyle}>利用率</div>
            <div style={ddStyle}>{rd(utilization)}%</div>
          </div>
        </div>
      </div>
      <div style={cardStyle}>
        <div style={{ fontSize: 13, fontWeight: 700, marginBottom: 8, color: '#1976d2' }}>ソースインピーダンス</div>
        <div style={detailRow}><span>Rs</span><span>{rd(r.Rs * 1000, 2)} mΩ</span></div>
        <div style={detailRow}><span>Xs</span><span>{rd(r.Xs * 1000, 2)} mΩ</span></div>
        <div style={{ ...detailRow, borderBottom: 'none' }}><span>|Zs|</span><span>{rd(r.Zs * 1000, 2)} mΩ</span></div>
      </div>
      {r.groundFault && (
        <div style={cardStyle}>
          <div style={{ fontSize: 13, fontWeight: 700, marginBottom: 8, color: '#1976d2' }}>接地設計</div>
          <div style={detailRow}><span>一線地絡電流 Ig</span><span>{r.groundFault.Ig} A</span></div>
          <div style={detailRow}>
            <span>B種接地抵抗上限</span>
            <span>
              {r.groundFault.vcbTripTime_s <= 0.5
                ? r.groundFault.Rb_05s + ' Ω (150/Ig)'
                : r.groundFault.vcbTripTime_s <= 1.0
                  ? r.groundFault.Rb_1s + ' Ω (600/Ig)'
                  : r.groundFault.Rb_2s + ' Ω (300/Ig)'}
            </span>
          </div>
          <div style={{ fontSize: 11, color: '#888', marginTop: 4 }}>
            Ig = 3ωCV = 3 × 2π × f × C × V/√3
          </div>
        </div>
      )}
    </div>
  );
}

/* --- TransformerForm 変圧器入力フォーム (§19-1) --- */
function TransformerForm({ trParams, setTrParams, onSave, onCancel, isEdit }) {
  const getCapacities = (trType) => {
    if (trType === '三相油入') return TR_RATINGS.three_phase_oil.capacities_kVA;
    if (trType === '単相油入') return TR_RATINGS.single_phase_oil.capacities_kVA;
    if (trType === 'モールド') return TR_RATINGS.mold.capacities_kVA;
    return TR_RATINGS.three_phase_oil.capacities_kVA;
  };

  const getAutoValues = (trType, kVA) => {
    const key = String(kVA);
    if (trType === '三相油入' && TR_RATINGS.three_phase_oil.data[key]) {
      const d = TR_RATINGS.three_phase_oil.data[key];
      return { pctZ: d.pct_z, xrRatio: d.xr_ratio };
    }
    if (trType === '単相油入' && TR_RATINGS.single_phase_oil.data[key]) {
      const d = TR_RATINGS.single_phase_oil.data[key];
      return { pctZ: d.pct_z, xrRatio: d.xr_ratio };
    }
    if (trType === 'モールド' && TR_RATINGS.mold.data[key]) {
      const d = TR_RATINGS.mold.data[key];
      return { pctZ: d.pct_z_min, xrRatio: null };
    }
    return { pctZ: 4.00, xrRatio: null };
  };

  const handleTypeChange = (val) => {
    const caps = getCapacities(val);
    const kVA = caps.includes(trParams.capacity_kVA) ? trParams.capacity_kVA : caps[0];
    const auto = getAutoValues(val, kVA);
    setTrParams(p => ({
      ...p, trType: val, capacity_kVA: kVA,
      ...(p.pctZAuto ? { pctZ: auto.pctZ, xrRatio: auto.xrRatio } : {})
    }));
  };

  const handleCapacityChange = (val) => {
    const kVA = Number(val);
    const auto = getAutoValues(trParams.trType, kVA);
    setTrParams(p => ({
      ...p, capacity_kVA: kVA,
      ...(p.pctZAuto ? { pctZ: auto.pctZ, xrRatio: auto.xrRatio } : {})
    }));
  };

  const capacities = getCapacities(trParams.trType);

  return (
    <div>
      <Sec title="変圧器情報">
        <RC label="変圧器名称">
          <input type="text" value={trParams.name} style={{ ...numStyle, textAlign: 'left' }}
            onChange={e => setTrParams(p => ({ ...p, name: e.target.value }))} />
        </RC>
        <RC label="種別">
          <select value={trParams.trType} style={selStyle} onChange={e => handleTypeChange(e.target.value)}>
            <option>三相油入</option><option>単相油入</option><option>モールド</option>
          </select>
        </RC>
        <RC label="容量 [kVA]">
          <select value={trParams.capacity_kVA} style={selStyle} onChange={e => handleCapacityChange(e.target.value)}>
            {capacities.map(c => <option key={c} value={c}>{c}</option>)}
          </select>
        </RC>
        <RC label="一次電圧 [V]">
          <select value={trParams.primaryV} style={selStyle} onChange={e => setTrParams(p => ({ ...p, primaryV: Number(e.target.value) }))}>
            <option value={3300}>3300</option><option value={6600}>6600</option>
          </select>
        </RC>
        <RC label="二次電圧 [V]">
          <select value={trParams.secondaryV} style={selStyle} onChange={e => setTrParams(p => ({ ...p, secondaryV: Number(e.target.value) }))}>
            <option value={105}>105</option><option value={210}>210</option><option value={420}>420</option>
          </select>
        </RC>
        <RC label="%Z">
          <div style={{ display: 'flex', gap: 6, alignItems: 'center' }}>
            <input type="number" step="0.01" value={trParams.pctZ} style={{ ...numStyle, flex: 1 }}
              disabled={trParams.pctZAuto}
              onChange={e => setTrParams(p => ({ ...p, pctZ: parseFloat(e.target.value) || 0 }))} />
            <label style={{ fontSize: 12, whiteSpace: 'nowrap' }}>
              <input type="checkbox" checked={trParams.pctZAuto}
                onChange={e => {
                  const auto = e.target.checked;
                  const vals = getAutoValues(trParams.trType, trParams.capacity_kVA);
                  setTrParams(p => ({ ...p, pctZAuto: auto, ...(auto ? { pctZ: vals.pctZ, xrRatio: vals.xrRatio } : {}) }));
                }} /> Auto
            </label>
          </div>
          {trParams.trType === 'モールド' && (
            <div style={{ fontSize: 11, color: '#888', marginTop: 2 }}>
              ※ モールド: 短絡電流計算は最小値を使用
            </div>
          )}
        </RC>
        <RC label="X/R 比">
          <input type="number" step="0.01" value={trParams.xrRatio != null ? trParams.xrRatio : ''} style={numStyle}
            disabled={trParams.pctZAuto && trParams.trType !== 'モールド'}
            onChange={e => setTrParams(p => ({ ...p, xrRatio: e.target.value === '' ? null : parseFloat(e.target.value) }))} />
        </RC>
        <RC label="結線方式">
          <select value={trParams.connection} style={selStyle}
            onChange={e => setTrParams(p => ({ ...p, connection: e.target.value }))}>
            {['Δ-Y', 'Y-Y', 'Δ-Δ', 'Y-Δ', 'V-V'].map(c => <option key={c}>{c}</option>)}
          </select>
        </RC>
      </Sec>
      <Sec title="高圧系統（受電側）">
        <RC label="HV ケーブル種別">
          <select value={trParams.hvSystem?.cableType || ''} style={selStyle}
            onChange={e => {
              const ct = e.target.value || null;
              const sizes = ct && IMP_HV[ct] ? IMP_HV[ct].sizes_mm2 : [];
              const sz = sizes.length > 0 ? sizes[Math.floor(sizes.length / 2)] : null;
              const cap = ct && sz && C_CABLE[ct] ? C_CABLE[ct][String(sz)] || null : null;
              setTrParams(p => ({ ...p, hvSystem: { ...p.hvSystem, cableType: ct, cableSize_mm2: sz, capacitance_uF_per_km: cap } }));
            }}>
            <option value="">未設定</option>
            <option value="CV-3C">CV-3C</option>
            <option value="CVT">CVT</option>
          </select>
        </RC>
        <RC label="ケーブルサイズ [mm²]" show={!!trParams.hvSystem?.cableType}>
          <select value={trParams.hvSystem?.cableSize_mm2 || ''} style={selStyle}
            onChange={e => {
              const sz = Number(e.target.value);
              const ct = trParams.hvSystem?.cableType;
              const cap = ct && C_CABLE[ct] ? C_CABLE[ct][String(sz)] || null : null;
              setTrParams(p => ({ ...p, hvSystem: { ...p.hvSystem, cableSize_mm2: sz, capacitance_uF_per_km: cap } }));
            }}>
            {(trParams.hvSystem?.cableType && IMP_HV[trParams.hvSystem.cableType]
              ? IMP_HV[trParams.hvSystem.cableType].sizes_mm2
              : []).map(s => <option key={s} value={s}>{s}</option>)}
          </select>
        </RC>
        <RC label="こう長 [km]" show={!!trParams.hvSystem?.cableType}>
          <input type="number" step="0.01" min="0" value={trParams.hvSystem?.totalCableLength_km || ''} style={numStyle}
            onChange={e => setTrParams(p => ({ ...p, hvSystem: { ...p.hvSystem, totalCableLength_km: parseFloat(e.target.value) || null } }))} />
        </RC>
        <RC label="対地静電容量 [μF/km]" show={!!trParams.hvSystem?.cableType}>
          <input type="number" step="0.01" min="0" value={trParams.hvSystem?.capacitance_uF_per_km || ''} style={numStyle}
            onChange={e => setTrParams(p => ({ ...p, hvSystem: { ...p.hvSystem, capacitance_uF_per_km: parseFloat(e.target.value) || null } }))} />
        </RC>
        <RC label="VCB 遮断時間 [s]" show={!!trParams.hvSystem?.cableType}>
          <select value={trParams.hvSystem?.vcbTripTime_s || 1.0} style={selStyle}
            onChange={e => setTrParams(p => ({ ...p, hvSystem: { ...p.hvSystem, vcbTripTime_s: parseFloat(e.target.value) } }))}>
            <option value={0.5}>0.5 秒以内</option>
            <option value={1.0}>1.0 秒以内</option>
            <option value={2.0}>2.0 秒以内</option>
          </select>
        </RC>
      </Sec>
      <div style={{ display: 'flex', gap: 8 }}>
        <button onClick={onSave} style={{
          flex: 1, padding: '10px', borderRadius: 6, border: 'none',
          background: '#1976d2', color: '#fff', fontSize: 14, fontWeight: 700, cursor: 'pointer'
        }}>{isEdit ? '更新' : '+ 変圧器登録'}</button>
        {isEdit && (
          <button onClick={onCancel} style={{
            padding: '10px 16px', borderRadius: 6, border: '1px solid #ccc',
            background: '#fff', color: '#666', fontSize: 14, cursor: 'pointer'
          }}>取消</button>
        )}
      </div>
    </div>
  );
}

/* --- TrunkForm 幹線入力フォーム (§9-6) --- */
function TrunkForm({ trunkParams, setTrunkParams, onSave, onCancel, isEdit, childSummary }) {
  const isCustomReduction = trunkParams.reductionPreset === 'カスタム';
  return (
    <div>
      <Sec title="幹線情報">
        <RC label="幹線名称">
          <input type="text" value={trunkParams.name} style={{ ...numStyle, textAlign: 'left' }}
            onChange={e => setTrunkParams(p => ({ ...p, name: e.target.value }))} />
        </RC>
        <RC label="電気方式">
          <span style={{ fontSize: 13 }}>{trunkParams.system} {trunkParams.voltage}V</span>
        </RC>
      </Sec>
      <Sec title="ケーブル条件">
        <RC label="こう長 [m]">
          <input type="number" step="0.5" value={trunkParams.cableLength} style={numStyle}
            onChange={e => setTrunkParams(p => ({ ...p, cableLength: parseFloat(e.target.value) || 0 }))} />
        </RC>
        <RC label="力率 cosθ">
          <input type="number" step="0.01" min="0.10" max="1.00" value={trunkParams.powerFactor} style={numStyle}
            onChange={e => setTrunkParams(p => ({ ...p, powerFactor: parseFloat(e.target.value) || 0.85 }))} />
        </RC>
        <RC label="ケーブル種類">
          <select value={trunkParams.cableType} style={selStyle}
            onChange={e => setTrunkParams(p => ({ ...p, cableType: e.target.value }))}>
            {getCableTypeOptions(trunkParams.system).map(c => <option key={c}>{c}</option>)}
          </select>
        </RC>
        <RC label="配線方式">
          <select value={trunkParams.wiringMethod} style={selStyle}
            onChange={e => setTrunkParams(p => ({ ...p, wiringMethod: e.target.value }))}>
            {['ケーブルラック配線', '配管配線', '直埋布設', '管路布設'].map(w => <option key={w}>{w}</option>)}
          </select>
        </RC>
        <RC label="周囲温度 [℃]">
          <input type="number" step="5" min="20" max="50" value={trunkParams.ambientTemp} style={numStyle}
            onChange={e => setTrunkParams(p => ({ ...p, ambientTemp: Number(e.target.value) }))} />
        </RC>
        <RC label="多条低減プリセット">
          <select value={trunkParams.reductionPreset} style={selStyle}
            onChange={e => {
              const val = e.target.value;
              const preset = RED_PRE.find(p => p.label === val);
              setTrunkParams(p => ({ ...p, reductionPreset: val, ...(preset && preset.factor !== null ? { reductionFactor: preset.factor } : {}) }));
            }}>
            {RED_PRE.map(p => <option key={p.label} value={p.label}>{p.label}{p.factor !== null ? ` (${p.factor})` : ''}</option>)}
          </select>
        </RC>
        {isCustomReduction && (
          <RC label="低減率">
            <input type="number" step="0.01" min="0.10" max="1.00" value={trunkParams.reductionFactor} style={numStyle}
              onChange={e => setTrunkParams(p => ({ ...p, reductionFactor: parseFloat(e.target.value) || 0.70 }))} />
          </RC>
        )}
        {!isCustomReduction && (
          <RC label="低減率">
            <span style={{ fontSize: 13 }}>{trunkParams.reductionFactor}</span>
          </RC>
        )}
        <RC label="MCCB AT">
          <select value={trunkParams.mccbATOverride} style={selStyle}
            onChange={e => setTrunkParams(p => ({ ...p, mccbATOverride: e.target.value }))}>
            <option>自動</option>
            {MCCB_AT.map(at => <option key={at} value={at}>{at} AT</option>)}
          </select>
        </RC>
        <RC label="遮断容量クラス">
          <select value={trunkParams.icuClass || 'standard'} style={selStyle}
            onChange={e => setTrunkParams(p => ({ ...p, icuClass: e.target.value }))}>
            <option value="standard">経済型 (standard)</option>
            <option value="high">高遮断型 (high)</option>
          </select>
        </RC>
      </Sec>
      {childSummary && (
        <div style={{ fontSize: 12, color: '#666', background: '#f5f5f5', borderRadius: 4, padding: 8, marginBottom: 12 }}>
          子回路合計: 電動機 {childSummary.sumIM.toFixed(1)}A + 一般 {childSummary.sumIH.toFixed(1)}A = {childSummary.totalI.toFixed(1)}A
        </div>
      )}
      <div style={{ display: 'flex', gap: 8 }}>
        <button onClick={onSave} style={{
          flex: 1, padding: '10px', borderRadius: 6, border: 'none',
          background: '#1976d2', color: '#fff', fontSize: 14, fontWeight: 700, cursor: 'pointer'
        }}>{isEdit ? '幹線を更新' : '+ 幹線登録'}</button>
        {isEdit && (
          <button onClick={onCancel} style={{
            padding: '10px 16px', borderRadius: 6, border: '1px solid #ccc',
            background: '#fff', color: '#666', fontSize: 14, cursor: 'pointer'
          }}>取消</button>
        )}
      </div>
    </div>
  );
}

/* --- TreeTable 登録一覧ツリー表示 (§12) --- */
function TreeTable({ nodes, allResults, selectedId, onSelect, onDelete, onAddChild, groups, crossLinks, onToggleGroupCollapse }) {
  const [collapsedGroups, setCollapsedGroups] = React.useState({});

  if (nodes.length === 0) return (
    <div style={{ color: '#999', padding: 16, fontSize: 13 }}>
      変圧器または負荷回路を登録してください
    </div>
  );

  const tree = buildTree(nodes);
  const grps = groups || [];
  const links = crossLinks || [];

  /* グループごとにルートノードを分類 */
  const groupedRoots = new Map();
  const ungroupedRoots = [];
  tree.forEach(root => {
    const grp = grps.find(g => g.rootNodeId === root.id);
    if (grp) {
      if (!groupedRoots.has(grp.id)) groupedRoots.set(grp.id, { group: grp, roots: [] });
      groupedRoots.get(grp.id).roots.push(root);
    } else {
      ungroupedRoots.push(root);
    }
  });

  const toggleCollapse = (grpId) => setCollapsedGroups(prev => ({ ...prev, [grpId]: !prev[grpId] }));

  const renderNode = (node, depth) => {
    const r = allResults[node.id];
    const isSelected = node.id === selectedId;
    const isTr = node.type === 'transformer';
    const isTrunk = node.type === 'trunk';
    const bgColor = isSelected ? '#e3f2fd' : isTr ? '#e8eaf6' : isTrunk ? '#f5f5f5' : '#fff';
    const tag = isTr ? '[TR]' : isTrunk ? '[主幹]' : '└';
    const name = isTr ? (node.transformer?.name || 'TR')
      : isTrunk ? (node.trunk?.name || '幹線')
      : (node.load?.loadName || '負荷');
    const sysV = isTr ? `${node.transformer?.secondaryV || ''}V`
      : isTrunk ? `${node.trunk?.system || ''} ${node.trunk?.voltage || ''}V`
      : `${node.load?.system || ''} ${node.load?.voltage || ''}V`;
    const cType = isTrunk ? (node.trunk?.cableType || '') : (node.load?.cableType || '');

    return (
      <React.Fragment key={node.id}>
        <tr onClick={() => onSelect(node)}
          style={{ background: bgColor, cursor: 'pointer', borderBottom: '1px solid #eee' }}>
          <td style={{ padding: '6px 4px', paddingLeft: 8 + depth * 20, fontSize: 12, whiteSpace: 'nowrap' }}>
            <span style={{
              display: 'inline-block', padding: '1px 4px', borderRadius: 3, fontSize: 11,
              fontWeight: 700, marginRight: 4,
              background: isTr ? '#3f51b5' : isTrunk ? '#78909c' : 'transparent',
              color: isTr || isTrunk ? '#fff' : '#999'
            }}>{tag}</span>
            {name}
          </td>
          <td style={{ padding: '6px 4px', fontSize: 12 }}>{sysV}</td>
          <td style={{ padding: '6px 4px', fontSize: 12, textAlign: 'right' }}>
            {r && r.dI != null ? `${r.dI}A` : r && r.In != null ? `${rd(r.In)}A` : '-'}
          </td>
          <td style={{ padding: '6px 4px', fontSize: 12 }}>
            {r && r.size ? `${cType} ${r.size}${r.parallel > 1 ? '×' + r.parallel : ''}` : '-'}
          </td>
          <td style={{ padding: '6px 4px', fontSize: 12, textAlign: 'right' }}>
            {r && r.mccbAT ? `${r.mccbAT}` : '-'}
          </td>
          <td style={{ padding: '6px 4px', fontSize: 12, textAlign: 'right' }}>
            {r && r.vd != null ? `${r.vd}V (${r.vdPercent}%)` : '-'}
          </td>
          <td style={{ padding: '6px 4px', fontSize: 12 }}>
            {r && r.ok != null ? <Badge ok={r.ok} label={r.systemMismatch ? '方式NG' : (r.ok ? 'OK' : 'NG')} /> : '-'}
          </td>
          <td style={{ padding: '6px 4px', fontSize: 12, textAlign: 'right' }}>
            {r && r.Isc3 ? `${rd(r.Isc3 / 1000, 1)}kA` : '-'}
          </td>
          <td style={{ padding: '6px 2px', whiteSpace: 'nowrap' }}>
            {(isTr || (isTrunk && depth < 2)) && onAddChild && (
              <button onClick={e => { e.stopPropagation(); onAddChild(node); }}
                style={{ border: 'none', background: 'none', color: '#1976d2', cursor: 'pointer', fontSize: 14, padding: '2px 6px', fontWeight: 700 }}>+</button>
            )}
            <button onClick={e => { e.stopPropagation(); onDelete(node.id); }}
              style={{ border: 'none', background: 'none', color: '#f44336', cursor: 'pointer', fontSize: 14, padding: '2px 6px' }}>×</button>
          </td>
        </tr>
        {node.children && node.children.map(child => renderNode(child, depth + 1))}
      </React.Fragment>
    );
  };

  const renderGroupHeader = (grp) => {
    const isCollapsed = collapsedGroups[grp.id];
    const memberNodes = getGroupNodes(nodes, grp.rootNodeId);
    const circuitCount = memberNodes.filter(n => n.type === 'load').length;
    const trunkCount = memberNodes.filter(n => n.type === 'trunk').length;
    /* グループ全体の判定サマリー */
    const allOk = memberNodes.every(n => {
      const r = allResults[n.id];
      return !r || r.ok == null || r.ok;
    });
    /* このグループに接続されているクロスリンク */
    const incomingLinks = links.filter(cl => cl.toGroupId === grp.id);
    const outgoingLinks = links.filter(cl => cl.fromGroupId === grp.id);

    return (
      <React.Fragment key={'grp-' + grp.id}>
        <tr onClick={() => toggleCollapse(grp.id)}
          style={{ background: grp.color || '#e3f2fd', cursor: 'pointer', borderBottom: '2px solid #bbb', borderTop: '2px solid #bbb' }}>
          <td colSpan={7} style={{ padding: '8px 8px', fontSize: 13, fontWeight: 700 }}>
            <span style={{ marginRight: 8, fontSize: 10, color: '#666' }}>{isCollapsed ? '▶' : '▼'}</span>
            {grp.name}
            <span style={{ marginLeft: 12, fontSize: 11, fontWeight: 400, color: '#666' }}>
              ({trunkCount}幹線 {circuitCount}回路)
            </span>
          </td>
          <td style={{ padding: '6px 4px', fontSize: 12 }}>
            {memberNodes.length > 0 && <Badge ok={allOk} label={allOk ? 'OK' : 'NG'} />}
          </td>
          <td style={{ padding: '6px 2px' }}></td>
        </tr>
        {/* クロスリンク表示 */}
        {incomingLinks.map(cl => {
          const fromGrp = grps.find(g => g.id === cl.fromGroupId);
          return (
            <tr key={'cl-in-' + cl.id} style={{ background: '#fffde7', borderBottom: '1px solid #eee' }}>
              <td colSpan={9} style={{ padding: '3px 8px 3px 28px', fontSize: 11, color: '#795548' }}>
                ← {fromGrp?.name || '?'} から{cl.linkType === 'emergency' ? '非常用' : cl.linkType === 'backup' ? 'バックアップ' : cl.linkType === 'tie' ? '連絡' : ''}給電
                {cl.label ? ` (${cl.label})` : ''}
              </td>
            </tr>
          );
        })}
        {outgoingLinks.map(cl => {
          const toGrp = grps.find(g => g.id === cl.toGroupId);
          return (
            <tr key={'cl-out-' + cl.id} style={{ background: '#fff8e1', borderBottom: '1px solid #eee' }}>
              <td colSpan={9} style={{ padding: '3px 8px 3px 28px', fontSize: 11, color: '#795548' }}>
                → {toGrp?.name || '?'} へ{cl.linkType === 'emergency' ? '非常用' : cl.linkType === 'backup' ? 'バックアップ' : cl.linkType === 'tie' ? '連絡' : ''}給電
                {cl.label ? ` (${cl.label})` : ''}
              </td>
            </tr>
          );
        })}
      </React.Fragment>
    );
  };

  return (
    <div style={{ overflowX: 'auto' }}>
      <table style={{ width: '100%', borderCollapse: 'collapse', fontSize: 13 }}>
        <thead>
          <tr style={{ background: '#fafafa', borderBottom: '2px solid #ddd' }}>
            <th style={{ padding: '6px 4px', textAlign: 'left', fontSize: 12 }}>名称</th>
            <th style={{ padding: '6px 4px', textAlign: 'left', fontSize: 12 }}>方式/電圧</th>
            <th style={{ padding: '6px 4px', textAlign: 'right', fontSize: 12 }}>設計I</th>
            <th style={{ padding: '6px 4px', textAlign: 'left', fontSize: 12 }}>ケーブル</th>
            <th style={{ padding: '6px 4px', textAlign: 'right', fontSize: 12 }}>AT</th>
            <th style={{ padding: '6px 4px', textAlign: 'right', fontSize: 12 }}>e [V]</th>
            <th style={{ padding: '6px 4px', textAlign: 'left', fontSize: 12 }}>判定</th>
            <th style={{ padding: '6px 4px', textAlign: 'right', fontSize: 12 }}>Isc₃</th>
            <th style={{ padding: '6px 4px', fontSize: 12 }}></th>
          </tr>
        </thead>
        <tbody>
          {/* グループ化されたルートノード */}
          {Array.from(groupedRoots.values()).map(({ group: grp, roots }) => (
            <React.Fragment key={'grpsec-' + grp.id}>
              {renderGroupHeader(grp)}
              {!collapsedGroups[grp.id] && roots.map(node => renderNode(node, 0))}
            </React.Fragment>
          ))}
          {/* 未分類のルートノード */}
          {ungroupedRoots.length > 0 && grps.length > 0 && (
            <tr style={{ background: '#f5f5f5', borderBottom: '1px solid #ccc', borderTop: '2px solid #bbb' }}>
              <td colSpan={9} style={{ padding: '6px 8px', fontSize: 12, fontWeight: 600, color: '#999' }}>
                未分類
              </td>
            </tr>
          )}
          {ungroupedRoots.map(node => renderNode(node, 0))}
        </tbody>
      </table>
    </div>
  );
}

/* === PDF GENERATION === */

/* === GROUP EDITOR (M2-6) === */

function GroupEditor({ groups, nodes, allResults, crossLinks, onUpdateGroup, onRemoveGroup, onAutoGroupAll, onAddCrossLink, onRemoveCrossLink }) {
  const [editingId, setEditingId] = React.useState(null);
  const [editName, setEditName] = React.useState('');
  const [editColor, setEditColor] = React.useState('');
  /* クロスリンク追加UI */
  const [showLinkForm, setShowLinkForm] = React.useState(false);
  const [linkFrom, setLinkFrom] = React.useState('');
  const [linkTo, setLinkTo] = React.useState('');
  const [linkType, setLinkType] = React.useState('tie');
  const [linkLabel, setLinkLabel] = React.useState('');

  const startEdit = (grp) => { setEditingId(grp.id); setEditName(grp.name); setEditColor(grp.color); };
  const saveEdit = () => {
    if (editingId && editName.trim()) {
      onUpdateGroup(editingId, { name: editName.trim(), color: editColor });
      setEditingId(null);
    }
  };
  const addLink = () => {
    if (linkFrom && linkTo && linkFrom !== linkTo) {
      onAddCrossLink({ fromGroupId: linkFrom, toGroupId: linkTo, linkType, label: linkLabel, fromNodeId: null, toNodeId: null });
      setShowLinkForm(false); setLinkFrom(''); setLinkTo(''); setLinkLabel(''); setLinkType('tie');
    }
  };

  const selStyle = { padding: '4px 8px', borderRadius: 4, border: '1px solid #ccc', fontSize: 12, width: '100%' };
  const btnSmall = { border: 'none', background: 'none', cursor: 'pointer', fontSize: 12, padding: '2px 6px' };

  return (
    <div style={{ padding: 8 }}>
      <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 12 }}>
        <span style={{ fontWeight: 700, fontSize: 14 }}>グループ一覧</span>
        <button onClick={onAutoGroupAll} style={{ padding: '4px 10px', borderRadius: 4, border: '1px solid #ccc', fontSize: 11, cursor: 'pointer', background: '#fff' }}>
          全自動グループ化
        </button>
      </div>

      {groups.length === 0 && (
        <div style={{ color: '#999', fontSize: 12, padding: 8 }}>
          グループがありません。変圧器を追加すると自動で作成されます。
        </div>
      )}

      {groups.map(grp => {
        const memberNodes = getGroupNodes(nodes, grp.rootNodeId);
        const circuitCount = memberNodes.filter(n => n.type === 'load').length;
        const trunkCount = memberNodes.filter(n => n.type === 'trunk').length;
        const isEditing = editingId === grp.id;

        return (
          <div key={grp.id} style={{
            border: '1px solid #ddd', borderRadius: 6, padding: 10, marginBottom: 8,
            borderLeft: `4px solid ${grp.color === '#e3f2fd' ? '#1976d2' : grp.color}`,
            background: '#fff'
          }}>
            {isEditing ? (
              <div>
                <input value={editName} onChange={e => setEditName(e.target.value)}
                  style={{ ...selStyle, marginBottom: 6, fontWeight: 600 }} autoFocus />
                <div style={{ display: 'flex', gap: 4, alignItems: 'center', marginBottom: 6 }}>
                  <span style={{ fontSize: 11, color: '#666' }}>色:</span>
                  {GROUP_COLORS.map(c => (
                    <div key={c} onClick={() => setEditColor(c)}
                      style={{ width: 20, height: 20, borderRadius: 3, background: c, cursor: 'pointer',
                        border: editColor === c ? '2px solid #333' : '1px solid #ccc' }} />
                  ))}
                </div>
                <div style={{ display: 'flex', gap: 6 }}>
                  <button onClick={saveEdit} style={{ ...btnSmall, color: '#1976d2', fontWeight: 700 }}>保存</button>
                  <button onClick={() => setEditingId(null)} style={{ ...btnSmall, color: '#999' }}>取消</button>
                </div>
              </div>
            ) : (
              <div>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center' }}>
                  <span style={{ fontWeight: 600, fontSize: 13 }}>{grp.name}</span>
                  <div>
                    <button onClick={() => startEdit(grp)} style={{ ...btnSmall, color: '#1976d2' }}>編集</button>
                    <button onClick={() => onRemoveGroup(grp.id)} style={{ ...btnSmall, color: '#f44336' }}>削除</button>
                  </div>
                </div>
                <div style={{ fontSize: 11, color: '#666', marginTop: 4 }}>
                  {trunkCount}幹線 · {circuitCount}回路 · {memberNodes.length}ノード
                </div>
              </div>
            )}
          </div>
        );
      })}

      {/* クロスリンク管理 */}
      <div style={{ marginTop: 16, borderTop: '1px solid #eee', paddingTop: 12 }}>
        <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 8 }}>
          <span style={{ fontWeight: 700, fontSize: 13 }}>グループ間接続</span>
          <button onClick={() => setShowLinkForm(!showLinkForm)} style={{ padding: '3px 8px', borderRadius: 4, border: '1px solid #ccc', fontSize: 11, cursor: 'pointer', background: '#fff' }}>
            {showLinkForm ? '取消' : '+ 接続追加'}
          </button>
        </div>

        {showLinkForm && groups.length >= 2 && (
          <div style={{ border: '1px solid #ddd', borderRadius: 6, padding: 10, marginBottom: 8, background: '#fafafa' }}>
            <div style={{ marginBottom: 6 }}>
              <label style={{ fontSize: 11, color: '#666' }}>送り側:</label>
              <select value={linkFrom} onChange={e => setLinkFrom(e.target.value)} style={selStyle}>
                <option value="">選択</option>
                {groups.map(g => <option key={g.id} value={g.id}>{g.name}</option>)}
              </select>
            </div>
            <div style={{ marginBottom: 6 }}>
              <label style={{ fontSize: 11, color: '#666' }}>受け側:</label>
              <select value={linkTo} onChange={e => setLinkTo(e.target.value)} style={selStyle}>
                <option value="">選択</option>
                {groups.filter(g => g.id !== linkFrom).map(g => <option key={g.id} value={g.id}>{g.name}</option>)}
              </select>
            </div>
            <div style={{ marginBottom: 6 }}>
              <label style={{ fontSize: 11, color: '#666' }}>接続タイプ:</label>
              <select value={linkType} onChange={e => setLinkType(e.target.value)} style={selStyle}>
                <option value="tie">連絡線</option>
                <option value="emergency">非常用</option>
                <option value="backup">バックアップ</option>
                <option value="custom">カスタム</option>
              </select>
            </div>
            <div style={{ marginBottom: 6 }}>
              <label style={{ fontSize: 11, color: '#666' }}>ラベル:</label>
              <input value={linkLabel} onChange={e => setLinkLabel(e.target.value)} placeholder="任意" style={selStyle} />
            </div>
            <button onClick={addLink} disabled={!linkFrom || !linkTo || linkFrom === linkTo}
              style={{ width: '100%', padding: '6px', borderRadius: 4, border: 'none',
                background: linkFrom && linkTo && linkFrom !== linkTo ? '#1976d2' : '#e0e0e0',
                color: '#fff', fontSize: 12, fontWeight: 600, cursor: 'pointer' }}>追加</button>
          </div>
        )}

        {crossLinks && crossLinks.length > 0 ? crossLinks.map(cl => {
          const from = groups.find(g => g.id === cl.fromGroupId);
          const to = groups.find(g => g.id === cl.toGroupId);
          const typeLabel = cl.linkType === 'emergency' ? '非常用' : cl.linkType === 'backup' ? 'バックアップ' : cl.linkType === 'tie' ? '連絡線' : cl.linkType || '';
          return (
            <div key={cl.id} style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center',
              fontSize: 12, padding: '4px 8px', border: '1px solid #eee', borderRadius: 4, marginBottom: 4, background: '#fff' }}>
              <span>{from?.name || '?'} → {to?.name || '?'} ({typeLabel}{cl.label ? `: ${cl.label}` : ''})</span>
              <button onClick={() => onRemoveCrossLink(cl.id)} style={{ ...btnSmall, color: '#f44336' }}>×</button>
            </div>
          );
        }) : (
          <div style={{ color: '#999', fontSize: 11, padding: 4 }}>接続なし</div>
        )}
      </div>
    </div>
  );
}

/* === PDF GENERATION === */

/**
 * genPDF — 電-8-1 様式の電路計算書 HTML を生成 (§15)
 *
 * @param {Array} nodes - 全ノード配列
 * @param {Object} allResults - calculateAll() の結果マップ
 * @returns {string} 完全な HTML 文字列
 */
function genPDF(nodes, allResults) {
  const tree = buildTree(nodes);
  const rows = [];

  /* ツリーを再帰的に走査して行データを生成 */
  function walkTree(node, depth) {
    const r = allResults[node.id];
    if (node.type === 'transformer') {
      const tr = node.transformer || {};
      rows.push({
        type: 'transformer', depth,
        trunkName: tr.name || '',
        system: '', voltage: `${tr.primaryV || ''}/${tr.secondaryV || ''}`,
        mccbAT: '', loadName: tr.trType || '',
        capacity: `${tr.capacity_kVA || ''}kVA`, dI: r ? `${rd(r.In)}` : '',
        cableLength: '', cableSpec: '', wiring: '',
        baseAmpacity: '', reductionFactor: '', effectiveAmpacity: '',
        K: '', cosT: '', Z: '', vd: '', allowVd: '', judge: '',
        pctZ: tr.pctZ != null ? `%Z=${tr.pctZ}` : ''
      });
    } else if (node.type === 'trunk') {
      const t = node.trunk || {};
      const sizeStr = r ? `${r.size}${r.parallel > 1 ? '×' + r.parallel : ''}` : '';
      rows.push({
        type: 'trunk', depth,
        trunkName: t.name || '',
        system: t.system || '', voltage: t.voltage || '',
        mccbAT: r ? r.mccbAT : '',
        loadName: '',
        capacity: r && r.totalI != null ? `${r.totalI}A(合計)` : '',
        dI: r ? r.sizingI : '',
        cableLength: t.cableLength || '',
        cableSpec: r ? `${t.cableType} ${sizeStr}` : '',
        wiring: t.wiringMethod ? t.wiringMethod.replace('配線', '').replace('布設', '') : '',
        baseAmpacity: r ? r.baseAmpacity : '',
        reductionFactor: r ? r.reductionFactor : '',
        effectiveAmpacity: r ? r.effectiveAmpacity : '',
        K: r ? (r.K === Math.sqrt(3) ? '√3' : r.K) : '',
        cosT: t.powerFactor || '',
        Z: r ? r.Z : '',
        vd: r ? `${r.vd}V (${r.vdPercent}%)` : '',
        allowVd: r ? `${r.allowVd}V (${r.allowVdPercent}%)` : '',
        judge: r ? (r.ok ? 'OK' : 'NG') : ''
      });
    } else if (node.type === 'load') {
      const p = node.load || {};
      const sizeStr = r ? `${r.size}${r.parallel > 1 ? '×' + r.parallel : ''}` : '';
      rows.push({
        type: 'load', depth,
        trunkName: '',
        system: p.system || '', voltage: p.voltage || '',
        mccbAT: r ? r.mccbAT : '',
        loadName: p.loadName || '',
        capacity: p.unit === 'A' ? `${p.capacity}A` : `${p.capacity}${p.unit}`,
        dI: r ? r.dI : '',
        cableLength: p.cableLength || '',
        cableSpec: r ? `${p.cableType} ${sizeStr}` : '',
        wiring: p.wiringMethod ? p.wiringMethod.replace('配線', '').replace('布設', '') : '',
        baseAmpacity: r ? r.baseAmpacity : '',
        reductionFactor: r ? r.reductionFactor : '',
        effectiveAmpacity: r ? r.effectiveAmpacity : '',
        K: r ? (r.K === Math.sqrt(3) ? '√3' : r.K) : '',
        cosT: p.powerFactor || '',
        Z: r ? r.Z : '',
        vd: r ? `${r.vd}V (${r.vdPercent}%)` : '',
        allowVd: r ? `${r.allowVd}V (${r.allowVdPercent}%)` : '',
        judge: r ? (r.ok ? 'OK' : 'NG') : ''
      });
    }
    if (node.children) {
      for (const child of node.children) walkTree(child, depth + 1);
    }
  }
  for (const root of tree) walkTree(root, 0);

  /* HTML テーブル行を生成 */
  const tbodyHtml = rows.map(row => {
    const cls = row.type === 'trunk' ? ' class="trunk-row"'
      : row.type === 'transformer' ? ' class="tr-row"' : '';
    const indent = row.depth > 0 ? `padding-left:${8 + row.depth * 16}px` : '';
    const nameStyle = indent ? ` style="${indent}"` : '';
    return `<tr${cls}>
      <td${nameStyle}>${esc(row.trunkName)}</td>
      <td>${esc(String(row.system))}</td>
      <td class="r">${esc(String(row.voltage))}</td>
      <td class="r">${esc(String(row.mccbAT))}</td>
      <td>${esc(row.loadName)}</td>
      <td class="r">${esc(String(row.capacity))}</td>
      <td class="r">${esc(String(row.dI))}</td>
      <td class="r">${esc(String(row.cableLength))}</td>
      <td>${esc(row.cableSpec)}</td>
      <td>${esc(row.wiring)}</td>
      <td class="r">${esc(String(row.baseAmpacity))}</td>
      <td class="r">${esc(String(row.reductionFactor))}</td>
      <td class="r">${esc(String(row.effectiveAmpacity))}</td>
      <td class="r">${esc(String(row.K))}</td>
      <td class="r">${esc(String(row.cosT))}</td>
      <td class="r">${esc(String(row.Z))}</td>
      <td class="r">${esc(row.vd)}</td>
      <td class="r">${esc(row.allowVd)}</td>
      <td class="r judge-${row.judge === 'OK' ? 'ok' : row.judge === 'NG' ? 'ng' : ''}">${esc(row.judge)}</td>
    </tr>`;
  }).join('\n');

  return `<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>低圧幹線ケーブル電路計算書</title>
<style>
@page { size: A3 landscape; margin: 8mm; }
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: 'MS Gothic', 'Hiragino Kaku Gothic ProN', monospace; font-size: 9pt; color: #000; }
h2 { font-size: 13pt; margin-bottom: 6px; }
table { border-collapse: collapse; width: 100%; margin-bottom: 12px; }
th, td { border: 1px solid #333; padding: 2px 4px; font-size: 8pt; white-space: nowrap; vertical-align: middle; }
th { background: #e8e8e8; font-weight: 700; text-align: center; }
td.r { text-align: right; }
.trunk-row { font-weight: 700; background: #dce6f7; }
.tr-row { font-weight: 700; background: #e8e0f0; }
.judge-ok { color: #006400; font-weight: 700; }
.judge-ng { color: #c00; font-weight: 700; }
.footer { font-size: 8pt; margin-top: 8px; line-height: 1.6; border-top: 1px solid #999; padding-top: 4px; }
.footer dt { font-weight: 700; }
@media print { body { -webkit-print-color-adjust: exact; print-color-adjust: exact; } }
</style>
</head>
<body>
<h2>低圧幹線ケーブル電路計算書</h2>
<p style="font-size:8pt;margin-bottom:4px;">出力日: ${new Date().toLocaleDateString('ja-JP')}</p>
<table>
<thead>
<tr>
  <th rowspan="2">幹線番号<br>/名称</th>
  <th rowspan="2">電気方式</th>
  <th rowspan="2">電圧<br>[V]</th>
  <th rowspan="2">遮断器<br>[AT]</th>
  <th rowspan="2">負荷名称</th>
  <th rowspan="2">負荷容量</th>
  <th rowspan="2">設計電流<br>[A]</th>
  <th rowspan="2">L<br>[m]</th>
  <th colspan="5">許容電流</th>
  <th colspan="5">電圧降下</th>
  <th rowspan="2">判定</th>
</tr>
<tr>
  <th>種別/太さ</th>
  <th>配線</th>
  <th>許容<br>[A]</th>
  <th>低減率</th>
  <th>補正後<br>[A]</th>
  <th>K</th>
  <th>cosθ</th>
  <th>Z<br>[Ω/km]</th>
  <th>e [V]<br>(%)</th>
  <th>許容e [V]<br>(%)</th>
</tr>
</thead>
<tbody>
${tbodyHtml}
</tbody>
</table>
<div class="footer">
<dl>
<dt>電圧降下計算式</dt>
<dd>e = K × I × l × Z / 1000 [V]　（l: こう長 [m]）</dd>
<dt>Z（インピーダンス）</dt>
<dd>Z = R·cosθ + X·sinθ [Ω/km]（精密式）</dd>
<dt>K値</dt>
<dd>単相2線式: K=2　/　単相3線式: K=1　/　三相3線式: K=√3　/　三相4線式: K=1</dd>
<dt>保護協調判定基準</dt>
<dd>一般回路: 実効許容電流 ≧ MCCB定格 [AT]　/　電動機回路: 実効許容電流 ≧ AT / 2.5</dd>
</dl>
</div>
</body>
</html>`;
}

/** HTML エスケープ */
function esc(s) { return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;').replace(/"/g,'&quot;'); }

/* === DIAGRAM OUTPUT (M2-5) === */

/**
 * genDiagramHTML — 系統図を印刷用 HTML/SVG として生成
 */
function genDiagramHTML(nodes, allResults, systemMeta) {
  const direction = (systemMeta && systemMeta.diagramDirection) || 'horizontal';
  /* canvas 座標を確定 */
  const positioned = ensureCanvasPositions(nodes, direction);

  /* SVG バウンディングボックスを計算 */
  let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
  for (const n of positioned) {
    if (!n.canvas) continue;
    minX = Math.min(minX, n.canvas.x);
    minY = Math.min(minY, n.canvas.y);
    maxX = Math.max(maxX, n.canvas.x + n.canvas.width);
    maxY = Math.max(maxY, n.canvas.y + n.canvas.height);
  }
  const pad = 60;
  minX -= pad; minY -= pad; maxX += pad; maxY += pad;
  const svgW = maxX - minX;
  const svgH = maxY - minY;

  /* 接続線 SVG */
  const dir = DIRECTIONS[direction];
  let connSvg = '';
  for (const n of positioned) {
    if (!n.parentId || !n.canvas) continue;
    const parent = positioned.find(p => p.id === n.parentId);
    if (!parent || !parent.canvas) continue;
    let fx, fy, tx, ty;
    if (dir.outPort === 'right') {
      fx = parent.canvas.x + parent.canvas.width; fy = parent.canvas.y + parent.canvas.height / 2;
      tx = n.canvas.x; ty = n.canvas.y + n.canvas.height / 2;
    } else {
      fx = parent.canvas.x + parent.canvas.width / 2; fy = parent.canvas.y + parent.canvas.height;
      tx = n.canvas.x + n.canvas.width / 2; ty = n.canvas.y;
    }
    const mx = (fx + tx) / 2, my = (fy + ty) / 2;
    const r = allResults[n.id];
    const col = r ? (r.ok ? '#333' : '#c00') : '#999';
    const dash = r && !r.ok ? 'stroke-dasharray="4 2"' : '';
    const d = dir.outPort === 'right'
      ? `M${fx},${fy} C${mx},${fy} ${mx},${ty} ${tx},${ty}`
      : `M${fx},${fy} C${fx},${my} ${tx},${my} ${tx},${ty}`;
    connSvg += `<path d="${d}" fill="none" stroke="${col}" stroke-width="1.5" ${dash}/>\n`;
  }

  /* モジュール SVG */
  let modSvg = '';
  for (const n of positioned) {
    if (!n.canvas) continue;
    const { x, y, width: w, height: h } = n.canvas;
    const r = allResults[n.id];

    if (n.type === 'transformer') {
      const tr = n.transformer || {};
      const rad = Math.min(w, h) * 0.22;
      const cx = x + w / 2, cy = y + h / 2;
      const [pri, sec] = (tr.connection || 'Δ-Y').split('-');
      modSvg += `<rect x="${x}" y="${y}" width="${w}" height="${h}" rx="4" fill="#f3e5f5" stroke="#7b1fa2" stroke-width="1.5"/>`;
      modSvg += `<circle cx="${cx - rad * 0.5}" cy="${cy}" r="${rad}" fill="none" stroke="#333" stroke-width="1.5"/>`;
      modSvg += `<circle cx="${cx + rad * 0.5}" cy="${cy}" r="${rad}" fill="none" stroke="#333" stroke-width="1.5"/>`;
      modSvg += `<text x="${cx - rad * 0.5}" y="${cy - rad - 4}" font-size="9" text-anchor="middle" fill="#555">${esc(pri)}</text>`;
      modSvg += `<text x="${cx + rad * 0.5}" y="${cy - rad - 4}" font-size="9" text-anchor="middle" fill="#555">${esc(sec)}</text>`;
      modSvg += `<text x="${cx}" y="${y - 6}" font-size="10" text-anchor="middle" font-weight="700" fill="#333">${esc(tr.name || 'TR')}</text>`;
      modSvg += `<text x="${cx}" y="${y + h + 12}" font-size="8" text-anchor="middle" fill="#666">${esc(String(tr.capacity_kVA || ''))}kVA ${esc(String(tr.primaryV || ''))}/${esc(String(tr.secondaryV || ''))}V</text>`;
      if (r) modSvg += `<text x="${cx}" y="${y + h + 22}" font-size="8" text-anchor="middle" fill="#666">Isc₃=${rd(r.Isc3 / 1000, 1)}kA  %Z=${tr.pctZ}</text>`;

    } else if (n.type === 'trunk') {
      const tr = n.trunk || {};
      const ok = r ? r.ok : null;
      const border = ok === false ? '#c00' : ok ? '#4caf50' : '#999';
      const bg = ok === false ? '#fff5f5' : '#fff';
      const sizeStr = r ? `${r.size}${r.parallel > 1 ? '×' + r.parallel : ''}` : '';
      modSvg += `<rect x="${x}" y="${y}" width="${w}" height="${h}" rx="4" fill="${bg}" stroke="${border}" stroke-width="1.5"/>`;
      /* MCCB */
      const mx = x + 18, my = y + h / 2, mw = 20, mh = 14;
      modSvg += `<rect x="${mx - mw / 2}" y="${my - mh / 2}" width="${mw}" height="${mh}" fill="#fff" stroke="#333" stroke-width="1.2"/>`;
      modSvg += `<line x1="${mx - mw / 4}" y1="${my - mh / 2}" x2="${mx + mw / 4}" y2="${my + mh / 2}" stroke="#333" stroke-width="1.2"/>`;
      if (r) modSvg += `<text x="${x + 36}" y="${my - 6}" font-size="8" fill="#333">${r.mccbAT}AT</text>`;
      modSvg += `<text x="${x + 36}" y="${my + 5}" font-size="8" fill="#555">${esc(tr.cableType)} ${sizeStr}</text>`;
      modSvg += `<text x="${x + 36}" y="${my + 15}" font-size="7" fill="#888">${tr.cableLength}m</text>`;
      modSvg += `<text x="${x + w / 2}" y="${y - 5}" font-size="10" text-anchor="middle" font-weight="600" fill="#333">${esc(tr.name || '幹線')}</text>`;
      if (r) modSvg += `<text x="${x + w - 6}" y="${my + 3}" font-size="8" text-anchor="end" fill="#666">${rd(r.dI, 1)}A  e=${r.vdPercent}%</text>`;
      if (ok != null) {
        modSvg += `<rect x="${x + w - 22}" y="${y + 3}" width="18" height="12" rx="2" fill="${ok ? '#e8f5e9' : '#ffebee'}" stroke="${ok ? '#4caf50' : '#c00'}" stroke-width="0.8"/>`;
        modSvg += `<text x="${x + w - 13}" y="${y + 12}" font-size="7" text-anchor="middle" font-weight="700" fill="${ok ? '#2e7d32' : '#c00'}">${ok ? 'OK' : 'NG'}</text>`;
      }

    } else if (n.type === 'load') {
      const p = n.load || {};
      const ok = r ? r.ok : null;
      const border = ok === false ? '#c00' : ok ? '#4caf50' : '#999';
      const bg = ok === false ? '#fff5f5' : '#fff';
      const sizeStr = r ? `${r.size}${r.parallel > 1 ? '×' + r.parallel : ''}` : '';
      modSvg += `<rect x="${x}" y="${y}" width="${w}" height="${h}" rx="4" fill="${bg}" stroke="${border}" stroke-width="1.5"/>`;
      /* MCCB */
      const mx = x + 18, my = y + h / 2, mw = 20, mh = 14;
      modSvg += `<rect x="${mx - mw / 2}" y="${my - mh / 2}" width="${mw}" height="${mh}" fill="#fff" stroke="#333" stroke-width="1.2"/>`;
      modSvg += `<line x1="${mx - mw / 4}" y1="${my - mh / 2}" x2="${mx + mw / 4}" y2="${my + mh / 2}" stroke="#333" stroke-width="1.2"/>`;
      if (r) modSvg += `<text x="${x + 36}" y="${my - 4}" font-size="8" fill="#333">${r.mccbAT}AT</text>`;
      modSvg += `<text x="${x + 36}" y="${my + 7}" font-size="7" fill="#888">${esc(p.cableType)} ${sizeStr} ${p.cableLength}m</text>`;
      /* 負荷シンボル */
      if (p.circuitType === '電動機') {
        modSvg += `<circle cx="${x + w - 18}" cy="${my}" r="10" fill="#e3f2fd" stroke="#1565c0" stroke-width="1.5"/>`;
        modSvg += `<text x="${x + w - 18}" y="${my + 4}" font-size="10" text-anchor="middle" font-weight="700" fill="#1565c0">M</text>`;
      } else {
        modSvg += `<polygon points="${x + w - 18},${my - 10} ${x + w - 8},${my + 6} ${x + w - 28},${my + 6}" fill="#fff3e0" stroke="#e65100" stroke-width="1.5"/>`;
      }
      modSvg += `<text x="${x + w / 2}" y="${y - 5}" font-size="9" text-anchor="middle" font-weight="600" fill="#333">${esc(p.loadName || p.trunkName || '負荷')}</text>`;
      if (r) modSvg += `<text x="${x + w / 2}" y="${y + h + 11}" font-size="7" text-anchor="middle" fill="#666">${rd(r.dI, 1)}A  e=${r.vdPercent}%</text>`;
      if (ok != null) {
        modSvg += `<rect x="${x + w - 22}" y="${y + 3}" width="18" height="12" rx="2" fill="${ok ? '#e8f5e9' : '#ffebee'}" stroke="${ok ? '#4caf50' : '#c00'}" stroke-width="0.8"/>`;
        modSvg += `<text x="${x + w - 13}" y="${y + 12}" font-size="7" text-anchor="middle" font-weight="700" fill="${ok ? '#2e7d32' : '#c00'}">${ok ? 'OK' : 'NG'}</text>`;
      }
    }
  }

  /* 標題欄 */
  const titleX = maxX - 200, titleY = maxY - 60;
  const titleSvg = `
    <rect x="${titleX}" y="${titleY}" width="180" height="50" fill="#fff" stroke="#333" stroke-width="1"/>
    <text x="${titleX + 90}" y="${titleY + 14}" font-size="11" text-anchor="middle" font-weight="700" fill="#333">幹線系統図</text>
    <line x1="${titleX}" y1="${titleY + 18}" x2="${titleX + 180}" y2="${titleY + 18}" stroke="#333" stroke-width="0.5"/>
    <text x="${titleX + 6}" y="${titleY + 30}" font-size="7" fill="#666">工事名称: ${esc(systemMeta.projectName || '')}</text>
    <text x="${titleX + 6}" y="${titleY + 40}" font-size="7" fill="#666">作成日: ${new Date().toLocaleDateString('ja-JP')}</text>
  `;

  /* 凡例 */
  const legX = minX + 10, legY = maxY - 80;
  const legendSvg = `
    <rect x="${legX}" y="${legY}" width="160" height="70" fill="#fff" stroke="#999" stroke-width="0.5" rx="2"/>
    <text x="${legX + 6}" y="${legY + 12}" font-size="8" font-weight="700" fill="#333">凡例</text>
    <rect x="${legX + 6}" y="${legY + 18}" width="14" height="10" fill="#fff" stroke="#333" stroke-width="1"/>
    <line x1="${legX + 9}" y1="${legY + 18}" x2="${legX + 17}" y2="${legY + 28}" stroke="#333" stroke-width="1"/>
    <text x="${legX + 26}" y="${legY + 27}" font-size="7" fill="#333">MCCB（配線用遮断器）</text>
    <circle cx="${legX + 13}" cy="${legY + 38}" r="6" fill="none" stroke="#333" stroke-width="1"/>
    <circle cx="${legX + 19}" cy="${legY + 38}" r="6" fill="none" stroke="#333" stroke-width="1"/>
    <text x="${legX + 32}" y="${legY + 41}" font-size="7" fill="#333">変圧器</text>
    <circle cx="${legX + 13}" cy="${legY + 54}" r="6" fill="#e3f2fd" stroke="#1565c0" stroke-width="1"/>
    <text x="${legX + 13}" y="${legY + 57}" font-size="6" text-anchor="middle" font-weight="700" fill="#1565c0">M</text>
    <text x="${legX + 26}" y="${legY + 57}" font-size="7" fill="#333">電動機</text>
    <polygon points="${legX + 90},${legY + 20} ${legX + 98},${legY + 30} ${legX + 82},${legY + 30}" fill="#fff3e0" stroke="#e65100" stroke-width="1"/>
    <text x="${legX + 104}" y="${legY + 27}" font-size="7" fill="#333">一般負荷</text>
  `;

  return `<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<title>幹線系統図</title>
<style>
@page { size: A3 landscape; margin: 10mm; }
* { box-sizing: border-box; margin: 0; padding: 0; }
body { font-family: 'MS Gothic', 'Hiragino Kaku Gothic ProN', monospace; }
svg { width: 100%; height: auto; }
@media print { body { -webkit-print-color-adjust: exact; print-color-adjust: exact; } }
</style>
</head>
<body>
<svg viewBox="${minX} ${minY} ${svgW} ${svgH}" xmlns="http://www.w3.org/2000/svg">
${connSvg}
${modSvg}
${titleSvg}
${legendSvg}
</svg>
</body>
</html>`;
}

/* === APP === */
function App() {
  /* --- State: live（表示用）と calc（計算用）の2層管理 (§6) --- */
  const [params, setParams] = React.useState({ ...DEFAULT_PARAMS });
  const [display, setDisplay] = React.useState({
    capacity: String(DEFAULT_PARAMS.capacity),
    powerFactor: String(DEFAULT_PARAMS.powerFactor),
    efficiency: String(DEFAULT_PARAMS.efficiency),
    demandFactor: String(DEFAULT_PARAMS.demandFactor),
    cableLength: String(DEFAULT_PARAMS.cableLength),
    ambientTemp: String(DEFAULT_PARAMS.ambientTemp),
    reductionFactor: String(DEFAULT_PARAMS.reductionFactor)
  });

  /* --- P4: ツリー状態 (§18-7) --- */
  const [nodes, setNodes] = React.useState([]);
  const [selectedId, setSelectedId] = React.useState(null);
  const [editMode, setEditMode] = React.useState('load');
  const [trParams, setTrParams] = React.useState({ ...DEFAULT_TR_PARAMS });
  const [trunkParams, setTrunkParams] = React.useState({ ...DEFAULT_TRUNK_PARAMS });
  const fileInputRef = React.useRef(null);

  /* --- M2: 系統図ステート --- */
  const [systemMeta, setSystemMeta] = React.useState({
    projectName: '', hvVoltage: 6600, freq: '60Hz',
    substationName: '受電設備', diagramDirection: 'horizontal'
  });
  const [rightPaneView, setRightPaneView] = React.useState('table'); /* 'table' | 'diagram' | 'split' */
  const [diagramMode, setDiagramMode] = React.useState('edit'); /* 'edit' | 'view' */
  const [showBulkImport, setShowBulkImport] = React.useState(false);

  /* --- M2-6: グループ管理ステート --- */
  const [groups, setGroups] = React.useState([]);
  const [crossLinks, setCrossLinks] = React.useState([]);

  /* --- 計算結果（フォームプレビュー用） --- */
  const result = React.useMemo(() => {
    if (editMode !== 'load' || params.capacity <= 0) return null;
    return runCalc(params);
  }, [params, editMode]);

  /* --- 全ノード一括計算 --- */
  const allResults = React.useMemo(() => {
    if (nodes.length === 0) return {};
    return calculateAll(nodes);
  }, [nodes]);

  /* --- M2: canvas 座標が未設定のノードに自動配置を適用 --- */
  React.useEffect(() => {
    if (nodes.length === 0) return;
    const needsLayout = nodes.some(n => !n.canvas || n.canvas.x == null);
    if (!needsLayout) return;
    const updated = ensureCanvasPositions(nodes, systemMeta.diagramDirection);
    if (updated !== nodes) setNodes(updated);
  }, [nodes.length]);

  /* --- 選択中ノードの情報 --- */
  const selectedNode = nodes.find(n => n.id === selectedId);
  const selectedResult = selectedId ? allResults[selectedId] : null;

  /* --- 変圧器プレビュー --- */
  const trPreview = React.useMemo(() => {
    if (editMode !== 'transformer') return null;
    return calcTransformer(trParams);
  }, [trParams, editMode]);

  /* --- 幹線の子回路集計 --- */
  const trunkChildSummary = React.useMemo(() => {
    if (editMode !== 'trunk' || !selectedId) return null;
    return aggregateCurrents(nodes, selectedId, allResults);
  }, [editMode, selectedId, nodes, allResults]);

  /* --- 連動制御ヘルパー (§5) --- */
  const updateSelect = (key, val) => {
    setParams(prev => {
      const next = { ...prev, [key]: val };
      if (key === 'system') {
        const voltages = VOLTAGE_OPTIONS[val];
        if (!voltages.includes(prev.voltage)) next.voltage = voltages[0];
        const cableOpts = getCableTypeOptions(val);
        if (!cableOpts.includes(prev.cableType)) next.cableType = cableOpts[0];
      }
      if (key === 'circuitType') {
        if (val === '一般') next.efficiency = 1.0;
      }
      if (key === 'reductionPreset') {
        const preset = RED_PRE.find(p => p.label === val);
        if (preset && preset.factor !== null) {
          next.reductionFactor = preset.factor;
          setDisplay(d => ({ ...d, reductionFactor: String(preset.factor) }));
        }
      }
      return next;
    });
  };

  const confirmNum = (key) => {
    const raw = display[key];
    const n = parseFloat(raw);
    if (!isNaN(n)) setParams(prev => ({ ...prev, [key]: n }));
    else setDisplay(d => ({ ...d, [key]: String(params[key]) }));
  };

  const updateNumLive = (key, val) => {
    if (typeof val === 'number') {
      setDisplay(d => ({ ...d, [key]: String(val) }));
      setParams(prev => ({ ...prev, [key]: val }));
    } else {
      setDisplay(d => ({ ...d, [key]: val }));
    }
  };

  /* --- フォームリセット --- */
  const resetToNewLoad = () => {
    setSelectedId(null);
    setEditMode('load');
    setParams({ ...DEFAULT_PARAMS });
    setDisplay({
      capacity: String(DEFAULT_PARAMS.capacity),
      powerFactor: String(DEFAULT_PARAMS.powerFactor),
      efficiency: String(DEFAULT_PARAMS.efficiency),
      demandFactor: String(DEFAULT_PARAMS.demandFactor),
      cableLength: String(DEFAULT_PARAMS.cableLength),
      ambientTemp: String(DEFAULT_PARAMS.ambientTemp),
      reductionFactor: String(DEFAULT_PARAMS.reductionFactor)
    });
  };

  /* --- CRUD: 負荷登録 --- */
  const handleRegisterLoad = () => {
    if (!result || !params.trunkName || params.capacity <= 0) return;
    setNodes(prev => {
      let updated = [...prev];
      const trNode = updated.find(n => n.type === 'transformer');
      let trunk = updated.find(n => n.type === 'trunk' && n.trunk.name === params.trunkName);
      if (!trunk) {
        const trId = trNode ? trNode.id : null;
        trunk = {
          id: genId(), type: 'trunk', parentId: trId,
          order: getChildren(updated, trId).length,
          ts: new Date().toISOString(), externalRef: null,
          canvas: null,
          trunk: {
            ...DEFAULT_TRUNK_PARAMS, name: params.trunkName,
            system: params.system, voltage: params.voltage,
            freq: params.freq, supplyType: trNode ? '高圧受電' : params.supplyType
          }
        };
        updated = addNode(updated, trunk);
      }
      const loadNode = {
        id: genId(), type: 'load', parentId: trunk.id,
        order: getChildren(updated, trunk.id).length,
        ts: new Date().toISOString(), externalRef: null,
        canvas: null,
        load: { ...params }
      };
      updated = addNode(updated, loadNode);
      return updated;
    });
    resetToNewLoad();
  };

  /* --- 一括取込ハンドラ --- */
  const handleBulkImport = (validRows) => {
    setNodes(prev => {
      let updated = [...prev];

      for (const row of validRows) {
        const p = row.params;
        const trName = row.trName || '';

        /* 変圧器の解決: trName 指定時は名前でマッチ → なければ自動作成 */
        let trNode = null;
        if (trName) {
          trNode = updated.find(n => n.type === 'transformer' && n.transformer.name === trName);
          if (!trNode) {
            trNode = {
              id: genId(), type: 'transformer', parentId: null,
              order: updated.filter(n => !n.parentId).length,
              ts: new Date().toISOString(), externalRef: null,
              canvas: null,
              transformer: {
                ...DEFAULT_TR_PARAMS, name: trName,
                secondaryV: p.voltage
              }
            };
            updated = addNode(updated, trNode);
          }
        } else {
          /* 変圧器名未指定: 既存の最初の変圧器を使う */
          trNode = updated.find(n => n.type === 'transformer');
        }

        /* 幹線の解決: 同一名のトランクを検索 → なければ作成 */
        let trunk = updated.find(n => n.type === 'trunk' && n.trunk.name === p.trunkName);
        if (!trunk) {
          const parentId = trNode ? trNode.id : null;
          trunk = {
            id: genId(), type: 'trunk', parentId: parentId,
            order: getChildren(updated, parentId).length,
            ts: new Date().toISOString(), externalRef: null,
            canvas: null,
            trunk: {
              ...DEFAULT_TRUNK_PARAMS, name: p.trunkName,
              system: p.system, voltage: p.voltage,
              freq: p.freq, supplyType: trNode ? '高圧受電' : p.supplyType
            }
          };
          updated = addNode(updated, trunk);
        }

        /* 負荷ノード作成 */
        const loadNode = {
          id: genId(), type: 'load', parentId: trunk.id,
          order: getChildren(updated, trunk.id).length,
          ts: new Date().toISOString(), externalRef: null,
          canvas: null,
          load: { ...p }
        };
        updated = addNode(updated, loadNode);
      }

      return updated;
    });
    /* 一括取込後にグループを自動生成 */
    setNodes(prev => {
      const newGroups = autoCreateGroups(prev, groups);
      if (newGroups.length > groups.length) setGroups(newGroups);
      return prev;
    });
  };

  /* --- CRUD: ノード更新 --- */
  const handleUpdateNode = () => {
    if (!selectedId) return;
    const node = nodes.find(n => n.id === selectedId);
    if (!node) return;
    if (node.type === 'load') {
      setNodes(prev => updateNode(prev, selectedId, { load: { ...params } }));
    } else if (node.type === 'trunk') {
      setNodes(prev => updateNode(prev, selectedId, { trunk: { ...trunkParams } }));
    } else if (node.type === 'transformer') {
      setNodes(prev => {
        let updated = updateNode(prev, selectedId, { transformer: { ...trParams } });
        if (node.transformer.secondaryV !== trParams.secondaryV) {
          const desc = getDescendants(updated, selectedId);
          for (const d of desc) {
            if (d.type === 'trunk') updated = updateNode(updated, d.id, { trunk: { ...d.trunk, voltage: trParams.secondaryV } });
            else if (d.type === 'load') updated = updateNode(updated, d.id, { load: { ...d.load, voltage: trParams.secondaryV } });
          }
        }
        return updated;
      });
    }
    resetToNewLoad();
  };

  /* --- CRUD: ノード削除 --- */
  const handleDeleteNode = (id) => {
    const target = nodes.find(n => n.id === id);
    setNodes(prev => {
      let updated = removeNode(prev, id);
      /* §13: load 削除後に親 trunk の子が 0 件なら trunk も自動削除 */
      if (target && target.type === 'load' && target.parentId) {
        const parentTrunk = updated.find(n => n.id === target.parentId);
        if (parentTrunk && parentTrunk.type === 'trunk' && getChildren(updated, parentTrunk.id).length === 0) {
          updated = removeNode(updated, parentTrunk.id);
        }
      }
      return updated;
    });
    /* M2-6: ルートノード削除時にグループとクロスリンクを連動削除 */
    const grp = groups.find(g => g.rootNodeId === id);
    if (grp) {
      setCrossLinks(prev => prev.filter(cl => cl.fromGroupId !== grp.id && cl.toGroupId !== grp.id));
      setGroups(prev => prev.filter(g => g.id !== grp.id));
    }
    if (selectedId === id) resetToNewLoad();
  };

  /* --- CRUD: 変圧器登録/更新 --- */
  const handleSaveTransformer = () => {
    if (selectedId && selectedNode?.type === 'transformer') {
      handleUpdateNode();
      /* M2-6: グループ名も同期更新 */
      const grp = groups.find(g => g.rootNodeId === selectedId);
      if (grp && trParams.name && grp.name !== trParams.name) {
        setGroups(prev => prev.map(g => g.id === grp.id ? { ...g, name: trParams.name } : g));
      }
    } else {
      const newId = genId();
      setNodes(prev => {
        const trCount = prev.filter(n => n.type === 'transformer').length;
        return addNode(prev, {
          id: newId, type: 'transformer', parentId: null,
          order: trCount, ts: new Date().toISOString(), externalRef: null,
          transformer: { ...trParams },
          canvas: null /* 自動配置で割り当て */
        });
      });
      /* M2-6: 変圧器追加時にグループを自動作成 */
      setGroups(prev => [...prev, {
        id: genId(),
        name: trParams.name || 'TR-' + (prev.length + 1),
        color: GROUP_COLORS[prev.length % GROUP_COLORS.length],
        rootNodeId: newId,
        canvas: { x: 0, y: 0, collapsed: false }
      }]);
      resetToNewLoad();
    }
  };

  /* --- CRUD: 幹線更新 --- */
  const handleSaveTrunk = () => {
    if (selectedId && selectedNode?.type === 'trunk') handleUpdateNode();
  };

  /* --- ツリー: 子ノード追加 --- */
  const handleAddChild = (parentNode) => {
    if (parentNode.type === 'transformer') {
      setSelectedId(null);
      setEditMode('trunk');
      setTrunkParams({ ...DEFAULT_TRUNK_PARAMS, voltage: parentNode.transformer?.secondaryV || 210 });
    } else if (parentNode.type === 'trunk') {
      setSelectedId(null);
      setEditMode('load');
      setParams({ ...DEFAULT_PARAMS, trunkName: parentNode.trunk?.name || '' });
      setDisplay({
        capacity: String(DEFAULT_PARAMS.capacity),
        powerFactor: String(DEFAULT_PARAMS.powerFactor),
        efficiency: String(DEFAULT_PARAMS.efficiency),
        demandFactor: String(DEFAULT_PARAMS.demandFactor),
        cableLength: String(DEFAULT_PARAMS.cableLength),
        ambientTemp: String(DEFAULT_PARAMS.ambientTemp),
        reductionFactor: String(DEFAULT_PARAMS.reductionFactor)
      });
    }
  };

  /* --- 行クリック: ノード選択 --- */
  const handleSelectNode = (node) => {
    setSelectedId(node.id);
    if (node.type === 'transformer') {
      setEditMode('transformer');
      setTrParams({ ...node.transformer });
    } else if (node.type === 'trunk') {
      setEditMode('trunk');
      setTrunkParams({ ...node.trunk });
    } else {
      setEditMode('load');
      const p = { ...node.load };
      setParams(p);
      setDisplay({
        capacity: String(p.capacity), powerFactor: String(p.powerFactor),
        efficiency: String(p.efficiency), demandFactor: String(p.demandFactor),
        cableLength: String(p.cableLength), ambientTemp: String(p.ambientTemp),
        reductionFactor: String(p.reductionFactor)
      });
    }
  };

  /* --- Export (§14, M2-6: M2G スキーマ) --- */
  const handleExport = () => {
    const data = { version: 'M2G', nodes, groups, crossLinks, systemMeta, exportedAt: new Date().toISOString() };
    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `幹線計算_${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    URL.revokeObjectURL(url);
  };

  /* --- Import (§14, M2-6: M2G 対応) --- */
  const handleImport = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const data = JSON.parse(ev.target.result);
        if (data.nodes && Array.isArray(data.nodes)) {
          const existingIds = new Set(nodes.map(n => n.id));
          const idMap = {};
          const imported = data.nodes.map(n => {
            let newId = n.id;
            if (existingIds.has(n.id)) { newId = genId(); idMap[n.id] = newId; }
            /* M2-3: 新フィールドのデフォルト補完 */
            if (n.type === 'load' && n.load) {
              n.load = { ...n.load, icuClass: n.load.icuClass || 'standard', hasELCB: n.load.hasELCB || false, elcbSensitivity_mA: n.load.elcbSensitivity_mA || 30, groundingMethod: n.load.groundingMethod || 'TT', groundResistance_ohm: n.load.groundResistance_ohm || 100 };
            }
            if (n.type === 'trunk' && n.trunk) {
              n.trunk = { ...n.trunk, icuClass: n.trunk.icuClass || 'standard' };
            }
            if (n.type === 'transformer' && n.transformer) {
              n.transformer = { ...n.transformer, hvSystem: { cableType: null, cableSize_mm2: null, totalCableLength_km: null, capacitance_uF_per_km: null, vcbTripTime_s: 1.0, ...(n.transformer.hvSystem || {}) } };
            }
            return { ...n, id: newId, canvas: n.canvas || null };
          }).map(n => ({
            ...n, parentId: n.parentId ? (idMap[n.parentId] || n.parentId) : null
          }));
          setNodes(prev => [...prev, ...imported]);
          if (data.systemMeta) setSystemMeta(prev => ({ ...prev, ...data.systemMeta }));

          /* M2-6: グループとクロスリンクの復元 */
          if (data.version === 'M2G' && data.groups) {
            const grpIdMap = {};
            const importedGroups = data.groups.map(g => {
              const newGrpId = genId();
              grpIdMap[g.id] = newGrpId;
              return { ...g, id: newGrpId, rootNodeId: idMap[g.rootNodeId] || g.rootNodeId };
            });
            setGroups(prev => [...prev, ...importedGroups]);
            if (data.crossLinks && Array.isArray(data.crossLinks)) {
              const importedLinks = data.crossLinks.map(cl => ({
                ...cl, id: genId(),
                fromGroupId: grpIdMap[cl.fromGroupId] || cl.fromGroupId,
                toGroupId: grpIdMap[cl.toGroupId] || cl.toGroupId,
                fromNodeId: cl.fromNodeId ? (idMap[cl.fromNodeId] || cl.fromNodeId) : null,
                toNodeId: cl.toNodeId ? (idMap[cl.toNodeId] || cl.toNodeId) : null
              }));
              setCrossLinks(prev => [...prev, ...importedLinks]);
            }
          } else {
            /* M2/P5 形式: ルートノードからグループを自動生成 */
            setGroups(prev => [...prev, ...autoCreateGroups(imported, prev)]);
          }

          alert(`${imported.length} ノードをインポートしました`);
        } else if (data.records && Array.isArray(data.records)) {
          alert('旧形式（P3）のファイルです。P4 以降の形式でエクスポートし直してください。');
        } else { alert('有効なデータが見つかりません'); }
      } catch (err) { alert('JSON の読み込みに失敗しました: ' + err.message); }
      if (fileInputRef.current) fileInputRef.current.value = '';
    };
    reader.readAsText(file);
  };

  /* --- M2-6: グループ CRUD ハンドラ --- */
  const handleAddGroup = (rootNodeId, name) => {
    if (groups.some(g => g.rootNodeId === rootNodeId)) return; /* 重複防止 */
    setGroups(prev => [...prev, {
      id: genId(), name: name || 'Group-' + (prev.length + 1),
      color: GROUP_COLORS[prev.length % GROUP_COLORS.length],
      rootNodeId, canvas: { x: 0, y: 0, collapsed: false }
    }]);
  };

  const handleUpdateGroup = (groupId, patch) => {
    setGroups(prev => prev.map(g => g.id === groupId ? { ...g, ...patch, id: g.id, rootNodeId: g.rootNodeId } : g));
  };

  const handleRemoveGroup = (groupId) => {
    setCrossLinks(prev => prev.filter(cl => cl.fromGroupId !== groupId && cl.toGroupId !== groupId));
    setGroups(prev => prev.filter(g => g.id !== groupId));
  };

  const handleAutoGroupAll = () => {
    const newGroups = autoCreateGroups(nodes, groups);
    if (newGroups.length > 0) setGroups(prev => [...prev, ...newGroups]);
  };

  const handleToggleGroupCollapse = (groupId) => {
    setGroups(prev => prev.map(g =>
      g.id === groupId ? { ...g, canvas: { ...g.canvas, collapsed: !g.canvas.collapsed } } : g
    ));
  };

  /* --- M2-6: クロスリンク CRUD ハンドラ --- */
  const handleAddCrossLink = (link) => {
    setCrossLinks(prev => [...prev, { id: genId(), lineStyle: 'dashed', color: '#ff9800', ...link }]);
  };

  const handleUpdateCrossLink = (linkId, patch) => {
    setCrossLinks(prev => prev.map(cl => cl.id === linkId ? { ...cl, ...patch, id: cl.id } : cl));
  };

  const handleRemoveCrossLink = (linkId) => {
    setCrossLinks(prev => prev.filter(cl => cl.id !== linkId));
  };

  /* --- PDF出力 (§15, M2-6: グループフィルタ対応) --- */
  const handlePDF = (groupId) => {
    let filteredNodes = nodes;
    if (groupId) {
      const grp = groups.find(g => g.id === groupId);
      if (grp) filteredNodes = getGroupNodes(nodes, grp.rootNodeId);
    }
    const html = genPDF(filteredNodes, allResults);
    const w = window.open('', '_blank');
    if (w) { w.document.write(html); w.document.close(); }
    else { alert('ポップアップがブロックされました。ブラウザの設定を確認してください。'); }
  };

  /* --- M2-5: 系統図出力 (M2-6: グループフィルタ対応) --- */
  const handleDiagramOutput = (groupId) => {
    let filteredNodes = nodes;
    if (groupId) {
      const grp = groups.find(g => g.id === groupId);
      if (grp) filteredNodes = getGroupNodes(nodes, grp.rootNodeId);
    }
    const html = genDiagramHTML(filteredNodes, allResults, systemMeta);
    const w = window.open('', '_blank');
    if (w) { w.document.write(html); w.document.close(); }
    else { alert('ポップアップがブロックされました。ブラウザの設定を確認してください。'); }
  };

  /* --- レンダリング --- */
  const isMotor = params.circuitType === '電動機';
  const isCustomReduction = params.reductionPreset === 'カスタム';
  const voltageOptions = VOLTAGE_OPTIONS[params.system] || [200];
  const cableTypeOptions = getCableTypeOptions(params.system);
  const capacityLabel = params.unit === 'A' ? '電流 [A]' : `負荷容量 [${params.unit}]`;
  const sliderCfgCapacity = params.unit === 'A' ? SLIDER_CFG.capacity_A
    : params.unit === 'kVA' ? SLIDER_CFG.capacity_kVA : SLIDER_CFG.capacity_kW;
  const isGround = params.wiringMethod === '直埋布設' || params.wiringMethod === '管路布設';
  const tempBase = isGround ? 25 : 40;
  const tempFactor = getTempFactor(params.wiringMethod, params.ambientTemp);

  const isEditing = selectedId != null;
  const canRegister = editMode === 'load' && result && params.trunkName && params.capacity > 0 && params.cableLength > 0;

  return (
    <div style={{ height: '100vh', display: 'flex', flexDirection: 'column' }}>
      {/* ヘッダー (§2) */}
      <header style={{
        background: '#1976d2', color: '#fff', padding: '8px 16px',
        display: 'flex', alignItems: 'center', justifyContent: 'space-between', flexShrink: 0
      }}>
        <h1 style={{ fontSize: 18, fontWeight: 700 }}>低圧幹線ケーブル計算ツール</h1>
        <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
          <input type="file" accept=".json" ref={fileInputRef} style={{ display: 'none' }} onChange={handleImport} />
          <button onClick={() => fileInputRef.current?.click()} style={{
            padding: '4px 12px', borderRadius: 4, border: '1px solid rgba(255,255,255,0.7)',
            background: 'transparent', color: '#fff', cursor: 'pointer', fontSize: 13
          }}>Import</button>
          <button onClick={() => setShowBulkImport(true)} style={{
            padding: '4px 12px', borderRadius: 4, border: '1px solid rgba(255,255,255,0.7)',
            background: 'rgba(255,255,255,0.15)', color: '#fff', cursor: 'pointer', fontSize: 13, fontWeight: 600
          }}>一括取込</button>
          <button onClick={handleExport} disabled={nodes.length === 0} style={{
            padding: '4px 12px', borderRadius: 4, border: '1px solid rgba(255,255,255,0.7)',
            background: 'transparent', color: '#fff',
            cursor: nodes.length ? 'pointer' : 'not-allowed',
            opacity: nodes.length ? 1 : 0.5, fontSize: 13
          }}>Export</button>
          <OutputDropdown label="PDF出力" disabled={nodes.length === 0}
            groups={groups} onAll={() => handlePDF()} onGroup={(gid) => handlePDF(gid)} />
          <OutputDropdown label="系統図" disabled={nodes.length === 0}
            groups={groups} onAll={() => handleDiagramOutput()} onGroup={(gid) => handleDiagramOutput(gid)} />
        </div>
      </header>

      {/* メインコンテンツ (§2) */}
      <div style={{ display: 'flex', flex: 1, overflow: 'hidden' }}>

        {/* 左ペイン: 入力フォーム — 460px固定、独立スクロール */}
        <div style={{
          width: 460, flexShrink: 0, overflowY: 'auto',
          background: '#fff', borderRight: '1px solid #ddd', padding: 16
        }}>

          {/* モード切替タブ (M2-1: 複数変圧器サポート, M2-6: グループ管理) */}
          <div style={{ display: 'flex', gap: 4, marginBottom: 12, flexWrap: 'wrap' }}>
            <button onClick={() => { setEditMode('transformer'); setSelectedId(null); setTrParams({ ...DEFAULT_TR_PARAMS }); }}
              style={{
                padding: '6px 12px', borderRadius: 4,
                border: editMode === 'transformer' ? '2px solid #1976d2' : '1px solid #ccc',
                background: editMode === 'transformer' ? '#e3f2fd' : '#fff',
                cursor: 'pointer', fontSize: 12, fontWeight: 600
              }}>+ 変圧器</button>
            <button onClick={resetToNewLoad}
              style={{
                padding: '6px 12px', borderRadius: 4,
                border: editMode === 'load' && !isEditing ? '2px solid #1976d2' : '1px solid #ccc',
                background: editMode === 'load' && !isEditing ? '#e3f2fd' : '#fff',
                cursor: 'pointer', fontSize: 12, fontWeight: 600
              }}>+ 負荷回路</button>
            <button onClick={() => setEditMode('group')}
              style={{
                padding: '6px 12px', borderRadius: 4,
                border: editMode === 'group' ? '2px solid #1976d2' : '1px solid #ccc',
                background: editMode === 'group' ? '#e3f2fd' : '#fff',
                cursor: 'pointer', fontSize: 12, fontWeight: 600
              }}>グループ</button>
          </div>

          {/* === 変圧器フォーム === */}
          {editMode === 'transformer' && (
            <TransformerForm
              trParams={trParams} setTrParams={setTrParams}
              onSave={handleSaveTransformer} onCancel={resetToNewLoad}
              isEdit={isEditing && selectedNode?.type === 'transformer'}
            />
          )}

          {/* === 幹線フォーム === */}
          {editMode === 'trunk' && (
            <TrunkForm
              trunkParams={trunkParams} setTrunkParams={setTrunkParams}
              onSave={handleSaveTrunk} onCancel={resetToNewLoad}
              isEdit={isEditing && selectedNode?.type === 'trunk'}
              childSummary={trunkChildSummary}
            />
          )}

          {/* === グループ管理 (M2-6) === */}
          {editMode === 'group' && (
            <GroupEditor
              groups={groups} nodes={nodes} allResults={allResults} crossLinks={crossLinks}
              onUpdateGroup={handleUpdateGroup} onRemoveGroup={handleRemoveGroup}
              onAutoGroupAll={handleAutoGroupAll}
              onAddCrossLink={handleAddCrossLink} onRemoveCrossLink={handleRemoveCrossLink}
            />
          )}

          {/* === 負荷回路フォーム（既存） === */}
          {editMode === 'load' && (
            <div>
              <Sec title="回路情報">
                <RC label="幹線番号/名称">
                  <input type="text" value={params.trunkName} style={{ ...numStyle, textAlign: 'left' }}
                    onChange={e => setParams(p => ({ ...p, trunkName: e.target.value }))} placeholder="例: L-1A" />
                </RC>
                <RC label="負荷名称">
                  <input type="text" value={params.loadName} style={{ ...numStyle, textAlign: 'left' }}
                    onChange={e => setParams(p => ({ ...p, loadName: e.target.value }))} placeholder="例: 空調機" />
                </RC>
                <RC label="電気方式">
                  <select value={params.system} style={selStyle} onChange={e => updateSelect('system', e.target.value)}>
                    {['単相2線式', '単相3線式', '三相3線式', '三相4線式'].map(s => <option key={s}>{s}</option>)}
                  </select>
                </RC>
                <RC label="電圧 [V]">
                  <select value={params.voltage} style={selStyle} onChange={e => updateSelect('voltage', Number(e.target.value))}>
                    {voltageOptions.map(v => <option key={v} value={v}>{params.system === '単相3線式' ? '100/200' : v}</option>)}
                  </select>
                </RC>
                <RC label="周波数">
                  <select value={params.freq} style={selStyle} onChange={e => updateSelect('freq', e.target.value)}>
                    <option>50Hz</option><option>60Hz</option>
                  </select>
                </RC>
                <RC label="供給方式">
                  <select value={params.supplyType} style={selStyle} onChange={e => updateSelect('supplyType', e.target.value)}>
                    <option>低圧受電</option><option>高圧受電</option>
                  </select>
                </RC>
                <RC label="回路種別">
                  <select value={params.circuitType} style={selStyle} onChange={e => updateSelect('circuitType', e.target.value)}>
                    <option>一般</option><option>電動機</option>
                  </select>
                </RC>
                <RC label="MCCB AT">
                  <select value={params.mccbATOverride} style={selStyle} onChange={e => updateSelect('mccbATOverride', e.target.value)}>
                    <option>自動</option>
                    {MCCB_AT.map(at => <option key={at} value={at}>{at} AT</option>)}
                  </select>
                </RC>
                <RC label="遮断容量クラス">
                  <select value={params.icuClass} style={selStyle} onChange={e => updateSelect('icuClass', e.target.value)}>
                    <option value="standard">経済型 (standard)</option>
                    <option value="high">高遮断型 (high)</option>
                  </select>
                </RC>
              </Sec>

              <Sec title="負荷条件">
                <RC label={capacityLabel}>
                  <div style={{ display: 'flex', gap: 6 }}>
                    <div style={{ flex: 1 }}>
                      <SliderInput value={params.capacity} displayValue={display.capacity}
                        cfg={sliderCfgCapacity} min={0}
                        onChange={v => updateNumLive('capacity', v)} onConfirm={() => confirmNum('capacity')} />
                    </div>
                    <select value={params.unit} style={{ ...selStyle, width: 70, flex: 'none' }}
                      onChange={e => updateSelect('unit', e.target.value)}>
                      <option>kW</option><option>kVA</option><option>A</option>
                    </select>
                  </div>
                </RC>
                <RC label="力率 cosθ">
                  <SliderInput value={params.powerFactor} displayValue={display.powerFactor}
                    cfg={SLIDER_CFG.powerFactor} min={0.10} max={1.00}
                    onChange={v => updateNumLive('powerFactor', v)} onConfirm={() => confirmNum('powerFactor')} />
                </RC>
                <RC label="効率 η" show={isMotor}>
                  <SliderInput value={params.efficiency} displayValue={display.efficiency}
                    cfg={SLIDER_CFG.efficiency} min={0.10} max={1.00}
                    onChange={v => updateNumLive('efficiency', v)} onConfirm={() => confirmNum('efficiency')} />
                </RC>
                <RC label="需要率 [%]">
                  <SliderInput value={params.demandFactor} displayValue={display.demandFactor}
                    cfg={SLIDER_CFG.demandFactor} min={1} max={100}
                    onChange={v => updateNumLive('demandFactor', v)} onConfirm={() => confirmNum('demandFactor')} />
                </RC>
                <RC label="こう長 [m]">
                  <SliderInput value={params.cableLength} displayValue={display.cableLength}
                    cfg={SLIDER_CFG.cableLength} min={0.1}
                    onChange={v => updateNumLive('cableLength', v)} onConfirm={() => confirmNum('cableLength')} />
                </RC>
              </Sec>

              <Sec title="ケーブル条件">
                <RC label="ケーブル種類">
                  <select value={params.cableType} style={selStyle} onChange={e => updateSelect('cableType', e.target.value)}>
                    {cableTypeOptions.map(c => <option key={c}>{c}</option>)}
                  </select>
                </RC>
                <RC label="配線方式">
                  <select value={params.wiringMethod} style={selStyle} onChange={e => updateSelect('wiringMethod', e.target.value)}>
                    {['ケーブルラック配線', '配管配線', '直埋布設', '管路布設'].map(w => <option key={w}>{w}</option>)}
                  </select>
                </RC>
                <RC label="周囲温度 [℃]">
                  <SliderInput value={params.ambientTemp} displayValue={display.ambientTemp}
                    cfg={SLIDER_CFG.ambientTemp} min={20} max={50}
                    onChange={v => updateNumLive('ambientTemp', v)} onConfirm={() => confirmNum('ambientTemp')} />
                  <div style={{ fontSize: 11, color: '#888', marginTop: 2 }}>
                    基底 {tempBase}℃ → 補正係数 {rd(tempFactor, 3)}
                    {isGround ? '（地中）' : '（気中）'}
                  </div>
                </RC>
                <RC label="多条低減プリセット">
                  <select value={params.reductionPreset} style={selStyle}
                    onChange={e => updateSelect('reductionPreset', e.target.value)}>
                    {RED_PRE.map(p => (
                      <option key={p.label} value={p.label}>
                        {p.label}{p.factor !== null ? ` (${p.factor})` : ''}
                      </option>
                    ))}
                  </select>
                </RC>
                <RC label="低減率" show={isCustomReduction}>
                  <SliderInput value={params.reductionFactor} displayValue={display.reductionFactor}
                    cfg={SLIDER_CFG.reductionFactor} min={0.10} max={1.00}
                    onChange={v => updateNumLive('reductionFactor', v)} onConfirm={() => confirmNum('reductionFactor')} />
                </RC>
                {!isCustomReduction && (
                  <RC label="低減率">
                    <span style={{ fontSize: 13, color: '#333' }}>{params.reductionFactor}</span>
                  </RC>
                )}
              </Sec>

              <Sec title="地絡保護">
                <RC label="漏電遮断器 (ELCB)">
                  <select value={params.hasELCB ? 'あり' : 'なし'} style={selStyle}
                    onChange={e => updateSelect('hasELCB', e.target.value === 'あり')}>
                    <option>なし</option><option>あり</option>
                  </select>
                </RC>
                <RC label="感度電流 IΔn [mA]" show={params.hasELCB}>
                  <select value={params.elcbSensitivity_mA} style={selStyle}
                    onChange={e => updateSelect('elcbSensitivity_mA', Number(e.target.value))}>
                    {[5, 10, 15, 30, 50, 100, 200, 500, 1000].map(v => <option key={v} value={v}>{v}</option>)}
                  </select>
                </RC>
                <RC label="接地方式" show={params.hasELCB}>
                  <select value={params.groundingMethod} style={selStyle}
                    onChange={e => updateSelect('groundingMethod', e.target.value)}>
                    <option value="TT">TT 系統</option>
                    <option value="TN">TN 系統</option>
                  </select>
                </RC>
                <RC label="接地抵抗 RA [Ω]" show={params.hasELCB && params.groundingMethod === 'TT'}>
                  <SliderInput value={params.groundResistance_ohm} displayValue={display.groundResistance_ohm || params.groundResistance_ohm}
                    cfg={{ step: 1, fine: 10, coarse: 50, decimals: 0 }} min={1} max={5000}
                    onChange={v => updateNumLive('groundResistance_ohm', v)} onConfirm={() => confirmNum('groundResistance_ohm')} />
                </RC>
              </Sec>

              {/* 登録/更新ボタン */}
              {isEditing ? (
                <div style={{ display: 'flex', gap: 8 }}>
                  <button onClick={handleUpdateNode} style={{
                    flex: 1, padding: '10px', borderRadius: 6, border: 'none',
                    background: '#1976d2', color: '#fff', fontSize: 14, fontWeight: 700, cursor: 'pointer'
                  }}>更新</button>
                  <button onClick={resetToNewLoad} style={{
                    padding: '10px 16px', borderRadius: 6, border: '1px solid #ccc',
                    background: '#fff', color: '#666', fontSize: 14, cursor: 'pointer'
                  }}>取消</button>
                </div>
              ) : (
                <button onClick={handleRegisterLoad} disabled={!canRegister} style={{
                  width: '100%', padding: '10px', borderRadius: 6, border: 'none',
                  background: canRegister ? '#4caf50' : '#e0e0e0',
                  color: canRegister ? '#fff' : '#999',
                  fontSize: 14, fontWeight: 700,
                  cursor: canRegister ? 'pointer' : 'not-allowed'
                }}>+ 登録</button>
              )}
            </div>
          )}
        </div>

        {/* 右ペイン: 選定結果 + 登録一覧 / 系統図 */}
        <div style={{ flex: 1, display: 'flex', flexDirection: 'column', overflow: 'hidden', background: '#fafafa' }}>

          {/* M2: ビュー切替タブ */}
          <div style={{ display: 'flex', gap: 0, padding: '8px 16px 0', background: '#fafafa', borderBottom: '1px solid #e0e0e0', flexShrink: 0 }}>
            {[
              { key: 'table', label: 'テーブル' },
              { key: 'diagram', label: '系統図' },
              { key: 'split', label: '分割' },
              { key: 'profile', label: 'プロファイル' }
            ].map(tab => (
              <button key={tab.key} onClick={() => setRightPaneView(tab.key)}
                style={{
                  padding: '6px 16px', fontSize: 12, fontWeight: rightPaneView === tab.key ? 700 : 400,
                  border: 'none', borderBottom: rightPaneView === tab.key ? '2px solid #1976d2' : '2px solid transparent',
                  background: 'transparent', color: rightPaneView === tab.key ? '#1976d2' : '#666',
                  cursor: 'pointer'
                }}>{tab.label}</button>
            ))}
            {/* 系統図表示時: 編集/ビューモード切替 */}
            {(rightPaneView === 'diagram' || rightPaneView === 'split') && (
              <div style={{ marginLeft: 'auto', display: 'flex', gap: 4, alignItems: 'center' }}>
                <button onClick={() => setDiagramMode('edit')}
                  style={{
                    padding: '3px 10px', fontSize: 11, borderRadius: 3,
                    border: diagramMode === 'edit' ? '1px solid #1976d2' : '1px solid #ccc',
                    background: diagramMode === 'edit' ? '#e3f2fd' : '#fff',
                    color: diagramMode === 'edit' ? '#1976d2' : '#666', cursor: 'pointer'
                  }}>編集</button>
                <button onClick={() => setDiagramMode('view')}
                  style={{
                    padding: '3px 10px', fontSize: 11, borderRadius: 3,
                    border: diagramMode === 'view' ? '1px solid #1976d2' : '1px solid #ccc',
                    background: diagramMode === 'view' ? '#e3f2fd' : '#fff',
                    color: diagramMode === 'view' ? '#1976d2' : '#666', cursor: 'pointer'
                  }}>ビュー</button>
              </div>
            )}
          </div>

          {/* テーブルビュー */}
          {(rightPaneView === 'table' || rightPaneView === 'split') && (
            <div style={{
              flex: rightPaneView === 'split' ? '0 0 40%' : 1,
              overflowY: 'auto', padding: 16
            }}>
              {/* 結果パネル（モード別） */}
              {editMode === 'transformer' && (
                <TransformerResultPanel
                  result={isEditing ? selectedResult : trPreview}
                  nodes={nodes} nodeId={selectedId} allResults={allResults}
                />
              )}
              {editMode === 'trunk' && selectedResult && (
                <ResultPanel result={selectedResult} params={selectedNode?.trunk || trunkParams} />
              )}
              {editMode === 'load' && (
                <ResultPanel result={isEditing ? selectedResult : result} params={params} />
              )}

              {/* 登録一覧テーブル */}
              <div style={{
                marginTop: 24, padding: 16, background: '#fff',
                border: '1px solid #e0e0e0', borderRadius: 8
              }}>
                <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 12 }}>
                  <span style={{ fontSize: 14, fontWeight: 700, color: '#333' }}>登録一覧</span>
                  <span style={{ fontSize: 12, color: '#999' }}>{nodes.length} ノード</span>
                </div>
                <TreeTable
                  nodes={nodes} allResults={allResults} selectedId={selectedId}
                  onSelect={handleSelectNode} onDelete={handleDeleteNode}
                  onAddChild={handleAddChild}
                  groups={groups} crossLinks={crossLinks}
                  onToggleGroupCollapse={handleToggleGroupCollapse}
                />
              </div>
            </div>
          )}

          {/* 系統図ビュー */}
          {(rightPaneView === 'diagram' || rightPaneView === 'split') && (
            <div style={{ flex: rightPaneView === 'split' ? '1 1 60%' : 1, borderTop: rightPaneView === 'split' ? '1px solid #e0e0e0' : 'none' }}>
              <DiagramCanvas
                nodes={nodes} allResults={allResults} systemMeta={systemMeta}
                selectedId={selectedId} onSelectNode={handleSelectNode}
                mode={diagramMode} onNodesChange={setNodes}
                groups={groups} crossLinks={crossLinks}
                onToggleGroupCollapse={handleToggleGroupCollapse}
              />
            </div>
          )}

          {/* プロファイルビュー (M2-3-P) */}
          {rightPaneView === 'profile' && (
            <div style={{ flex: 1, overflow: 'hidden' }}>
              <ProfileTab
                nodes={nodes} allResults={allResults}
                selectedId={selectedId} onSelectNode={handleSelectNode}
              />
            </div>
          )}

        </div>

      </div>

      {/* 一括取込ダイアログ */}
      <BulkImportDialog
        open={showBulkImport}
        onClose={() => setShowBulkImport(false)}
        onImport={handleBulkImport}
      />
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
