<!DOCTYPE html>
<html lang="ja">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>低圧幹線ケーブル計算ツール</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=Noto+Sans+JP:wght@400;500;700&display=swap" rel="stylesheet">
<style>
*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
html, body { height: 100%; overflow: hidden; }
body {
  font-family: 'Noto Sans JP', 'Hiragino Kaku Gothic ProN', Meiryo, sans-serif;
  font-size: 14px;
  color: #333;
  background: #f5f5f5;
}
@media print {
  body { font-family: 'MS Gothic', 'Hiragino Kaku Gothic ProN', monospace; }
}
</style>
</head>
<body>
<div id="root"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/react/18.2.0/umd/react.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/react-dom/18.2.0/umd/react-dom.production.min.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/7.23.9/babel.min.js"></script>

<script type="text/babel">
/* === DATA TABLES === */
/* __DATA__ */

/* === TREE UTILITIES === */

function genId() {
  return typeof crypto !== 'undefined' && crypto.randomUUID
    ? crypto.randomUUID()
    : Date.now().toString(36) + Math.random().toString(36).slice(2, 8);
}

function getChildren(nodes, parentId) {
  return nodes.filter(n => n.parentId === parentId).sort((a, b) => a.order - b.order);
}

function getParent(nodes, id) {
  const node = nodes.find(n => n.id === id);
  return node && node.parentId ? nodes.find(n => n.id === node.parentId) : null;
}

function getAncestors(nodes, id) {
  const result = [];
  let cur = nodes.find(n => n.id === id);
  while (cur && cur.parentId) {
    cur = nodes.find(n => n.id === cur.parentId);
    if (cur) result.push(cur);
  }
  return result;
}

function getDepth(nodes, id) {
  let d = 0, cur = nodes.find(n => n.id === id);
  while (cur && cur.parentId) {
    cur = nodes.find(n => n.id === cur.parentId);
    d++;
  }
  return d;
}

function getDescendants(nodes, id) {
  const result = [];
  const stack = getChildren(nodes, id).slice();
  while (stack.length) {
    const n = stack.pop();
    result.push(n);
    stack.push(...getChildren(nodes, n.id));
  }
  return result;
}

function buildTree(nodes) {
  const roots = nodes.filter(n => !n.parentId).sort((a, b) => a.order - b.order);
  const attach = (node) => ({
    ...node,
    children: getChildren(nodes, node.id).map(attach)
  });
  return roots.map(attach);
}

function validateNode(nodes, node) {
  const depth = node.parentId ? getDepth(nodes, node.parentId) + 1 : 0;
  if (depth > 3) return 'depth exceeds 3';
  if (node.type === 'transformer' && depth !== 0) return 'transformer must be root';
  if (node.type === 'trunk' && depth < 1 && nodes.some(n => n.type === 'transformer')) return 'trunk must be under transformer';
  if (node.type === 'load') {
    const parent = node.parentId ? nodes.find(n => n.id === node.parentId) : null;
    if (!parent || parent.type !== 'trunk') return 'load must be under trunk';
  }
  return null;
}

function addNode(nodes, node) {
  const err = validateNode(nodes, node);
  if (err) { console.warn('addNode:', err); return nodes; }
  return [...nodes, node];
}

function updateNode(nodes, id, patch) {
  return nodes.map(n => n.id === id ? { ...n, ...patch, id: n.id, type: n.type, ts: new Date().toISOString() } : n);
}

function removeNode(nodes, id) {
  const descIds = new Set(getDescendants(nodes, id).map(n => n.id));
  descIds.add(id);
  return nodes.filter(n => !descIds.has(n.id));
}

/* === CALC ENGINE === */

/* --- 定数・ヘルパー --- */
const SIZES_CVT = [8, 14, 22, 38, 60, 100, 150, 200, 250, 325];
const SIZES_CV  = [2, 3.5, 5.5, 8, 14, 22, 38, 60, 100, 150, 200, 250, 325];

function getCableSizes(ct) {
  return (ct === 'CVT' || ct === 'CVD') ? SIZES_CVT : SIZES_CV;
}

function getImpTable(ct) {
  return (ct === 'CVT' || ct === 'CVD') ? IMP_CVT : IMP_CV;
}

function getAmpTable(wm) {
  const m = { 'ケーブルラック配線': A_RACK, '配管配線': A_COND, '直埋布設': A_DIRECT, '管路布設': A_DUCT };
  return m[wm] || A_RACK;
}

/** 基本許容電流を取得。データ未整備の場合は null */
function getBaseAmpacity(ct, wm, sz) {
  const t = getAmpTable(wm)[ct];
  if (!t) return null;
  const i = t.sizes_mm2.indexOf(sz);
  return (i >= 0 && i < t.ampacity.length) ? t.ampacity[i] : null;
}

/** インピーダンス [R, X] を取得 */
function getImpedance(ct, freq, sz) {
  const t = getImpTable(ct);
  return (t[freq] && t[freq][String(sz)]) || null;
}

/** 温度補正係数（線形補間対応） */
function getTempFactor(wm, temp) {
  const env = (wm === '直埋布設' || wm === '管路布設') ? 'ground' : 'air';
  const f = TC[env].factors;
  const ts = Object.keys(f).map(Number).sort((a, b) => a - b);
  if (temp <= ts[0]) return f[ts[0]];
  if (temp >= ts[ts.length - 1]) return f[ts[ts.length - 1]];
  for (let i = 0; i < ts.length - 1; i++) {
    if (temp >= ts[i] && temp <= ts[i + 1]) {
      return f[ts[i]] + (f[ts[i + 1]] - f[ts[i]]) * (temp - ts[i]) / (ts[i + 1] - ts[i]);
    }
  }
  return 1.0;
}

/** 電圧降下の方式係数 K と基準電圧 (§8-4) */
function getVdParams(sys, V) {
  switch (sys) {
    case '単相2線式': return { K: 2, baseV: V };
    case '単相3線式': return { K: 1, baseV: 100 };
    case '三相3線式': return { K: Math.sqrt(3), baseV: V };
    case '三相4線式': return { K: 1, baseV: V / Math.sqrt(3) };
    default: return { K: Math.sqrt(3), baseV: V };
  }
}

/** 許容電圧降下率 [%] (§8-5) */
function getAllowVdP(L, sup) {
  const h = sup === '高圧受電';
  if (L <= 60)  return h ? 3 : 2;
  if (L <= 120) return h ? 5 : 4;
  if (L <= 200) return h ? 6 : 5;
  return h ? 7 : 6;
}

/** MCCB 自動選定 (§8-6) */
function selectMCCB(dI, circuitType) {
  const th = circuitType === '電動機' ? dI * 1.25 : dI;
  for (const at of MCCB_AT) { if (at >= th) return at; }
  return MCCB_AT[MCCB_AT.length - 1];
}

function isThreePhase(sys) {
  return sys === '三相3線式' || sys === '三相4線式';
}

/** 丸めユーティリティ */
function rd(v, n = 2) { const m = Math.pow(10, n); return Math.round(v * m) / m; }

/**
 * runCalc — 子回路のケーブルサイズ選定 (§8)
 *
 * @param {Object} p - 入力パラメータ
 * @returns {Object} 計算結果（ok, size, dI, sizingI, mccbAT, 各判定フラグ等）
 */
function runCalc(p) {
  /* 8-1: 設計電流 */
  const V = p.voltage, PF = p.powerFactor, EFF = p.efficiency;
  const three = isThreePhase(p.system);
  let rawI;
  if (p.unit === 'kW') {
    rawI = three
      ? p.capacity * 1000 / (Math.sqrt(3) * V * PF * EFF)
      : p.capacity * 1000 / (V * PF * EFF);
  } else if (p.unit === 'kVA') {
    rawI = three
      ? p.capacity * 1000 / (Math.sqrt(3) * V)
      : p.capacity * 1000 / V;
  } else {
    rawI = p.capacity;
  }
  const dI = rawI * p.demandFactor / 100;

  /* 8-2: 電動機電流補正 */
  const sizingI = p.circuitType === '電動機'
    ? (dI <= 50 ? dI * 1.25 : dI * 1.1)
    : dI;

  /* 電圧降下パラメータ */
  const { K, baseV } = getVdParams(p.system, V);
  const sinT = Math.sqrt(1 - PF * PF);
  const allowVdP = getAllowVdP(p.cableLength, p.supplyType);

  /* 温度補正 */
  const tF = getTempFactor(p.wiringMethod, p.ambientTemp);

  /* MCCB（ケーブルサイズに依存しないため先に決定） */
  const mccbAT = p.mccbATOverride !== '自動'
    ? Number(p.mccbATOverride)
    : selectMCCB(dI, p.circuitType);

  const sizes = getCableSizes(p.cableType);

  /* 8-3: 3条件走査 — 許容電流→電圧降下→保護協調 */
  for (const sz of sizes) {
    /* Step 1: 許容電流 */
    const bA = getBaseAmpacity(p.cableType, p.wiringMethod, sz);
    if (bA === null) continue;
    const eA = bA * tF * p.reductionFactor;
    if (eA < sizingI) continue;

    /* Step 2: 電圧降下（精密式 R·cosθ + X·sinθ） */
    const imp = getImpedance(p.cableType, p.freq, sz);
    if (!imp) continue;
    const Z = imp[0] * PF + imp[1] * sinT;
    const vd = K * dI * (p.cableLength / 1000) * Z;
    const vdP = baseV > 0 ? vd / baseV * 100 : 0;
    if (vdP > allowVdP) continue;

    /* Step 3: 保護協調 */
    const protOK = p.circuitType === '電動機' ? eA >= mccbAT / 2.5 : eA >= mccbAT;
    if (!protOK) continue;

    return {
      ok: true, size: sz, dI: rd(dI), sizingI: rd(sizingI), mccbAT,
      baseAmpacity: bA, tempFactor: rd(tF, 3), reductionFactor: p.reductionFactor,
      effectiveAmpacity: rd(eA), Z: rd(Z, 4), K,
      vd: rd(vd), vdPercent: rd(vdP),
      allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
      ampacityOK: true, vdOK: true, protOK: true
    };
  }

  /* 全サイズ不適合 — 最大サイズで NG 結果を返す */
  const sz = sizes[sizes.length - 1];
  const bA = getBaseAmpacity(p.cableType, p.wiringMethod, sz);
  const eA = bA !== null ? bA * tF * p.reductionFactor : 0;
  const imp = getImpedance(p.cableType, p.freq, sz);
  const Z = imp ? imp[0] * PF + imp[1] * sinT : 0;
  const vd = K * dI * (p.cableLength / 1000) * Z;
  const vdP = baseV > 0 ? vd / baseV * 100 : 0;

  return {
    ok: false, size: sz, dI: rd(dI), sizingI: rd(sizingI), mccbAT,
    baseAmpacity: bA || 0, tempFactor: rd(tF, 3), reductionFactor: p.reductionFactor,
    effectiveAmpacity: rd(eA), Z: rd(Z, 4), K,
    vd: rd(vd), vdPercent: rd(vdP),
    allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
    ampacityOK: eA >= sizingI, vdOK: vdP <= allowVdP,
    protOK: p.circuitType === '電動機' ? eA >= mccbAT / 2.5 : eA >= mccbAT
  };
}

/**
 * runParentCalc — 親幹線のケーブルサイズ選定 (§9)
 *
 * @param {Array} children - 子回路の配列 [{ params, result }, ...]
 * @param {Object} cfg - 親幹線設定（cableLength, powerFactor, cableType, wiringMethod, ambientTemp, reductionFactor, mccbATOverride）
 * @returns {Object|null} 計算結果。children が空なら null
 */
function runParentCalc(children, cfg) {
  if (!children || children.length === 0) return null;

  /* 子回路の電気方式等を継承 */
  const first = children[0].params;
  const sys = first.system, V = first.voltage, freq = first.freq, sup = first.supplyType;

  /* 9-3: 設計電流の分類集計 */
  let sumIM = 0, sumIH = 0, hasMotor = false;
  for (const c of children) {
    if (c.params.circuitType === '電動機') { sumIM += c.result.dI; hasMotor = true; }
    else sumIH += c.result.dI;
  }
  const totalI = sumIM + sumIH;
  const sizingI = hasMotor
    ? (sumIM <= 50 ? sumIM * 1.25 + sumIH : sumIM * 1.1 + sumIH)
    : totalI;

  const PF = cfg.powerFactor;
  const { K, baseV } = getVdParams(sys, V);
  const sinT = Math.sqrt(1 - PF * PF);
  const allowVdP = getAllowVdP(cfg.cableLength, sup);
  const tF = getTempFactor(cfg.wiringMethod, cfg.ambientTemp);

  /* 9-4: MCCB */
  const mccbTh = hasMotor ? totalI * 1.25 : totalI;
  const mccbAT = cfg.mccbATOverride !== '自動'
    ? Number(cfg.mccbATOverride)
    : (() => { for (const at of MCCB_AT) { if (at >= mccbTh) return at; } return MCCB_AT[MCCB_AT.length - 1]; })();

  const sizes = getCableSizes(cfg.cableType);

  /* ケーブルサイズ走査 */
  for (const sz of sizes) {
    const bA = getBaseAmpacity(cfg.cableType, cfg.wiringMethod, sz);
    if (bA === null) continue;
    const eA = bA * tF * cfg.reductionFactor;
    if (eA < sizingI) continue;

    const imp = getImpedance(cfg.cableType, freq, sz);
    if (!imp) continue;
    const Z = imp[0] * PF + imp[1] * sinT;
    const vd = K * totalI * (cfg.cableLength / 1000) * Z;
    const vdP = baseV > 0 ? vd / baseV * 100 : 0;
    if (vdP > allowVdP) continue;

    /* 9-5: 保護協調 */
    const protOK = hasMotor ? eA >= mccbAT / 2.5 : eA >= mccbAT;
    if (!protOK) continue;

    return {
      ok: true, size: sz, totalI: rd(totalI), sumIM: rd(sumIM), sumIH: rd(sumIH),
      hasMotor, sizingI: rd(sizingI), mccbAT,
      baseAmpacity: bA, tempFactor: rd(tF, 3), reductionFactor: cfg.reductionFactor,
      effectiveAmpacity: rd(eA), Z: rd(Z, 4), K,
      vd: rd(vd), vdPercent: rd(vdP),
      allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
      ampacityOK: true, vdOK: true, protOK: true
    };
  }

  /* 全サイズ不適合 */
  const sz = sizes[sizes.length - 1];
  const bA = getBaseAmpacity(cfg.cableType, cfg.wiringMethod, sz);
  const eA = bA !== null ? bA * tF * cfg.reductionFactor : 0;
  const imp = getImpedance(cfg.cableType, freq, sz);
  const Z = imp ? imp[0] * PF + imp[1] * sinT : 0;
  const vd = K * totalI * (cfg.cableLength / 1000) * Z;
  const vdP = baseV > 0 ? vd / baseV * 100 : 0;

  return {
    ok: false, size: sz, totalI: rd(totalI), sumIM: rd(sumIM), sumIH: rd(sumIH),
    hasMotor, sizingI: rd(sizingI), mccbAT,
    baseAmpacity: bA || 0, tempFactor: rd(tF, 3), reductionFactor: cfg.reductionFactor,
    effectiveAmpacity: rd(eA), Z: rd(Z, 4), K,
    vd: rd(vd), vdPercent: rd(vdP),
    allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
    ampacityOK: eA >= sizingI, vdOK: vdP <= allowVdP,
    protOK: hasMotor ? eA >= mccbAT / 2.5 : eA >= mccbAT
  };
}

/**
 * calcTransformer — 変圧器ノードの計算 (§19-3)
 */
function calcTransformer(tr) {
  const S = tr.capacity_kVA * 1000;
  const Vs = tr.secondaryV;
  let Rs, Xs;
  if (tr.xrRatio != null && tr.xrRatio > 0) {
    const pctR = tr.pctZ / Math.sqrt(1 + tr.xrRatio * tr.xrRatio);
    const pctX = pctR * tr.xrRatio;
    Rs = (pctR / 100) * Vs * Vs / S;
    Xs = (pctX / 100) * Vs * Vs / S;
  } else {
    Rs = (tr.pctZ / 100) * Vs * Vs / S;
    Xs = 0;
  }
  const Zs = Math.sqrt(Rs * Rs + Xs * Xs);
  const In = isThreePhase('三相3線式') ? S / (Math.sqrt(3) * Vs) : S / Vs;
  const Isc3 = Vs / (Math.sqrt(3) * Zs);
  return { Rs, Xs, Zs, In, Isc3, pctZ: tr.pctZ, capacity_kVA: tr.capacity_kVA };
}

/**
 * aggregateCurrents — ボトムアップ電流合算 (§9-3)
 */
function aggregateCurrents(nodes, trunkId, allResults) {
  const children = getChildren(nodes, trunkId);
  let sumIM = 0, sumIH = 0;
  for (const child of children) {
    if (child.type === 'trunk') {
      const sub = aggregateCurrents(nodes, child.id, allResults);
      sumIM += sub.sumIM;
      sumIH += sub.sumIH;
    } else if (child.type === 'load') {
      const r = allResults[child.id];
      if (!r) continue;
      if (child.load.circuitType === '電動機') sumIM += r.dI;
      else sumIH += r.dI;
    }
  }
  return { sumIM, sumIH, totalI: sumIM + sumIH, hasMotor: sumIM > 0 };
}

/**
 * runTrunkCalc — 幹線ノードのケーブルサイズ選定
 */
function runTrunkCalc(trunk, agg) {
  const { sumIM, sumIH, totalI, hasMotor } = agg;
  if (totalI === 0) return null;

  const sys = trunk.system, V = trunk.voltage, freq = trunk.freq, sup = trunk.supplyType;
  const PF = trunk.powerFactor;
  const sizingI = hasMotor
    ? (sumIM <= 50 ? sumIM * 1.25 + sumIH : sumIM * 1.1 + sumIH)
    : totalI;

  const { K, baseV } = getVdParams(sys, V);
  const sinT = Math.sqrt(1 - PF * PF);
  const allowVdP = getAllowVdP(trunk.cableLength, sup);
  const tF = getTempFactor(trunk.wiringMethod, trunk.ambientTemp);

  const mccbTh = hasMotor ? totalI * 1.25 : totalI;
  const mccbAT = trunk.mccbATOverride !== '自動'
    ? Number(trunk.mccbATOverride)
    : (() => { for (const at of MCCB_AT) { if (at >= mccbTh) return at; } return MCCB_AT[MCCB_AT.length - 1]; })();

  const sizes = getCableSizes(trunk.cableType);

  for (const sz of sizes) {
    const bA = getBaseAmpacity(trunk.cableType, trunk.wiringMethod, sz);
    if (bA === null) continue;
    const eA = bA * tF * trunk.reductionFactor;
    if (eA < sizingI) continue;

    const imp = getImpedance(trunk.cableType, freq, sz);
    if (!imp) continue;
    const Z = imp[0] * PF + imp[1] * sinT;
    const vd = K * totalI * (trunk.cableLength / 1000) * Z;
    const vdP = baseV > 0 ? vd / baseV * 100 : 0;
    if (vdP > allowVdP) continue;

    const protOK = hasMotor ? eA >= mccbAT / 2.5 : eA >= mccbAT;
    if (!protOK) continue;

    return {
      ok: true, size: sz, dI: rd(totalI), totalI: rd(totalI),
      sumIM: rd(sumIM), sumIH: rd(sumIH), hasMotor, sizingI: rd(sizingI), mccbAT,
      baseAmpacity: bA, tempFactor: rd(tF, 3), reductionFactor: trunk.reductionFactor,
      effectiveAmpacity: rd(eA), Z: rd(Z, 4), K,
      vd: rd(vd), vdPercent: rd(vdP),
      allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
      ampacityOK: true, vdOK: true, protOK: true, baseV
    };
  }

  const sz = sizes[sizes.length - 1];
  const bA = getBaseAmpacity(trunk.cableType, trunk.wiringMethod, sz);
  const eA = bA !== null ? bA * tF * trunk.reductionFactor : 0;
  const imp = getImpedance(trunk.cableType, freq, sz);
  const Z = imp ? imp[0] * PF + imp[1] * sinT : 0;
  const vd = K * totalI * (trunk.cableLength / 1000) * Z;
  const vdP = baseV > 0 ? vd / baseV * 100 : 0;

  return {
    ok: false, size: sz, dI: rd(totalI), totalI: rd(totalI),
    sumIM: rd(sumIM), sumIH: rd(sumIH), hasMotor, sizingI: rd(sizingI), mccbAT,
    baseAmpacity: bA || 0, tempFactor: rd(tF, 3), reductionFactor: trunk.reductionFactor,
    effectiveAmpacity: rd(eA), Z: rd(Z, 4), K,
    vd: rd(vd), vdPercent: rd(vdP),
    allowVd: rd(baseV * allowVdP / 100), allowVdPercent: allowVdP,
    ampacityOK: eA >= sizingI, vdOK: vdP <= allowVdP,
    protOK: hasMotor ? eA >= mccbAT / 2.5 : eA >= mccbAT, baseV
  };
}

/**
 * calcCumulativeVd — トップダウン累積電圧降下 (§20-3)
 */
function calcCumulativeVd(nodes, nodeId, parentCumVd, allResults) {
  const r = allResults[nodeId];
  const cumVd = parentCumVd + (r && r.vd ? r.vd : 0);
  if (r) {
    r.cumulativeVd = rd(cumVd);
    const bV = r.baseV || (r.allowVdPercent && r.allowVd ? r.allowVd / r.allowVdPercent * 100 : 0);
    r.cumulativeVdP = bV > 0 ? rd(cumVd / bV * 100) : 0;
  }
  for (const child of getChildren(nodes, nodeId)) {
    calcCumulativeVd(nodes, child.id, cumVd, allResults);
  }
}

/**
 * calcFaultCurrents — トップダウン R+jX ベクトル累積による短絡電流計算 (§20-2, §20-3)
 */
function calcFaultCurrents(nodes, allResults) {
  const tr = nodes.find(n => n.type === 'transformer');
  if (!tr) return;
  const trR = allResults[tr.id];
  if (!trR) return;
  // M2-3: HV integration point — hvSystem impedance would be added here
  propagateFault(nodes, tr.id, trR.Rs, trR.Xs, tr.transformer.secondaryV, allResults);
}

function propagateFault(nodes, nodeId, Rcum, Xcum, Vs, allResults) {
  const r = allResults[nodeId];
  if (r) {
    r.Rcum = Rcum;
    r.Xcum = Xcum;
    r.Zcum = Math.sqrt(Rcum * Rcum + Xcum * Xcum);
    r.Isc3 = Vs / (Math.sqrt(3) * r.Zcum);
  }
  for (const child of getChildren(nodes, nodeId)) {
    let Rc = 0, Xc = 0;
    if (child.type === 'trunk' || child.type === 'load') {
      const cfg = child.type === 'trunk' ? child.trunk : child.load;
      const childR = allResults[child.id];
      if (childR && childR.size) {
        const imp = getImpedance(cfg.cableType, cfg.freq, childR.size);
        if (imp) {
          const Lkm = cfg.cableLength / 1000;
          Rc = imp[0] * Lkm;
          Xc = imp[1] * Lkm;
        }
      }
    }
    propagateFault(nodes, child.id, Rcum + Rc, Xcum + Xc, Vs, allResults);
  }
}

/**
 * checkWithstand — 短時間耐電流検証 (§20-6)
 */
function checkWithstand(size_mm2, Isc3, t) {
  t = t || 0.1;
  const K = 134; /* Cu_XLPE: WITHSTAND.K_constants.Cu_XLPE.K */
  const Iw = K * size_mm2 / Math.sqrt(t);
  return { ok: Isc3 <= Iw, Iwithstand: rd(Iw), Isc3: rd(Isc3), K, t };
}

/**
 * calculateAll — 全ノード一括計算
 */
function calculateAll(nodes) {
  const results = {};

  /* 1. ボトムアップ: 全 load ノードを計算 */
  for (const n of nodes) {
    if (n.type === 'load') results[n.id] = runCalc(n.load);
  }

  /* 2. ボトムアップ: trunk ノードを深い順に計算 */
  const trunks = nodes.filter(n => n.type === 'trunk')
    .map(n => ({ node: n, depth: getDepth(nodes, n.id) }))
    .sort((a, b) => b.depth - a.depth);
  for (const { node } of trunks) {
    const agg = aggregateCurrents(nodes, node.id, results);
    const r = runTrunkCalc(node.trunk, agg);
    if (r) results[node.id] = r;
  }

  /* 3. transformer ノード */
  for (const n of nodes) {
    if (n.type === 'transformer') results[n.id] = calcTransformer(n.transformer);
  }

  /* 4. トップダウン: 累積電圧降下 */
  const roots = nodes.filter(n => !n.parentId);
  for (const root of roots) {
    calcCumulativeVd(nodes, root.id, 0, results);
  }

  /* 5. トップダウン: 短絡電流 */
  calcFaultCurrents(nodes, results);

  // M2-3: Ground fault current Ig = 3ωCV — reserved for future

  return results;
}

/* === COMPONENTS === */

/* --- 電気方式 → 電圧選択肢 (§5) --- */
const VOLTAGE_OPTIONS = {
  '単相2線式': [100, 200],
  '単相3線式': [200],
  '三相3線式': [200, 210, 400, 415, 440],
  '三相4線式': [200]
};

/* --- ケーブル種類と電気方式の対応 (§3-3) --- */
function getCableTypeOptions(sys) {
  if (sys === '単相2線式') return ['CV-2C'];
  if (sys === '単相3線式') return ['CV-3C'];
  return ['CVT', 'CVD', 'CV-3C'];
}

/* --- スライダー感度テーブル (§7) --- */
const SLIDER_CFG = {
  capacity_kW:  { step: 0.1, range: 100 },
  capacity_kVA: { step: 0.1, range: 100 },
  capacity_A:   { step: 1,   range: 200 },
  powerFactor:  { step: 0.01, range: 0.30 },
  efficiency:   { step: 0.01, range: 0.30 },
  demandFactor: { step: 1,   range: 50 },
  cableLength:  { step: 0.5, range: 100 },
  ambientTemp:  { step: 5,   range: 15 },
  reductionFactor: { step: 0.01, range: 0.30 }
};

/* --- デフォルト入力値 (§3) --- */
const DEFAULT_PARAMS = {
  trunkName: '', loadName: '',
  system: '三相3線式', voltage: 200, freq: '60Hz', supplyType: '低圧受電',
  circuitType: '一般', mccbATOverride: '自動',
  capacity: 15, unit: 'kW', powerFactor: 0.85, efficiency: 1.0,
  demandFactor: 100, cableLength: 30,
  cableType: 'CVT', wiringMethod: 'ケーブルラック配線',
  ambientTemp: 40, reductionPreset: '1段 S=d 7列以上', reductionFactor: 0.70
};

/* --- 変圧器デフォルト (§19) --- */
const DEFAULT_TR_PARAMS = {
  name: 'TR-1', trType: '三相油入', capacity_kVA: 500,
  primaryV: 6600, secondaryV: 210,
  pctZ: 4.00, xrRatio: 2.98, connection: 'Δ-Y', pctZAuto: true,
  hvSystem: null /* P4-7: reserved for M2-3 */
};

/* --- 幹線デフォルト (§9) --- */
const DEFAULT_TRUNK_PARAMS = {
  name: '', system: '三相3線式', voltage: 210, freq: '60Hz', supplyType: '高圧受電',
  cableLength: 10, cableType: 'CVT', wiringMethod: 'ケーブルラック配線',
  ambientTemp: 40, reductionPreset: '1段 S=d 7列以上', reductionFactor: 0.70,
  powerFactor: 0.85, mccbATOverride: '自動'
};

/* --- Badge コンポーネント (§11-1) --- */
function Badge({ ok, label }) {
  return (
    <span style={{
      display: 'inline-flex', alignItems: 'center', gap: 4,
      padding: '2px 8px', borderRadius: 4, fontSize: 12, fontWeight: 700,
      color: '#fff', background: ok ? '#4caf50' : '#f44336'
    }}>
      {ok ? '○' : '×'} {label}
    </span>
  );
}

/* --- Sec セクションラッパー --- */
function Sec({ title, children }) {
  return (
    <fieldset style={{
      border: '1px solid #ddd', borderRadius: 6, padding: '8px 12px',
      marginBottom: 12
    }}>
      <legend style={{ fontSize: 13, fontWeight: 700, color: '#1976d2', padding: '0 4px' }}>{title}</legend>
      {children}
    </fieldset>
  );
}

/* --- RC フォーム行コンポーネント --- */
function RC({ label, children, show = true }) {
  if (!show) return null;
  return (
    <div style={{
      display: 'flex', alignItems: 'center', marginBottom: 6, minHeight: 30
    }}>
      <label style={{ width: 130, fontSize: 13, flexShrink: 0, color: '#555' }}>{label}</label>
      <div style={{ flex: 1 }}>{children}</div>
    </div>
  );
}

/* --- セレクトボックス共通スタイル --- */
const selStyle = {
  width: '100%', padding: '4px 6px', fontSize: 13, border: '1px solid #ccc',
  borderRadius: 4, background: '#fff', outline: 'none'
};

/* --- 数値入力共通スタイル --- */
const numStyle = {
  width: '100%', padding: '4px 6px', fontSize: 13, border: '1px solid #ccc',
  borderRadius: 4, textAlign: 'right', outline: 'none'
};

/* --- SliderInput コンポーネント (§7) --- */
function SliderInput({ value, displayValue, onChange, onConfirm, cfg, min, max, style: extraStyle }) {
  const [open, setOpen] = React.useState(false);
  const [dragging, setDragging] = React.useState(false);
  const baseRef = React.useRef(value);
  const wrapRef = React.useRef(null);

  /* ポップアップ外クリックで閉じる */
  React.useEffect(() => {
    if (!open) return;
    const handler = (e) => {
      if (wrapRef.current && !wrapRef.current.contains(e.target)) { setOpen(false); }
    };
    document.addEventListener('mousedown', handler);
    return () => document.removeEventListener('mousedown', handler);
  }, [open]);

  const clamp = (v) => {
    let c = v;
    if (min !== undefined) c = Math.max(min, c);
    if (max !== undefined) c = Math.min(max, c);
    /* ステップで丸める */
    c = Math.round(c / cfg.step) * cfg.step;
    /* 浮動小数点の丸め */
    const dp = String(cfg.step).includes('.') ? String(cfg.step).split('.')[1].length : 0;
    return Number(c.toFixed(dp));
  };

  const handleSliderChange = (e) => {
    /* range: 0~200 → center=100 → offset = (v-100)/100 * range */
    const pct = (Number(e.target.value) - 100) / 100;
    const newVal = clamp(baseRef.current + pct * cfg.range);
    onChange(newVal);
  };

  const handleSliderCommit = () => {
    setDragging(false);
    onConfirm();
    baseRef.current = value;
  };

  return (
    <div ref={wrapRef} style={{ position: 'relative' }}>
      <input
        type="text"
        value={displayValue !== undefined ? displayValue : value}
        style={{ ...numStyle, ...extraStyle }}
        onChange={(e) => {
          const v = e.target.value;
          onChange(v === '' ? '' : v);
        }}
        onFocus={() => { setOpen(true); baseRef.current = value; }}
        onBlur={(e) => {
          /* スライダー操作中はblurで確定しない */
          if (dragging) return;
          if (wrapRef.current && wrapRef.current.contains(e.relatedTarget)) return;
          const n = parseFloat(displayValue !== undefined ? displayValue : value);
          if (!isNaN(n)) { onChange(clamp(n)); }
          onConfirm();
        }}
        onKeyDown={(e) => { if (e.key === 'Enter') { e.target.blur(); } }}
      />
      {open && (
        <div style={{
          position: 'absolute', top: '100%', left: 0, right: 0, zIndex: 10,
          background: '#fff', border: '1px solid #ccc', borderRadius: 4,
          padding: '6px 8px', boxShadow: '0 2px 8px rgba(0,0,0,0.15)', marginTop: 2
        }}>
          <input
            type="range" min={0} max={200} value={100}
            style={{ width: '100%', cursor: 'pointer' }}
            onMouseDown={() => { setDragging(true); baseRef.current = typeof value === 'number' ? value : parseFloat(value) || 0; }}
            onInput={handleSliderChange}
            onMouseUp={handleSliderCommit}
            onTouchStart={() => { setDragging(true); baseRef.current = typeof value === 'number' ? value : parseFloat(value) || 0; }}
            onTouchEnd={handleSliderCommit}
          />
          <div style={{ display: 'flex', justifyContent: 'space-between', fontSize: 10, color: '#999' }}>
            <span>{clamp((typeof value === 'number' ? value : parseFloat(value) || 0) - cfg.range)}</span>
            <span>{clamp((typeof value === 'number' ? value : parseFloat(value) || 0) + cfg.range)}</span>
          </div>
        </div>
      )}
    </div>
  );
}

/* --- ResultPanel 選定結果パネル (§11) --- */
function ResultPanel({ result, params }) {
  if (!result) return <div style={{ color: '#999', padding: 16 }}>入力を完了すると結果が表示されます</div>;
  const r = result;
  const isTrunk = r.hasMotor !== undefined;
  const isMotor = isTrunk ? r.hasMotor : params.circuitType === '電動機';

  const cardStyle = {
    background: '#fff', border: '1px solid #e0e0e0', borderRadius: 8,
    padding: 16, marginBottom: 16
  };
  const dtStyle = { fontSize: 12, color: '#888', marginBottom: 2 };
  const ddStyle = { fontSize: 18, fontWeight: 700, marginBottom: 8 };
  const detailRow = { display: 'flex', justifyContent: 'space-between', fontSize: 13, padding: '3px 0', borderBottom: '1px solid #f0f0f0' };

  return (
    <div>
      {/* 総合判定 */}
      <div style={{ ...cardStyle, borderLeft: `4px solid ${r.ok ? '#4caf50' : '#f44336'}` }}>
        <div style={{ display: 'flex', alignItems: 'center', gap: 8, marginBottom: 12 }}>
          <span style={{
            fontSize: 20, fontWeight: 700,
            color: r.ok ? '#4caf50' : '#f44336'
          }}>{r.ok ? 'OK' : 'NG'}</span>
          <span style={{ fontSize: 14, color: '#666' }}>総合判定</span>
        </div>
        <div style={{ display: 'flex', gap: 8, flexWrap: 'wrap' }}>
          <Badge ok={r.ampacityOK} label="許容電流" />
          <Badge ok={r.vdOK} label="電圧降下" />
          <Badge ok={r.protOK} label="保護協調" />
        </div>
      </div>

      {/* 主要結果 (§11-2) */}
      <div style={cardStyle}>
        <div style={{ display: 'flex', gap: 16 }}>
          <div style={{ flex: 1 }}>
            <div style={dtStyle}>選定ケーブル</div>
            <div style={ddStyle}>{params.cableType} {r.size} mm²</div>
          </div>
          <div style={{ flex: 1 }}>
            <div style={dtStyle}>MCCB 定格</div>
            <div style={ddStyle}>{r.mccbAT} AT</div>
          </div>
          <div style={{ flex: 1 }}>
            <div style={dtStyle}>設計電流</div>
            <div style={ddStyle}>{r.dI} A</div>
          </div>
        </div>
        {isTrunk && r.hasMotor && (
          <div style={{ fontSize: 12, color: '#666', background: '#f5f5f5', borderRadius: 4, padding: '4px 8px', marginTop: 4 }}>
            電動機 {r.sumIM}A × {r.sumIM <= 50 ? '1.25' : '1.1'} + 一般 {r.sumIH}A = {r.sizingI}A
          </div>
        )}
        {!isTrunk && isMotor && (
          <div style={{ fontSize: 12, color: '#666', background: '#f5f5f5', borderRadius: 4, padding: '4px 8px', marginTop: 4 }}>
            サイジング電流: {r.sizingI} A（{r.dI <= 50 ? '×1.25' : '×1.1'} 補正）
          </div>
        )}
      </div>

      {/* 許容電流の詳細 */}
      <div style={cardStyle}>
        <div style={{ fontSize: 13, fontWeight: 700, marginBottom: 8, color: '#1976d2' }}>許容電流</div>
        <div style={detailRow}><span>基本許容電流</span><span>{r.baseAmpacity} A</span></div>
        <div style={detailRow}><span>温度補正係数</span><span>{r.tempFactor}</span></div>
        <div style={detailRow}><span>低減率</span><span>{r.reductionFactor}</span></div>
        <div style={{ ...detailRow, fontWeight: 700, borderBottom: 'none' }}>
          <span>実効許容電流</span>
          <span style={{ color: r.ampacityOK ? '#4caf50' : '#f44336' }}>{r.effectiveAmpacity} A</span>
        </div>
        <div style={{ fontSize: 11, color: '#999', marginTop: 4 }}>
          {r.baseAmpacity} × {r.tempFactor} × {r.reductionFactor} = {r.effectiveAmpacity} A
          {isMotor ? ` ≧ ${r.sizingI} A（サイジング電流）` : ` ≧ ${r.dI} A（設計電流）`}
        </div>
      </div>

      {/* 電圧降下の詳細 */}
      <div style={cardStyle}>
        <div style={{ fontSize: 13, fontWeight: 700, marginBottom: 8, color: '#1976d2' }}>電圧降下</div>
        <div style={detailRow}><span>合成インピーダンス Z</span><span>{r.Z} Ω/km</span></div>
        <div style={detailRow}><span>方式係数 K</span><span>{rd(r.K, 4)}</span></div>
        <div style={detailRow}><span>電圧降下</span><span style={{ color: r.vdOK ? '#4caf50' : '#f44336' }}>{r.vd} V ({r.vdPercent}%)</span></div>
        <div style={{ ...detailRow, fontWeight: 700, borderBottom: 'none' }}>
          <span>許容値</span><span>{r.allowVd} V ({r.allowVdPercent}%)</span>
        </div>
      </div>

      {/* 保護協調の詳細 */}
      <div style={cardStyle}>
        <div style={{ fontSize: 13, fontWeight: 700, marginBottom: 8, color: '#1976d2' }}>保護協調</div>
        <div style={detailRow}><span>MCCB 定格</span><span>{r.mccbAT} AT</span></div>
        {isMotor && (
          <div style={detailRow}><span>保護協調閾値 (AT/2.5)</span><span>{rd(r.mccbAT / 2.5)} A</span></div>
        )}
        <div style={{ ...detailRow, fontWeight: 700, borderBottom: 'none' }}>
          <span>実効許容電流</span>
          <span style={{ color: r.protOK ? '#4caf50' : '#f44336' }}>
            {r.effectiveAmpacity} A {isMotor ? `≧ ${rd(r.mccbAT / 2.5)} A` : `≧ ${r.mccbAT} A`}
          </span>
        </div>
      </div>

      {/* 短絡電流（変圧器接続時） */}
      {r.Isc3 != null && (
        <div style={cardStyle}>
          <div style={{ fontSize: 13, fontWeight: 700, marginBottom: 8, color: '#1976d2' }}>短絡電流</div>
          <div style={detailRow}><span>短絡電流 Isc₃</span><span>{rd(r.Isc3 / 1000, 1)} kA</span></div>
          <div style={detailRow}><span>累積 R</span><span>{rd(r.Rcum * 1000, 2)} mΩ</span></div>
          <div style={detailRow}><span>累積 X</span><span>{rd(r.Xcum * 1000, 2)} mΩ</span></div>
          {r.size && (() => {
            const wt = checkWithstand(r.size, r.Isc3, 0.1);
            return (
              <React.Fragment>
                <div style={detailRow}><span>短時間耐電流 (K=134, t=0.1s)</span><span>{rd(wt.Iwithstand / 1000, 1)} kA</span></div>
                <div style={{ ...detailRow, fontWeight: 700, borderBottom: 'none' }}>
                  <span>熱耐量</span>
                  <span><Badge ok={wt.ok} label={wt.ok ? 'OK' : 'NG'} /></span>
                </div>
              </React.Fragment>
            );
          })()}
        </div>
      )}

      {/* 累積電圧降下（ツリー内） */}
      {r.cumulativeVd != null && r.cumulativeVd > 0 && (
        <div style={cardStyle}>
          <div style={{ fontSize: 13, fontWeight: 700, marginBottom: 8, color: '#1976d2' }}>累積電圧降下</div>
          <div style={{ ...detailRow, fontWeight: 700, borderBottom: 'none' }}>
            <span>変圧器からの累積</span>
            <span>{r.cumulativeVd} V ({r.cumulativeVdP}%)</span>
          </div>
        </div>
      )}
    </div>
  );
}

/* --- TransformerResultPanel 変圧器結果パネル (§19-3) --- */
function TransformerResultPanel({ result, nodes, nodeId, allResults }) {
  if (!result) return null;
  const r = result;
  const cardStyle = { background: '#fff', border: '1px solid #e0e0e0', borderRadius: 8, padding: 16, marginBottom: 16 };
  const dtStyle = { fontSize: 12, color: '#888', marginBottom: 2 };
  const ddStyle = { fontSize: 18, fontWeight: 700, marginBottom: 8 };
  const detailRow = { display: 'flex', justifyContent: 'space-between', fontSize: 13, padding: '3px 0', borderBottom: '1px solid #f0f0f0' };

  let utilization = 0;
  if (nodeId) {
    const allLoads = getDescendants(nodes, nodeId).filter(n => n.type === 'load');
    let totalKW = 0;
    for (const l of allLoads) {
      totalKW += (l.load.capacity || 0) * (l.load.demandFactor || 100) / 100;
    }
    utilization = r.capacity_kVA > 0 ? totalKW / r.capacity_kVA * 100 : 0;
  }

  return (
    <div>
      <div style={cardStyle}>
        <div style={{ display: 'flex', gap: 16 }}>
          <div style={{ flex: 1 }}>
            <div style={dtStyle}>定格二次電流</div>
            <div style={ddStyle}>{rd(r.In)} A</div>
          </div>
          <div style={{ flex: 1 }}>
            <div style={dtStyle}>短絡電流 Isc₃</div>
            <div style={ddStyle}>{rd(r.Isc3 / 1000, 1)} kA</div>
          </div>
          <div style={{ flex: 1 }}>
            <div style={dtStyle}>利用率</div>
            <div style={ddStyle}>{rd(utilization)}%</div>
          </div>
        </div>
      </div>
      <div style={cardStyle}>
        <div style={{ fontSize: 13, fontWeight: 700, marginBottom: 8, color: '#1976d2' }}>ソースインピーダンス</div>
        <div style={detailRow}><span>Rs</span><span>{rd(r.Rs * 1000, 2)} mΩ</span></div>
        <div style={detailRow}><span>Xs</span><span>{rd(r.Xs * 1000, 2)} mΩ</span></div>
        <div style={{ ...detailRow, borderBottom: 'none' }}><span>|Zs|</span><span>{rd(r.Zs * 1000, 2)} mΩ</span></div>
      </div>
    </div>
  );
}

/* --- TransformerForm 変圧器入力フォーム (§19-1) --- */
function TransformerForm({ trParams, setTrParams, onSave, onCancel, isEdit }) {
  const getCapacities = (trType) => {
    if (trType === '三相油入') return TR_RATINGS.three_phase_oil.capacities_kVA;
    if (trType === '単相油入') return TR_RATINGS.single_phase_oil.capacities_kVA;
    if (trType === 'モールド') return TR_RATINGS.mold.capacities_kVA;
    return TR_RATINGS.three_phase_oil.capacities_kVA;
  };

  const getAutoValues = (trType, kVA) => {
    const key = String(kVA);
    if (trType === '三相油入' && TR_RATINGS.three_phase_oil.data[key]) {
      const d = TR_RATINGS.three_phase_oil.data[key];
      return { pctZ: d.pct_z, xrRatio: d.xr_ratio };
    }
    if (trType === '単相油入' && TR_RATINGS.single_phase_oil.data[key]) {
      const d = TR_RATINGS.single_phase_oil.data[key];
      return { pctZ: d.pct_z, xrRatio: d.xr_ratio };
    }
    if (trType === 'モールド' && TR_RATINGS.mold.data[key]) {
      const d = TR_RATINGS.mold.data[key];
      return { pctZ: d.pct_z_min, xrRatio: null };
    }
    return { pctZ: 4.00, xrRatio: null };
  };

  const handleTypeChange = (val) => {
    const caps = getCapacities(val);
    const kVA = caps.includes(trParams.capacity_kVA) ? trParams.capacity_kVA : caps[0];
    const auto = getAutoValues(val, kVA);
    setTrParams(p => ({
      ...p, trType: val, capacity_kVA: kVA,
      ...(p.pctZAuto ? { pctZ: auto.pctZ, xrRatio: auto.xrRatio } : {})
    }));
  };

  const handleCapacityChange = (val) => {
    const kVA = Number(val);
    const auto = getAutoValues(trParams.trType, kVA);
    setTrParams(p => ({
      ...p, capacity_kVA: kVA,
      ...(p.pctZAuto ? { pctZ: auto.pctZ, xrRatio: auto.xrRatio } : {})
    }));
  };

  const capacities = getCapacities(trParams.trType);

  return (
    <div>
      <Sec title="変圧器情報">
        <RC label="変圧器名称">
          <input type="text" value={trParams.name} style={{ ...numStyle, textAlign: 'left' }}
            onChange={e => setTrParams(p => ({ ...p, name: e.target.value }))} />
        </RC>
        <RC label="種別">
          <select value={trParams.trType} style={selStyle} onChange={e => handleTypeChange(e.target.value)}>
            <option>三相油入</option><option>単相油入</option><option>モールド</option>
          </select>
        </RC>
        <RC label="容量 [kVA]">
          <select value={trParams.capacity_kVA} style={selStyle} onChange={e => handleCapacityChange(e.target.value)}>
            {capacities.map(c => <option key={c} value={c}>{c}</option>)}
          </select>
        </RC>
        <RC label="一次電圧 [V]">
          <select value={trParams.primaryV} style={selStyle} onChange={e => setTrParams(p => ({ ...p, primaryV: Number(e.target.value) }))}>
            <option value={3300}>3300</option><option value={6600}>6600</option>
          </select>
        </RC>
        <RC label="二次電圧 [V]">
          <select value={trParams.secondaryV} style={selStyle} onChange={e => setTrParams(p => ({ ...p, secondaryV: Number(e.target.value) }))}>
            <option value={105}>105</option><option value={210}>210</option><option value={420}>420</option>
          </select>
        </RC>
        <RC label="%Z">
          <div style={{ display: 'flex', gap: 6, alignItems: 'center' }}>
            <input type="number" step="0.01" value={trParams.pctZ} style={{ ...numStyle, flex: 1 }}
              disabled={trParams.pctZAuto}
              onChange={e => setTrParams(p => ({ ...p, pctZ: parseFloat(e.target.value) || 0 }))} />
            <label style={{ fontSize: 12, whiteSpace: 'nowrap' }}>
              <input type="checkbox" checked={trParams.pctZAuto}
                onChange={e => {
                  const auto = e.target.checked;
                  const vals = getAutoValues(trParams.trType, trParams.capacity_kVA);
                  setTrParams(p => ({ ...p, pctZAuto: auto, ...(auto ? { pctZ: vals.pctZ, xrRatio: vals.xrRatio } : {}) }));
                }} /> Auto
            </label>
          </div>
          {trParams.trType === 'モールド' && (
            <div style={{ fontSize: 11, color: '#888', marginTop: 2 }}>
              ※ モールド: 短絡電流計算は最小値を使用
            </div>
          )}
        </RC>
        <RC label="X/R 比">
          <input type="number" step="0.01" value={trParams.xrRatio != null ? trParams.xrRatio : ''} style={numStyle}
            disabled={trParams.pctZAuto && trParams.trType !== 'モールド'}
            onChange={e => setTrParams(p => ({ ...p, xrRatio: e.target.value === '' ? null : parseFloat(e.target.value) }))} />
        </RC>
        <RC label="結線方式">
          <select value={trParams.connection} style={selStyle}
            onChange={e => setTrParams(p => ({ ...p, connection: e.target.value }))}>
            {['Δ-Y', 'Y-Y', 'Δ-Δ', 'Y-Δ', 'V-V'].map(c => <option key={c}>{c}</option>)}
          </select>
        </RC>
      </Sec>
      <div style={{ display: 'flex', gap: 8 }}>
        <button onClick={onSave} style={{
          flex: 1, padding: '10px', borderRadius: 6, border: 'none',
          background: '#1976d2', color: '#fff', fontSize: 14, fontWeight: 700, cursor: 'pointer'
        }}>{isEdit ? '更新' : '+ 変圧器登録'}</button>
        {isEdit && (
          <button onClick={onCancel} style={{
            padding: '10px 16px', borderRadius: 6, border: '1px solid #ccc',
            background: '#fff', color: '#666', fontSize: 14, cursor: 'pointer'
          }}>取消</button>
        )}
      </div>
    </div>
  );
}

/* --- TrunkForm 幹線入力フォーム (§9-6) --- */
function TrunkForm({ trunkParams, setTrunkParams, onSave, onCancel, isEdit, childSummary }) {
  const isCustomReduction = trunkParams.reductionPreset === 'カスタム';
  return (
    <div>
      <Sec title="幹線情報">
        <RC label="幹線名称">
          <input type="text" value={trunkParams.name} style={{ ...numStyle, textAlign: 'left' }}
            onChange={e => setTrunkParams(p => ({ ...p, name: e.target.value }))} />
        </RC>
        <RC label="電気方式">
          <span style={{ fontSize: 13 }}>{trunkParams.system} {trunkParams.voltage}V</span>
        </RC>
      </Sec>
      <Sec title="ケーブル条件">
        <RC label="こう長 [m]">
          <input type="number" step="0.5" value={trunkParams.cableLength} style={numStyle}
            onChange={e => setTrunkParams(p => ({ ...p, cableLength: parseFloat(e.target.value) || 0 }))} />
        </RC>
        <RC label="力率 cosθ">
          <input type="number" step="0.01" min="0.10" max="1.00" value={trunkParams.powerFactor} style={numStyle}
            onChange={e => setTrunkParams(p => ({ ...p, powerFactor: parseFloat(e.target.value) || 0.85 }))} />
        </RC>
        <RC label="ケーブル種類">
          <select value={trunkParams.cableType} style={selStyle}
            onChange={e => setTrunkParams(p => ({ ...p, cableType: e.target.value }))}>
            {getCableTypeOptions(trunkParams.system).map(c => <option key={c}>{c}</option>)}
          </select>
        </RC>
        <RC label="配線方式">
          <select value={trunkParams.wiringMethod} style={selStyle}
            onChange={e => setTrunkParams(p => ({ ...p, wiringMethod: e.target.value }))}>
            {['ケーブルラック配線', '配管配線', '直埋布設', '管路布設'].map(w => <option key={w}>{w}</option>)}
          </select>
        </RC>
        <RC label="周囲温度 [℃]">
          <input type="number" step="5" min="20" max="50" value={trunkParams.ambientTemp} style={numStyle}
            onChange={e => setTrunkParams(p => ({ ...p, ambientTemp: Number(e.target.value) }))} />
        </RC>
        <RC label="多条低減プリセット">
          <select value={trunkParams.reductionPreset} style={selStyle}
            onChange={e => {
              const val = e.target.value;
              const preset = RED_PRE.find(p => p.label === val);
              setTrunkParams(p => ({ ...p, reductionPreset: val, ...(preset && preset.factor !== null ? { reductionFactor: preset.factor } : {}) }));
            }}>
            {RED_PRE.map(p => <option key={p.label} value={p.label}>{p.label}{p.factor !== null ? ` (${p.factor})` : ''}</option>)}
          </select>
        </RC>
        {isCustomReduction && (
          <RC label="低減率">
            <input type="number" step="0.01" min="0.10" max="1.00" value={trunkParams.reductionFactor} style={numStyle}
              onChange={e => setTrunkParams(p => ({ ...p, reductionFactor: parseFloat(e.target.value) || 0.70 }))} />
          </RC>
        )}
        {!isCustomReduction && (
          <RC label="低減率">
            <span style={{ fontSize: 13 }}>{trunkParams.reductionFactor}</span>
          </RC>
        )}
        <RC label="MCCB AT">
          <select value={trunkParams.mccbATOverride} style={selStyle}
            onChange={e => setTrunkParams(p => ({ ...p, mccbATOverride: e.target.value }))}>
            <option>自動</option>
            {MCCB_AT.map(at => <option key={at} value={at}>{at} AT</option>)}
          </select>
        </RC>
      </Sec>
      {childSummary && (
        <div style={{ fontSize: 12, color: '#666', background: '#f5f5f5', borderRadius: 4, padding: 8, marginBottom: 12 }}>
          子回路合計: 電動機 {childSummary.sumIM.toFixed(1)}A + 一般 {childSummary.sumIH.toFixed(1)}A = {childSummary.totalI.toFixed(1)}A
        </div>
      )}
      <div style={{ display: 'flex', gap: 8 }}>
        <button onClick={onSave} style={{
          flex: 1, padding: '10px', borderRadius: 6, border: 'none',
          background: '#1976d2', color: '#fff', fontSize: 14, fontWeight: 700, cursor: 'pointer'
        }}>{isEdit ? '幹線を更新' : '+ 幹線登録'}</button>
        {isEdit && (
          <button onClick={onCancel} style={{
            padding: '10px 16px', borderRadius: 6, border: '1px solid #ccc',
            background: '#fff', color: '#666', fontSize: 14, cursor: 'pointer'
          }}>取消</button>
        )}
      </div>
    </div>
  );
}

/* --- TreeTable 登録一覧ツリー表示 (§12) --- */
function TreeTable({ nodes, allResults, selectedId, onSelect, onDelete }) {
  if (nodes.length === 0) return (
    <div style={{ color: '#999', padding: 16, fontSize: 13 }}>
      変圧器または負荷回路を登録してください
    </div>
  );

  const tree = buildTree(nodes);

  /* --- カード内ラベル+値の共通スタイル --- */
  const cellLabel = { fontSize: 10, color: '#888', marginBottom: 1 };
  const cellValue = { fontSize: 13, fontWeight: 600 };
  const infoCell = { display: 'flex', flexDirection: 'column', alignItems: 'flex-start' };
  const rowStyle = { display: 'flex', alignItems: 'center', gap: 10, padding: '3px 0' };

  const renderNode = (node, depth) => {
    const r = allResults[node.id];
    const isSelected = node.id === selectedId;
    const isTr = node.type === 'transformer';
    const isTrunk = node.type === 'trunk';
    const tag = isTr ? 'TR' : isTrunk ? '主幹' : '└';
    const name = isTr ? (node.transformer?.name || 'TR')
      : isTrunk ? (node.trunk?.name || '幹線')
      : (node.load?.loadName || '負荷');
    const sysV = isTr ? `${node.transformer?.secondaryV || ''}V`
      : isTrunk ? `${node.trunk?.system || ''} ${node.trunk?.voltage || ''}V`
      : `${node.load?.system || ''} ${node.load?.voltage || ''}V`;
    const cType = isTrunk ? (node.trunk?.cableType || '') : (node.load?.cableType || '');

    /* 左ボーダー色: OK=緑, NG=赤, 変圧器=青, 結果なし=グレー */
    const borderColor = isTr ? '#3f51b5'
      : (r && r.ok != null) ? (r.ok ? '#4caf50' : '#f44336')
      : '#bdbdbd';

    return (
      <React.Fragment key={node.id}>
        <div
          onClick={() => onSelect(node)}
          style={{
            marginLeft: depth * 24,
            marginBottom: 6,
            border: isSelected ? '2px solid #1976d2' : '1px solid #e0e0e0',
            borderLeft: `4px solid ${borderColor}`,
            borderRadius: 6,
            background: isSelected ? '#e3f2fd' : isTr ? '#e8eaf6' : isTrunk ? '#fafafa' : '#fff',
            cursor: 'pointer',
            overflow: 'hidden'
          }}
        >
          {/* ヘッダー: タグ + 名称 + 方式/電圧 + 削除 */}
          <div style={{
            display: 'flex', alignItems: 'center', padding: '5px 10px',
            borderBottom: r ? '1px solid #eee' : 'none', gap: 6
          }}>
            <span style={{
              display: 'inline-block', padding: '1px 6px', borderRadius: 3,
              fontSize: 10, fontWeight: 700,
              background: isTr ? '#3f51b5' : isTrunk ? '#78909c' : 'transparent',
              color: isTr || isTrunk ? '#fff' : '#999'
            }}>{tag}</span>
            <span style={{ fontSize: 12, fontWeight: 600, flex: 1 }}>{name}</span>
            <span style={{ fontSize: 11, color: '#888' }}>{sysV}</span>
            <button onClick={e => { e.stopPropagation(); onDelete(node.id); }}
              style={{ border: 'none', background: 'none', color: '#f44336', cursor: 'pointer', fontSize: 14, padding: '0 4px', lineHeight: 1 }}>×</button>
          </div>

          {/* 負荷/幹線: 3段レイアウト */}
          {r && !isTr && (
            <div style={{ padding: '4px 10px 6px' }}>
              {/* 1段目: 総合判定 + 選定ケーブル, MCCB定格, 設計電流 */}
              <div style={{ ...rowStyle, borderBottom: '1px solid #f0f0f0', paddingBottom: 5 }}>
                <Badge ok={r.ok} label={r.ok ? 'OK' : 'NG'} />
                <div style={{ display: 'flex', gap: 16, flex: 1 }}>
                  <div style={infoCell}>
                    <span style={cellLabel}>選定ケーブル</span>
                    <span style={cellValue}>{cType} {r.size} mm²</span>
                  </div>
                  <div style={infoCell}>
                    <span style={cellLabel}>MCCB定格</span>
                    <span style={cellValue}>{r.mccbAT} AT</span>
                  </div>
                  <div style={infoCell}>
                    <span style={cellLabel}>設計電流</span>
                    <span style={cellValue}>{r.dI} A</span>
                  </div>
                </div>
              </div>
              {/* 2段目: 許容電流 + 電圧降下 */}
              <div style={{ ...rowStyle, borderBottom: '1px solid #f0f0f0', paddingBottom: 4 }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: 6, flex: 1 }}>
                  <Badge ok={r.ampacityOK} label="許容電流" />
                  <span style={{ fontSize: 12, color: '#555' }}>{r.effectiveAmpacity} A</span>
                </div>
                <div style={{ display: 'flex', alignItems: 'center', gap: 6, flex: 1 }}>
                  <Badge ok={r.vdOK} label="電圧降下" />
                  <span style={{ fontSize: 12, color: '#555' }}>{r.vd}V ({r.vdPercent}%)</span>
                </div>
              </div>
              {/* 3段目: 保護協調 + 累積電圧降下 */}
              <div style={{ ...rowStyle, paddingTop: 4 }}>
                <div style={{ display: 'flex', alignItems: 'center', gap: 6, flex: 1 }}>
                  <Badge ok={r.protOK} label="保護協調" />
                </div>
                <div style={{ display: 'flex', alignItems: 'center', gap: 6, flex: 1 }}>
                  {r.cumulativeVd != null && r.cumulativeVd > 0 ? (
                    <React.Fragment>
                      <span style={{ fontSize: 10, color: '#888' }}>累積Vd</span>
                      <span style={{ fontSize: 12, fontWeight: 600 }}>{r.cumulativeVd}V ({r.cumulativeVdP}%)</span>
                    </React.Fragment>
                  ) : (
                    <span style={{ fontSize: 11, color: '#ccc' }}>—</span>
                  )}
                </div>
              </div>
            </div>
          )}

          {/* 変圧器: 定格情報 */}
          {r && isTr && (
            <div style={{ display: 'flex', gap: 20, padding: '6px 10px', fontSize: 12 }}>
              <div style={infoCell}>
                <span style={cellLabel}>定格二次電流</span>
                <span style={cellValue}>{rd(r.In)} A</span>
              </div>
              <div style={infoCell}>
                <span style={cellLabel}>Isc₃</span>
                <span style={cellValue}>{rd(r.Isc3 / 1000, 1)} kA</span>
              </div>
              <div style={infoCell}>
                <span style={cellLabel}>%Z</span>
                <span style={cellValue}>{r.pctZ}%</span>
              </div>
            </div>
          )}
        </div>
        {node.children && node.children.map(child => renderNode(child, depth + 1))}
      </React.Fragment>
    );
  };

  return (
    <div>
      {tree.map(node => renderNode(node, 0))}
    </div>
  );
}

/* === PDF GENERATION === */
/* TODO: P5 で実装 — genPDF */

/* === APP === */
function App() {
  /* --- State: live（表示用）と calc（計算用）の2層管理 (§6) --- */
  const [params, setParams] = React.useState({ ...DEFAULT_PARAMS });
  const [display, setDisplay] = React.useState({
    capacity: String(DEFAULT_PARAMS.capacity),
    powerFactor: String(DEFAULT_PARAMS.powerFactor),
    efficiency: String(DEFAULT_PARAMS.efficiency),
    demandFactor: String(DEFAULT_PARAMS.demandFactor),
    cableLength: String(DEFAULT_PARAMS.cableLength),
    ambientTemp: String(DEFAULT_PARAMS.ambientTemp),
    reductionFactor: String(DEFAULT_PARAMS.reductionFactor)
  });

  /* --- P4: ツリー状態 (§18-7) --- */
  const [nodes, setNodes] = React.useState([]);
  const [selectedId, setSelectedId] = React.useState(null);
  const [editMode, setEditMode] = React.useState('load');
  const [trParams, setTrParams] = React.useState({ ...DEFAULT_TR_PARAMS });
  const [trunkParams, setTrunkParams] = React.useState({ ...DEFAULT_TRUNK_PARAMS });
  const fileInputRef = React.useRef(null);

  /* --- 計算結果（フォームプレビュー用） --- */
  const result = React.useMemo(() => {
    if (editMode !== 'load' || params.capacity <= 0) return null;
    return runCalc(params);
  }, [params, editMode]);

  /* --- 全ノード一括計算 --- */
  const allResults = React.useMemo(() => {
    if (nodes.length === 0) return {};
    return calculateAll(nodes);
  }, [nodes]);

  /* --- 選択中ノードの情報 --- */
  const selectedNode = nodes.find(n => n.id === selectedId);
  const selectedResult = selectedId ? allResults[selectedId] : null;

  /* --- 変圧器プレビュー --- */
  const trPreview = React.useMemo(() => {
    if (editMode !== 'transformer') return null;
    return calcTransformer(trParams);
  }, [trParams, editMode]);

  /* --- 幹線の子回路集計 --- */
  const trunkChildSummary = React.useMemo(() => {
    if (editMode !== 'trunk' || !selectedId) return null;
    return aggregateCurrents(nodes, selectedId, allResults);
  }, [editMode, selectedId, nodes, allResults]);

  /* --- 連動制御ヘルパー (§5) --- */
  const updateSelect = (key, val) => {
    setParams(prev => {
      const next = { ...prev, [key]: val };
      if (key === 'system') {
        const voltages = VOLTAGE_OPTIONS[val];
        if (!voltages.includes(prev.voltage)) next.voltage = voltages[0];
        const cableOpts = getCableTypeOptions(val);
        if (!cableOpts.includes(prev.cableType)) next.cableType = cableOpts[0];
      }
      if (key === 'circuitType') {
        if (val === '一般') next.efficiency = 1.0;
      }
      if (key === 'reductionPreset') {
        const preset = RED_PRE.find(p => p.label === val);
        if (preset && preset.factor !== null) {
          next.reductionFactor = preset.factor;
          setDisplay(d => ({ ...d, reductionFactor: String(preset.factor) }));
        }
      }
      return next;
    });
  };

  const confirmNum = (key) => {
    const raw = display[key];
    const n = parseFloat(raw);
    if (!isNaN(n)) setParams(prev => ({ ...prev, [key]: n }));
    else setDisplay(d => ({ ...d, [key]: String(params[key]) }));
  };

  const updateNumLive = (key, val) => {
    if (typeof val === 'number') {
      setDisplay(d => ({ ...d, [key]: String(val) }));
      setParams(prev => ({ ...prev, [key]: val }));
    } else {
      setDisplay(d => ({ ...d, [key]: val }));
    }
  };

  /* --- フォームリセット --- */
  const resetToNewLoad = () => {
    setSelectedId(null);
    setEditMode('load');
    setParams({ ...DEFAULT_PARAMS });
    setDisplay({
      capacity: String(DEFAULT_PARAMS.capacity),
      powerFactor: String(DEFAULT_PARAMS.powerFactor),
      efficiency: String(DEFAULT_PARAMS.efficiency),
      demandFactor: String(DEFAULT_PARAMS.demandFactor),
      cableLength: String(DEFAULT_PARAMS.cableLength),
      ambientTemp: String(DEFAULT_PARAMS.ambientTemp),
      reductionFactor: String(DEFAULT_PARAMS.reductionFactor)
    });
  };

  /* --- CRUD: 負荷登録 --- */
  const handleRegisterLoad = () => {
    if (!result || !params.trunkName || params.capacity <= 0) return;
    setNodes(prev => {
      let updated = [...prev];
      const trNode = updated.find(n => n.type === 'transformer');
      let trunk = updated.find(n => n.type === 'trunk' && n.trunk.name === params.trunkName);
      if (!trunk) {
        const trId = trNode ? trNode.id : null;
        trunk = {
          id: genId(), type: 'trunk', parentId: trId,
          order: getChildren(updated, trId).length,
          ts: new Date().toISOString(),
          trunk: {
            ...DEFAULT_TRUNK_PARAMS, name: params.trunkName,
            system: params.system, voltage: params.voltage,
            freq: params.freq, supplyType: trNode ? '高圧受電' : params.supplyType
          }
        };
        updated = addNode(updated, trunk);
      }
      const loadNode = {
        id: genId(), type: 'load', parentId: trunk.id,
        order: getChildren(updated, trunk.id).length,
        ts: new Date().toISOString(),
        load: { ...params }
      };
      updated = addNode(updated, loadNode);
      return updated;
    });
    resetToNewLoad();
  };

  /* --- CRUD: ノード更新 --- */
  const handleUpdateNode = () => {
    if (!selectedId) return;
    const node = nodes.find(n => n.id === selectedId);
    if (!node) return;
    if (node.type === 'load') {
      setNodes(prev => updateNode(prev, selectedId, { load: { ...params } }));
    } else if (node.type === 'trunk') {
      setNodes(prev => updateNode(prev, selectedId, { trunk: { ...trunkParams } }));
    } else if (node.type === 'transformer') {
      setNodes(prev => {
        let updated = updateNode(prev, selectedId, { transformer: { ...trParams } });
        if (node.transformer.secondaryV !== trParams.secondaryV) {
          const desc = getDescendants(updated, selectedId);
          for (const d of desc) {
            if (d.type === 'trunk') updated = updateNode(updated, d.id, { trunk: { ...d.trunk, voltage: trParams.secondaryV } });
            else if (d.type === 'load') updated = updateNode(updated, d.id, { load: { ...d.load, voltage: trParams.secondaryV } });
          }
        }
        return updated;
      });
    }
    resetToNewLoad();
  };

  /* --- CRUD: ノード削除 --- */
  const handleDeleteNode = (id) => {
    setNodes(prev => removeNode(prev, id));
    if (selectedId === id) resetToNewLoad();
  };

  /* --- CRUD: 変圧器登録/更新 --- */
  const handleSaveTransformer = () => {
    if (selectedId && selectedNode?.type === 'transformer') {
      handleUpdateNode();
    } else {
      setNodes(prev => addNode(prev, {
        id: genId(), type: 'transformer', parentId: null,
        order: 0, ts: new Date().toISOString(),
        transformer: { ...trParams }
      }));
      resetToNewLoad();
    }
  };

  /* --- CRUD: 幹線更新 --- */
  const handleSaveTrunk = () => {
    if (selectedId && selectedNode?.type === 'trunk') handleUpdateNode();
  };

  /* --- 行クリック: ノード選択 --- */
  const handleSelectNode = (node) => {
    setSelectedId(node.id);
    if (node.type === 'transformer') {
      setEditMode('transformer');
      setTrParams({ ...node.transformer });
    } else if (node.type === 'trunk') {
      setEditMode('trunk');
      setTrunkParams({ ...node.trunk });
    } else {
      setEditMode('load');
      const p = { ...node.load };
      setParams(p);
      setDisplay({
        capacity: String(p.capacity), powerFactor: String(p.powerFactor),
        efficiency: String(p.efficiency), demandFactor: String(p.demandFactor),
        cableLength: String(p.cableLength), ambientTemp: String(p.ambientTemp),
        reductionFactor: String(p.reductionFactor)
      });
    }
  };

  /* --- Export (§14) --- */
  const handleExport = () => {
    const data = { version: 'P4', nodes, exportedAt: new Date().toISOString() };
    const json = JSON.stringify(data, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `幹線計算_${new Date().toISOString().slice(0,10)}.json`;
    a.click();
    URL.revokeObjectURL(url);
  };

  /* --- Import (§14) --- */
  const handleImport = (e) => {
    const file = e.target.files[0];
    if (!file) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
      try {
        const data = JSON.parse(ev.target.result);
        if (data.nodes && Array.isArray(data.nodes)) {
          const existingIds = new Set(nodes.map(n => n.id));
          const idMap = {};
          const imported = data.nodes.map(n => {
            let newId = n.id;
            if (existingIds.has(n.id)) { newId = genId(); idMap[n.id] = newId; }
            return { ...n, id: newId };
          }).map(n => ({
            ...n, parentId: n.parentId ? (idMap[n.parentId] || n.parentId) : null
          }));
          setNodes(prev => [...prev, ...imported]);
          alert(`${imported.length} ノードをインポートしました`);
        } else { alert('有効なデータが見つかりません'); }
      } catch (err) { alert('JSON の読み込みに失敗しました: ' + err.message); }
      if (fileInputRef.current) fileInputRef.current.value = '';
    };
    reader.readAsText(file);
  };

  /* --- レンダリング --- */
  const isMotor = params.circuitType === '電動機';
  const isCustomReduction = params.reductionPreset === 'カスタム';
  const voltageOptions = VOLTAGE_OPTIONS[params.system] || [200];
  const cableTypeOptions = getCableTypeOptions(params.system);
  const capacityLabel = params.unit === 'A' ? '電流 [A]' : `負荷容量 [${params.unit}]`;
  const sliderCfgCapacity = params.unit === 'A' ? SLIDER_CFG.capacity_A
    : params.unit === 'kVA' ? SLIDER_CFG.capacity_kVA : SLIDER_CFG.capacity_kW;
  const isGround = params.wiringMethod === '直埋布設' || params.wiringMethod === '管路布設';
  const tempBase = isGround ? 25 : 40;
  const tempFactor = getTempFactor(params.wiringMethod, params.ambientTemp);

  const isEditing = selectedId != null;
  const hasTr = nodes.some(n => n.type === 'transformer');
  const canRegister = editMode === 'load' && result && params.trunkName && params.capacity > 0 && params.cableLength > 0;

  return (
    <div style={{ height: '100vh', display: 'flex', flexDirection: 'column' }}>
      {/* ヘッダー (§2) */}
      <header style={{
        background: '#1976d2', color: '#fff', padding: '8px 16px',
        display: 'flex', alignItems: 'center', justifyContent: 'space-between', flexShrink: 0
      }}>
        <h1 style={{ fontSize: 18, fontWeight: 700 }}>低圧幹線ケーブル計算ツール</h1>
        <div style={{ display: 'flex', gap: 8, alignItems: 'center' }}>
          <input type="file" accept=".json" ref={fileInputRef} style={{ display: 'none' }} onChange={handleImport} />
          <button onClick={() => fileInputRef.current?.click()} style={{
            padding: '4px 12px', borderRadius: 4, border: '1px solid rgba(255,255,255,0.7)',
            background: 'transparent', color: '#fff', cursor: 'pointer', fontSize: 13
          }}>Import</button>
          <button onClick={handleExport} disabled={nodes.length === 0} style={{
            padding: '4px 12px', borderRadius: 4, border: '1px solid rgba(255,255,255,0.7)',
            background: 'transparent', color: '#fff',
            cursor: nodes.length ? 'pointer' : 'not-allowed',
            opacity: nodes.length ? 1 : 0.5, fontSize: 13
          }}>Export</button>
          <button disabled style={{
            padding: '4px 12px', borderRadius: 4, border: '1px solid rgba(255,255,255,0.5)',
            background: 'transparent', color: '#fff', cursor: 'not-allowed', opacity: 0.5, fontSize: 13
          }}>PDF出力</button>
        </div>
      </header>

      {/* メインコンテンツ (§2) */}
      <div style={{ display: 'flex', flex: 1, overflow: 'hidden' }}>

        {/* 左ペイン: 入力フォーム — 460px固定、独立スクロール */}
        <div style={{
          width: 460, flexShrink: 0, overflowY: 'auto',
          background: '#fff', borderRight: '1px solid #ddd', padding: 16
        }}>

          {/* モード切替タブ */}
          <div style={{ display: 'flex', gap: 4, marginBottom: 12, flexWrap: 'wrap' }}>
            {!hasTr && (
              <button onClick={() => { setEditMode('transformer'); setSelectedId(null); setTrParams({ ...DEFAULT_TR_PARAMS }); }}
                style={{
                  padding: '6px 12px', borderRadius: 4,
                  border: editMode === 'transformer' ? '2px solid #1976d2' : '1px solid #ccc',
                  background: editMode === 'transformer' ? '#e3f2fd' : '#fff',
                  cursor: 'pointer', fontSize: 12, fontWeight: 600
                }}>+ 変圧器</button>
            )}
            <button onClick={resetToNewLoad}
              style={{
                padding: '6px 12px', borderRadius: 4,
                border: editMode === 'load' && !isEditing ? '2px solid #1976d2' : '1px solid #ccc',
                background: editMode === 'load' && !isEditing ? '#e3f2fd' : '#fff',
                cursor: 'pointer', fontSize: 12, fontWeight: 600
              }}>+ 負荷回路</button>
          </div>

          {/* === 変圧器フォーム === */}
          {editMode === 'transformer' && (
            <TransformerForm
              trParams={trParams} setTrParams={setTrParams}
              onSave={handleSaveTransformer} onCancel={resetToNewLoad}
              isEdit={isEditing && selectedNode?.type === 'transformer'}
            />
          )}

          {/* === 幹線フォーム === */}
          {editMode === 'trunk' && (
            <TrunkForm
              trunkParams={trunkParams} setTrunkParams={setTrunkParams}
              onSave={handleSaveTrunk} onCancel={resetToNewLoad}
              isEdit={isEditing && selectedNode?.type === 'trunk'}
              childSummary={trunkChildSummary}
            />
          )}

          {/* === 負荷回路フォーム（既存） === */}
          {editMode === 'load' && (
            <div>
              <Sec title="回路情報">
                <RC label="幹線番号/名称">
                  <input type="text" value={params.trunkName} style={{ ...numStyle, textAlign: 'left' }}
                    onChange={e => setParams(p => ({ ...p, trunkName: e.target.value }))} placeholder="例: L-1A" />
                </RC>
                <RC label="負荷名称">
                  <input type="text" value={params.loadName} style={{ ...numStyle, textAlign: 'left' }}
                    onChange={e => setParams(p => ({ ...p, loadName: e.target.value }))} placeholder="例: 空調機" />
                </RC>
                <RC label="電気方式">
                  <select value={params.system} style={selStyle} onChange={e => updateSelect('system', e.target.value)}>
                    {['単相2線式', '単相3線式', '三相3線式', '三相4線式'].map(s => <option key={s}>{s}</option>)}
                  </select>
                </RC>
                <RC label="電圧 [V]">
                  <select value={params.voltage} style={selStyle} onChange={e => updateSelect('voltage', Number(e.target.value))}>
                    {voltageOptions.map(v => <option key={v} value={v}>{params.system === '単相3線式' ? '100/200' : v}</option>)}
                  </select>
                </RC>
                <RC label="周波数">
                  <select value={params.freq} style={selStyle} onChange={e => updateSelect('freq', e.target.value)}>
                    <option>50Hz</option><option>60Hz</option>
                  </select>
                </RC>
                <RC label="供給方式">
                  <select value={params.supplyType} style={selStyle} onChange={e => updateSelect('supplyType', e.target.value)}>
                    <option>低圧受電</option><option>高圧受電</option>
                  </select>
                </RC>
                <RC label="回路種別">
                  <select value={params.circuitType} style={selStyle} onChange={e => updateSelect('circuitType', e.target.value)}>
                    <option>一般</option><option>電動機</option>
                  </select>
                </RC>
                <RC label="MCCB AT">
                  <select value={params.mccbATOverride} style={selStyle} onChange={e => updateSelect('mccbATOverride', e.target.value)}>
                    <option>自動</option>
                    {MCCB_AT.map(at => <option key={at} value={at}>{at} AT</option>)}
                  </select>
                </RC>
              </Sec>

              <Sec title="負荷条件">
                <RC label={capacityLabel}>
                  <div style={{ display: 'flex', gap: 6 }}>
                    <div style={{ flex: 1 }}>
                      <SliderInput value={params.capacity} displayValue={display.capacity}
                        cfg={sliderCfgCapacity} min={0}
                        onChange={v => updateNumLive('capacity', v)} onConfirm={() => confirmNum('capacity')} />
                    </div>
                    <select value={params.unit} style={{ ...selStyle, width: 70, flex: 'none' }}
                      onChange={e => updateSelect('unit', e.target.value)}>
                      <option>kW</option><option>kVA</option><option>A</option>
                    </select>
                  </div>
                </RC>
                <RC label="力率 cosθ">
                  <SliderInput value={params.powerFactor} displayValue={display.powerFactor}
                    cfg={SLIDER_CFG.powerFactor} min={0.10} max={1.00}
                    onChange={v => updateNumLive('powerFactor', v)} onConfirm={() => confirmNum('powerFactor')} />
                </RC>
                <RC label="効率 η" show={isMotor}>
                  <SliderInput value={params.efficiency} displayValue={display.efficiency}
                    cfg={SLIDER_CFG.efficiency} min={0.10} max={1.00}
                    onChange={v => updateNumLive('efficiency', v)} onConfirm={() => confirmNum('efficiency')} />
                </RC>
                <RC label="需要率 [%]">
                  <SliderInput value={params.demandFactor} displayValue={display.demandFactor}
                    cfg={SLIDER_CFG.demandFactor} min={1} max={100}
                    onChange={v => updateNumLive('demandFactor', v)} onConfirm={() => confirmNum('demandFactor')} />
                </RC>
                <RC label="こう長 [m]">
                  <SliderInput value={params.cableLength} displayValue={display.cableLength}
                    cfg={SLIDER_CFG.cableLength} min={0.1}
                    onChange={v => updateNumLive('cableLength', v)} onConfirm={() => confirmNum('cableLength')} />
                </RC>
              </Sec>

              <Sec title="ケーブル条件">
                <RC label="ケーブル種類">
                  <select value={params.cableType} style={selStyle} onChange={e => updateSelect('cableType', e.target.value)}>
                    {cableTypeOptions.map(c => <option key={c}>{c}</option>)}
                  </select>
                </RC>
                <RC label="配線方式">
                  <select value={params.wiringMethod} style={selStyle} onChange={e => updateSelect('wiringMethod', e.target.value)}>
                    {['ケーブルラック配線', '配管配線', '直埋布設', '管路布設'].map(w => <option key={w}>{w}</option>)}
                  </select>
                </RC>
                <RC label="周囲温度 [℃]">
                  <SliderInput value={params.ambientTemp} displayValue={display.ambientTemp}
                    cfg={SLIDER_CFG.ambientTemp} min={20} max={50}
                    onChange={v => updateNumLive('ambientTemp', v)} onConfirm={() => confirmNum('ambientTemp')} />
                  <div style={{ fontSize: 11, color: '#888', marginTop: 2 }}>
                    基底 {tempBase}℃ → 補正係数 {rd(tempFactor, 3)}
                    {isGround ? '（地中）' : '（気中）'}
                  </div>
                </RC>
                <RC label="多条低減プリセット">
                  <select value={params.reductionPreset} style={selStyle}
                    onChange={e => updateSelect('reductionPreset', e.target.value)}>
                    {RED_PRE.map(p => (
                      <option key={p.label} value={p.label}>
                        {p.label}{p.factor !== null ? ` (${p.factor})` : ''}
                      </option>
                    ))}
                  </select>
                </RC>
                <RC label="低減率" show={isCustomReduction}>
                  <SliderInput value={params.reductionFactor} displayValue={display.reductionFactor}
                    cfg={SLIDER_CFG.reductionFactor} min={0.10} max={1.00}
                    onChange={v => updateNumLive('reductionFactor', v)} onConfirm={() => confirmNum('reductionFactor')} />
                </RC>
                {!isCustomReduction && (
                  <RC label="低減率">
                    <span style={{ fontSize: 13, color: '#333' }}>{params.reductionFactor}</span>
                  </RC>
                )}
              </Sec>

              {/* 登録/更新ボタン */}
              {isEditing ? (
                <div style={{ display: 'flex', gap: 8 }}>
                  <button onClick={handleUpdateNode} style={{
                    flex: 1, padding: '10px', borderRadius: 6, border: 'none',
                    background: '#1976d2', color: '#fff', fontSize: 14, fontWeight: 700, cursor: 'pointer'
                  }}>更新</button>
                  <button onClick={resetToNewLoad} style={{
                    padding: '10px 16px', borderRadius: 6, border: '1px solid #ccc',
                    background: '#fff', color: '#666', fontSize: 14, cursor: 'pointer'
                  }}>取消</button>
                </div>
              ) : (
                <button onClick={handleRegisterLoad} disabled={!canRegister} style={{
                  width: '100%', padding: '10px', borderRadius: 6, border: 'none',
                  background: canRegister ? '#4caf50' : '#e0e0e0',
                  color: canRegister ? '#fff' : '#999',
                  fontSize: 14, fontWeight: 700,
                  cursor: canRegister ? 'pointer' : 'not-allowed'
                }}>+ 登録</button>
              )}
            </div>
          )}
        </div>

        {/* 右ペイン: 選定結果 + 登録一覧 */}
        <div style={{ flex: 1, overflowY: 'auto', padding: 16, background: '#fafafa' }}>
          {/* 結果パネル（モード別） */}
          {editMode === 'transformer' && (
            <TransformerResultPanel
              result={isEditing ? selectedResult : trPreview}
              nodes={nodes} nodeId={selectedId} allResults={allResults}
            />
          )}
          {editMode === 'trunk' && selectedResult && (
            <ResultPanel result={selectedResult} params={selectedNode?.trunk || trunkParams} />
          )}
          {editMode === 'load' && (
            <ResultPanel result={isEditing ? selectedResult : result} params={params} />
          )}

          {/* 登録一覧テーブル */}
          <div style={{
            marginTop: 24, padding: 16, background: '#fff',
            border: '1px solid #e0e0e0', borderRadius: 8
          }}>
            <div style={{ display: 'flex', justifyContent: 'space-between', alignItems: 'center', marginBottom: 12 }}>
              <span style={{ fontSize: 14, fontWeight: 700, color: '#333' }}>登録一覧</span>
              <span style={{ fontSize: 12, color: '#999' }}>{nodes.length} ノード</span>
            </div>
            <TreeTable
              nodes={nodes} allResults={allResults} selectedId={selectedId}
              onSelect={handleSelectNode} onDelete={handleDeleteNode}
            />
          </div>
        </div>

      </div>
    </div>
  );
}

ReactDOM.createRoot(document.getElementById('root')).render(<App />);
</script>
</body>
</html>
